/*!
 * excalibur - 0.25.0-alpha.7566+c37e999 - 2020-12-1
 * https://github.com/excaliburjs/Excalibur
 * Copyright (c) 2020 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>
 * Licensed BSD-2-Clause
 * @preserve
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ex"] = factory();
	else
		root["ex"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/core-js/es/array/index.js":
/*!***************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/es/array/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.string.iterator */ "../../node_modules/core-js/modules/es.string.iterator.js");
__webpack_require__(/*! ../../modules/es.array.from */ "../../node_modules/core-js/modules/es.array.from.js");
__webpack_require__(/*! ../../modules/es.array.is-array */ "../../node_modules/core-js/modules/es.array.is-array.js");
__webpack_require__(/*! ../../modules/es.array.of */ "../../node_modules/core-js/modules/es.array.of.js");
__webpack_require__(/*! ../../modules/es.array.concat */ "../../node_modules/core-js/modules/es.array.concat.js");
__webpack_require__(/*! ../../modules/es.array.copy-within */ "../../node_modules/core-js/modules/es.array.copy-within.js");
__webpack_require__(/*! ../../modules/es.array.every */ "../../node_modules/core-js/modules/es.array.every.js");
__webpack_require__(/*! ../../modules/es.array.fill */ "../../node_modules/core-js/modules/es.array.fill.js");
__webpack_require__(/*! ../../modules/es.array.filter */ "../../node_modules/core-js/modules/es.array.filter.js");
__webpack_require__(/*! ../../modules/es.array.find */ "../../node_modules/core-js/modules/es.array.find.js");
__webpack_require__(/*! ../../modules/es.array.find-index */ "../../node_modules/core-js/modules/es.array.find-index.js");
__webpack_require__(/*! ../../modules/es.array.flat */ "../../node_modules/core-js/modules/es.array.flat.js");
__webpack_require__(/*! ../../modules/es.array.flat-map */ "../../node_modules/core-js/modules/es.array.flat-map.js");
__webpack_require__(/*! ../../modules/es.array.for-each */ "../../node_modules/core-js/modules/es.array.for-each.js");
__webpack_require__(/*! ../../modules/es.array.includes */ "../../node_modules/core-js/modules/es.array.includes.js");
__webpack_require__(/*! ../../modules/es.array.index-of */ "../../node_modules/core-js/modules/es.array.index-of.js");
__webpack_require__(/*! ../../modules/es.array.iterator */ "../../node_modules/core-js/modules/es.array.iterator.js");
__webpack_require__(/*! ../../modules/es.array.join */ "../../node_modules/core-js/modules/es.array.join.js");
__webpack_require__(/*! ../../modules/es.array.last-index-of */ "../../node_modules/core-js/modules/es.array.last-index-of.js");
__webpack_require__(/*! ../../modules/es.array.map */ "../../node_modules/core-js/modules/es.array.map.js");
__webpack_require__(/*! ../../modules/es.array.reduce */ "../../node_modules/core-js/modules/es.array.reduce.js");
__webpack_require__(/*! ../../modules/es.array.reduce-right */ "../../node_modules/core-js/modules/es.array.reduce-right.js");
__webpack_require__(/*! ../../modules/es.array.reverse */ "../../node_modules/core-js/modules/es.array.reverse.js");
__webpack_require__(/*! ../../modules/es.array.slice */ "../../node_modules/core-js/modules/es.array.slice.js");
__webpack_require__(/*! ../../modules/es.array.some */ "../../node_modules/core-js/modules/es.array.some.js");
__webpack_require__(/*! ../../modules/es.array.sort */ "../../node_modules/core-js/modules/es.array.sort.js");
__webpack_require__(/*! ../../modules/es.array.species */ "../../node_modules/core-js/modules/es.array.species.js");
__webpack_require__(/*! ../../modules/es.array.splice */ "../../node_modules/core-js/modules/es.array.splice.js");
__webpack_require__(/*! ../../modules/es.array.unscopables.flat */ "../../node_modules/core-js/modules/es.array.unscopables.flat.js");
__webpack_require__(/*! ../../modules/es.array.unscopables.flat-map */ "../../node_modules/core-js/modules/es.array.unscopables.flat-map.js");
var path = __webpack_require__(/*! ../../internals/path */ "../../node_modules/core-js/internals/path.js");

module.exports = path.Array;


/***/ }),

/***/ "../../node_modules/core-js/es/function/index.js":
/*!******************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/es/function/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.function.bind */ "../../node_modules/core-js/modules/es.function.bind.js");
__webpack_require__(/*! ../../modules/es.function.name */ "../../node_modules/core-js/modules/es.function.name.js");
__webpack_require__(/*! ../../modules/es.function.has-instance */ "../../node_modules/core-js/modules/es.function.has-instance.js");
var path = __webpack_require__(/*! ../../internals/path */ "../../node_modules/core-js/internals/path.js");

module.exports = path.Function;


/***/ }),

/***/ "../../node_modules/core-js/es/object/index.js":
/*!****************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/es/object/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.symbol */ "../../node_modules/core-js/modules/es.symbol.js");
__webpack_require__(/*! ../../modules/es.object.assign */ "../../node_modules/core-js/modules/es.object.assign.js");
__webpack_require__(/*! ../../modules/es.object.create */ "../../node_modules/core-js/modules/es.object.create.js");
__webpack_require__(/*! ../../modules/es.object.define-property */ "../../node_modules/core-js/modules/es.object.define-property.js");
__webpack_require__(/*! ../../modules/es.object.define-properties */ "../../node_modules/core-js/modules/es.object.define-properties.js");
__webpack_require__(/*! ../../modules/es.object.entries */ "../../node_modules/core-js/modules/es.object.entries.js");
__webpack_require__(/*! ../../modules/es.object.freeze */ "../../node_modules/core-js/modules/es.object.freeze.js");
__webpack_require__(/*! ../../modules/es.object.from-entries */ "../../node_modules/core-js/modules/es.object.from-entries.js");
__webpack_require__(/*! ../../modules/es.object.get-own-property-descriptor */ "../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js");
__webpack_require__(/*! ../../modules/es.object.get-own-property-descriptors */ "../../node_modules/core-js/modules/es.object.get-own-property-descriptors.js");
__webpack_require__(/*! ../../modules/es.object.get-own-property-names */ "../../node_modules/core-js/modules/es.object.get-own-property-names.js");
__webpack_require__(/*! ../../modules/es.object.get-prototype-of */ "../../node_modules/core-js/modules/es.object.get-prototype-of.js");
__webpack_require__(/*! ../../modules/es.object.is */ "../../node_modules/core-js/modules/es.object.is.js");
__webpack_require__(/*! ../../modules/es.object.is-extensible */ "../../node_modules/core-js/modules/es.object.is-extensible.js");
__webpack_require__(/*! ../../modules/es.object.is-frozen */ "../../node_modules/core-js/modules/es.object.is-frozen.js");
__webpack_require__(/*! ../../modules/es.object.is-sealed */ "../../node_modules/core-js/modules/es.object.is-sealed.js");
__webpack_require__(/*! ../../modules/es.object.keys */ "../../node_modules/core-js/modules/es.object.keys.js");
__webpack_require__(/*! ../../modules/es.object.prevent-extensions */ "../../node_modules/core-js/modules/es.object.prevent-extensions.js");
__webpack_require__(/*! ../../modules/es.object.seal */ "../../node_modules/core-js/modules/es.object.seal.js");
__webpack_require__(/*! ../../modules/es.object.set-prototype-of */ "../../node_modules/core-js/modules/es.object.set-prototype-of.js");
__webpack_require__(/*! ../../modules/es.object.values */ "../../node_modules/core-js/modules/es.object.values.js");
__webpack_require__(/*! ../../modules/es.object.to-string */ "../../node_modules/core-js/modules/es.object.to-string.js");
__webpack_require__(/*! ../../modules/es.object.define-getter */ "../../node_modules/core-js/modules/es.object.define-getter.js");
__webpack_require__(/*! ../../modules/es.object.define-setter */ "../../node_modules/core-js/modules/es.object.define-setter.js");
__webpack_require__(/*! ../../modules/es.object.lookup-getter */ "../../node_modules/core-js/modules/es.object.lookup-getter.js");
__webpack_require__(/*! ../../modules/es.object.lookup-setter */ "../../node_modules/core-js/modules/es.object.lookup-setter.js");
__webpack_require__(/*! ../../modules/es.json.to-string-tag */ "../../node_modules/core-js/modules/es.json.to-string-tag.js");
__webpack_require__(/*! ../../modules/es.math.to-string-tag */ "../../node_modules/core-js/modules/es.math.to-string-tag.js");
__webpack_require__(/*! ../../modules/es.reflect.to-string-tag */ "../../node_modules/core-js/modules/es.reflect.to-string-tag.js");
var path = __webpack_require__(/*! ../../internals/path */ "../../node_modules/core-js/internals/path.js");

module.exports = path.Object;


/***/ }),

/***/ "../../node_modules/core-js/internals/a-function.js":
/*!*********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/a-function.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/a-possible-prototype.js":
/*!*******************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/a-possible-prototype.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/add-to-unscopables.js":
/*!*****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/add-to-unscopables.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");
var create = __webpack_require__(/*! ../internals/object-create */ "../../node_modules/core-js/internals/object-create.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/an-object.js":
/*!********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/an-object.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/array-copy-within.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-copy-within.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "../../node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");

var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/array-fill.js":
/*!*********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-fill.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "../../node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/array-for-each.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-for-each.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $forEach = __webpack_require__(/*! ../internals/array-iteration */ "../../node_modules/core-js/internals/array-iteration.js").forEach;
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "../../node_modules/core-js/internals/array-method-is-strict.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var STRICT_METHOD = arrayMethodIsStrict('forEach');
var USES_TO_LENGTH = arrayMethodUsesToLength('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
module.exports = (!STRICT_METHOD || !USES_TO_LENGTH) ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;


/***/ }),

/***/ "../../node_modules/core-js/internals/array-from.js":
/*!*********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-from.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "../../node_modules/core-js/internals/function-bind-context.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "../../node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "../../node_modules/core-js/internals/is-array-iterator-method.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "../../node_modules/core-js/internals/create-property.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "../../node_modules/core-js/internals/get-iterator-method.js");

// `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/array-includes.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-includes.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "../../node_modules/core-js/internals/to-absolute-index.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "../../node_modules/core-js/internals/array-iteration.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-iteration.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "../../node_modules/core-js/internals/function-bind-context.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "../../node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "../../node_modules/core-js/internals/array-species-create.js");

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_OUT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push.call(target, value); // filterOut
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterOut` method
  // https://github.com/tc39/proposal-array-filtering
  filterOut: createMethod(7)
};


/***/ }),

/***/ "../../node_modules/core-js/internals/array-last-index-of.js":
/*!******************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-last-index-of.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "../../node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "../../node_modules/core-js/internals/array-method-is-strict.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var min = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : nativeLastIndexOf;


/***/ }),

/***/ "../../node_modules/core-js/internals/array-method-has-species-support.js":
/*!*******************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-method-has-species-support.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "../../node_modules/core-js/internals/engine-v8-version.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "../../node_modules/core-js/internals/array-method-is-strict.js":
/*!*********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-method-is-strict.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ "../../node_modules/core-js/internals/array-method-uses-to-length.js":
/*!**************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-method-uses-to-length.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");

var defineProperty = Object.defineProperty;
var cache = {};

var thrower = function (it) { throw it; };

module.exports = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;

  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !DESCRIPTORS) return true;
    var O = { length: -1 };

    if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
    else O[1] = 1;

    method.call(O, argument0, argument1);
  });
};


/***/ }),

/***/ "../../node_modules/core-js/internals/array-reduce.js":
/*!***********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-reduce.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "../../node_modules/core-js/internals/a-function.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "../../node_modules/core-js/internals/indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ "../../node_modules/core-js/internals/array-species-create.js":
/*!*******************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/array-species-create.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "../../node_modules/core-js/internals/is-array.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/call-with-safe-iteration-closing.js":
/*!*******************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "../../node_modules/core-js/internals/an-object.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "../../node_modules/core-js/internals/iterator-close.js");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    iteratorClose(iterator);
    throw error;
  }
};


/***/ }),

/***/ "../../node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!*****************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/classof-raw.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/classof-raw.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/classof.js":
/*!******************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/classof.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "../../node_modules/core-js/internals/to-string-tag-support.js");
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "../../node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/copy-constructor-properties.js":
/*!**************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/copy-constructor-properties.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "../../node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "../../node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "../../node_modules/core-js/internals/correct-prototype-getter.js":
/*!***********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/correct-prototype-getter.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "../../node_modules/core-js/internals/create-iterator-constructor.js":
/*!**************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/create-iterator-constructor.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "../../node_modules/core-js/internals/iterators-core.js").IteratorPrototype;
var create = __webpack_require__(/*! ../internals/object-create */ "../../node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "../../node_modules/core-js/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "../../node_modules/core-js/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "../../node_modules/core-js/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/create-non-enumerable-property.js":
/*!*****************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "../../node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/create-property-descriptor.js":
/*!*************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/create-property-descriptor.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "../../node_modules/core-js/internals/create-property.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/create-property.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "../../node_modules/core-js/internals/to-primitive.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "../../node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/define-iterator.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/define-iterator.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "../../node_modules/core-js/internals/create-iterator-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "../../node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "../../node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "../../node_modules/core-js/internals/set-to-string-tag.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "../../node_modules/core-js/internals/create-non-enumerable-property.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "../../node_modules/core-js/internals/redefine.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "../../node_modules/core-js/internals/is-pure.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "../../node_modules/core-js/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "../../node_modules/core-js/internals/iterators-core.js");

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/define-well-known-symbol.js":
/*!***********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/define-well-known-symbol.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "../../node_modules/core-js/internals/path.js");
var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "../../node_modules/core-js/internals/well-known-symbol-wrapped.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js").f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "../../node_modules/core-js/internals/descriptors.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/descriptors.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");

// Thank's IE8 for his funny defineProperty
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "../../node_modules/core-js/internals/document-create-element.js":
/*!**********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/document-create-element.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "../../node_modules/core-js/internals/engine-is-node.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/engine-is-node.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "../../node_modules/core-js/internals/classof-raw.js");
var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");

module.exports = classof(global.process) == 'process';


/***/ }),

/***/ "../../node_modules/core-js/internals/engine-user-agent.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/engine-user-agent.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "../../node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "../../node_modules/core-js/internals/engine-v8-version.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/engine-v8-version.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "../../node_modules/core-js/internals/engine-user-agent.js");

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ "../../node_modules/core-js/internals/enum-bug-keys.js":
/*!************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/enum-bug-keys.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "../../node_modules/core-js/internals/export.js":
/*!*****************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/export.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "../../node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "../../node_modules/core-js/internals/create-non-enumerable-property.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "../../node_modules/core-js/internals/redefine.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "../../node_modules/core-js/internals/set-global.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "../../node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "../../node_modules/core-js/internals/is-forced.js");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "../../node_modules/core-js/internals/fails.js":
/*!****************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/fails.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "../../node_modules/core-js/internals/flatten-into-array.js":
/*!*****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/flatten-into-array.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray = __webpack_require__(/*! ../internals/is-array */ "../../node_modules/core-js/internals/is-array.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "../../node_modules/core-js/internals/function-bind-context.js");

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),

/***/ "../../node_modules/core-js/internals/freezing.js":
/*!*******************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/freezing.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "../../node_modules/core-js/internals/function-bind-context.js":
/*!********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/function-bind-context.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "../../node_modules/core-js/internals/a-function.js");

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "../../node_modules/core-js/internals/function-bind.js":
/*!************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/function-bind.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(/*! ../internals/a-function */ "../../node_modules/core-js/internals/a-function.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/get-built-in.js":
/*!***********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/get-built-in.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "../../node_modules/core-js/internals/path.js");
var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "../../node_modules/core-js/internals/get-iterator-method.js":
/*!******************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/get-iterator-method.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ "../../node_modules/core-js/internals/classof.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "../../node_modules/core-js/internals/iterators.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "../../node_modules/core-js/internals/global.js":
/*!*****************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/global.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func
  (function () { return this; })() || Function('return this')();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/core-js/internals/has.js":
/*!**************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/has.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/hidden-keys.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/hidden-keys.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "../../node_modules/core-js/internals/html.js":
/*!***************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/html.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "../../node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "../../node_modules/core-js/internals/ie8-dom-define.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/ie8-dom-define.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "../../node_modules/core-js/internals/document-create-element.js");

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "../../node_modules/core-js/internals/indexed-object.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/indexed-object.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "../../node_modules/core-js/internals/classof-raw.js");

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "../../node_modules/core-js/internals/inspect-source.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/inspect-source.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ../internals/shared-store */ "../../node_modules/core-js/internals/shared-store.js");

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "../../node_modules/core-js/internals/internal-metadata.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/internal-metadata.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "../../node_modules/core-js/internals/hidden-keys.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");
var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js").f;
var uid = __webpack_require__(/*! ../internals/uid */ "../../node_modules/core-js/internals/uid.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "../../node_modules/core-js/internals/freezing.js");

var METADATA = uid('meta');
var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + ++id, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "../../node_modules/core-js/internals/internal-state.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/internal-state.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "../../node_modules/core-js/internals/native-weak-map.js");
var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "../../node_modules/core-js/internals/create-non-enumerable-property.js");
var objectHas = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "../../node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "../../node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "../../node_modules/core-js/internals/hidden-keys.js");

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "../../node_modules/core-js/internals/is-array-iterator-method.js":
/*!***********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/is-array-iterator-method.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "../../node_modules/core-js/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/is-array.js":
/*!*******************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/is-array.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "../../node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ "../../node_modules/core-js/internals/is-forced.js":
/*!********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/is-forced.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "../../node_modules/core-js/internals/is-object.js":
/*!********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/is-object.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "../../node_modules/core-js/internals/is-pure.js":
/*!******************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/is-pure.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "../../node_modules/core-js/internals/iterate.js":
/*!******************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/iterate.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "../../node_modules/core-js/internals/an-object.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "../../node_modules/core-js/internals/is-array-iterator-method.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "../../node_modules/core-js/internals/function-bind-context.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "../../node_modules/core-js/internals/get-iterator-method.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "../../node_modules/core-js/internals/iterator-close.js");

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/iterator-close.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/iterator-close.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "../../node_modules/core-js/internals/an-object.js");

module.exports = function (iterator) {
  var returnMethod = iterator['return'];
  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};


/***/ }),

/***/ "../../node_modules/core-js/internals/iterators-core.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/iterators-core.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "../../node_modules/core-js/internals/object-get-prototype-of.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "../../node_modules/core-js/internals/create-non-enumerable-property.js");
var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "../../node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "../../node_modules/core-js/internals/iterators.js":
/*!********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/iterators.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "../../node_modules/core-js/internals/native-symbol.js":
/*!************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/native-symbol.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});


/***/ }),

/***/ "../../node_modules/core-js/internals/native-weak-map.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/native-weak-map.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "../../node_modules/core-js/internals/inspect-source.js");

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "../../node_modules/core-js/internals/object-assign.js":
/*!************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-assign.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "../../node_modules/core-js/internals/object-keys.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "../../node_modules/core-js/internals/object-get-own-property-symbols.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "../../node_modules/core-js/internals/object-property-is-enumerable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "../../node_modules/core-js/internals/indexed-object.js");

var nativeAssign = Object.assign;
var defineProperty = Object.defineProperty;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
module.exports = !nativeAssign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  } return T;
} : nativeAssign;


/***/ }),

/***/ "../../node_modules/core-js/internals/object-create.js":
/*!************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-create.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "../../node_modules/core-js/internals/an-object.js");
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "../../node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "../../node_modules/core-js/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "../../node_modules/core-js/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "../../node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "../../node_modules/core-js/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "../../node_modules/core-js/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/object-define-properties.js":
/*!***********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-define-properties.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "../../node_modules/core-js/internals/an-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "../../node_modules/core-js/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/object-define-property.js":
/*!*********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-define-property.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "../../node_modules/core-js/internals/ie8-dom-define.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "../../node_modules/core-js/internals/an-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "../../node_modules/core-js/internals/to-primitive.js");

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!*********************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "../../node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "../../node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "../../node_modules/core-js/internals/to-primitive.js");
var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "../../node_modules/core-js/internals/ie8-dom-define.js");

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/object-get-own-property-names-external.js":
/*!*************************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-get-own-property-names-external.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "../../node_modules/core-js/internals/object-get-own-property-names.js").f;

var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "../../node_modules/core-js/internals/object-get-own-property-names.js":
/*!****************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-get-own-property-names.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "../../node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "../../node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!******************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "../../node_modules/core-js/internals/object-get-prototype-of.js":
/*!**********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-get-prototype-of.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "../../node_modules/core-js/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "../../node_modules/core-js/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/object-keys-internal.js":
/*!*******************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-keys-internal.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var indexOf = __webpack_require__(/*! ../internals/array-includes */ "../../node_modules/core-js/internals/array-includes.js").indexOf;
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "../../node_modules/core-js/internals/hidden-keys.js");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/object-keys.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-keys.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "../../node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "../../node_modules/core-js/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/object-property-is-enumerable.js":
/*!****************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ "../../node_modules/core-js/internals/object-prototype-accessors-forced.js":
/*!********************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-prototype-accessors-forced.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "../../node_modules/core-js/internals/is-pure.js");
var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");

// Forced replacement object prototype accessors methods
module.exports = IS_PURE || !fails(function () {
  var key = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, key, function () { /* empty */ });
  delete global[key];
});


/***/ }),

/***/ "../../node_modules/core-js/internals/object-set-prototype-of.js":
/*!**********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-set-prototype-of.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "../../node_modules/core-js/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "../../node_modules/core-js/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "../../node_modules/core-js/internals/object-to-array.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-to-array.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "../../node_modules/core-js/internals/object-keys.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var propertyIsEnumerable = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "../../node_modules/core-js/internals/object-property-is-enumerable.js").f;

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),

/***/ "../../node_modules/core-js/internals/object-to-string.js":
/*!***************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/object-to-string.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "../../node_modules/core-js/internals/to-string-tag-support.js");
var classof = __webpack_require__(/*! ../internals/classof */ "../../node_modules/core-js/internals/classof.js");

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "../../node_modules/core-js/internals/own-keys.js":
/*!*******************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/own-keys.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "../../node_modules/core-js/internals/get-built-in.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "../../node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "../../node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "../../node_modules/core-js/internals/an-object.js");

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/path.js":
/*!***************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/path.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");

module.exports = global;


/***/ }),

/***/ "../../node_modules/core-js/internals/redefine.js":
/*!*******************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/redefine.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "../../node_modules/core-js/internals/create-non-enumerable-property.js");
var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "../../node_modules/core-js/internals/set-global.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "../../node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "../../node_modules/core-js/internals/internal-state.js");

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "../../node_modules/core-js/internals/require-object-coercible.js":
/*!***********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/require-object-coercible.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/same-value.js":
/*!*********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/same-value.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/set-global.js":
/*!*********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/set-global.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "../../node_modules/core-js/internals/create-non-enumerable-property.js");

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "../../node_modules/core-js/internals/set-species.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/set-species.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "../../node_modules/core-js/internals/get-built-in.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "../../node_modules/core-js/internals/set-to-string-tag.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/set-to-string-tag.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js").f;
var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "../../node_modules/core-js/internals/shared-key.js":
/*!*********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/shared-key.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ../internals/shared */ "../../node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "../../node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "../../node_modules/core-js/internals/shared-store.js":
/*!***********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/shared-store.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "../../node_modules/core-js/internals/set-global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "../../node_modules/core-js/internals/shared.js":
/*!*****************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/shared.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "../../node_modules/core-js/internals/is-pure.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "../../node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.8.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "../../node_modules/core-js/internals/string-multibyte.js":
/*!***************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/string-multibyte.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "../../node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "../../node_modules/core-js/internals/require-object-coercible.js");

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "../../node_modules/core-js/internals/to-absolute-index.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/to-absolute-index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "../../node_modules/core-js/internals/to-integer.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/to-indexed-object.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/to-indexed-object.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "../../node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "../../node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "../../node_modules/core-js/internals/to-integer.js":
/*!*********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/to-integer.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/to-length.js":
/*!********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/to-length.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "../../node_modules/core-js/internals/to-integer.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "../../node_modules/core-js/internals/to-object.js":
/*!********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/to-object.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "../../node_modules/core-js/internals/require-object-coercible.js");

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "../../node_modules/core-js/internals/to-primitive.js":
/*!***********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/to-primitive.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "../../node_modules/core-js/internals/to-string-tag-support.js":
/*!********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/to-string-tag-support.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "../../node_modules/core-js/internals/uid.js":
/*!**************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/uid.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ "../../node_modules/core-js/internals/use-symbol-as-uid.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "../../node_modules/core-js/internals/native-symbol.js");

module.exports = NATIVE_SYMBOL
  // eslint-disable-next-line no-undef
  && !Symbol.sham
  // eslint-disable-next-line no-undef
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "../../node_modules/core-js/internals/well-known-symbol-wrapped.js":
/*!************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/well-known-symbol-wrapped.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "../../node_modules/core-js/internals/well-known-symbol.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/internals/well-known-symbol.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "../../node_modules/core-js/internals/shared.js");
var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var uid = __webpack_require__(/*! ../internals/uid */ "../../node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "../../node_modules/core-js/internals/native-symbol.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "../../node_modules/core-js/internals/use-symbol-as-uid.js");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.concat.js":
/*!************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.concat.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "../../node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "../../node_modules/core-js/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "../../node_modules/core-js/internals/array-species-create.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "../../node_modules/core-js/internals/array-method-has-species-support.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "../../node_modules/core-js/internals/engine-v8-version.js");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, forced: FORCED }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.copy-within.js":
/*!*****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.copy-within.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var copyWithin = __webpack_require__(/*! ../internals/array-copy-within */ "../../node_modules/core-js/internals/array-copy-within.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "../../node_modules/core-js/internals/add-to-unscopables.js");

// `Array.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
$({ target: 'Array', proto: true }, {
  copyWithin: copyWithin
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('copyWithin');


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.every.js":
/*!***********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.every.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $every = __webpack_require__(/*! ../internals/array-iteration */ "../../node_modules/core-js/internals/array-iteration.js").every;
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "../../node_modules/core-js/internals/array-method-is-strict.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var STRICT_METHOD = arrayMethodIsStrict('every');
var USES_TO_LENGTH = arrayMethodUsesToLength('every');

// `Array.prototype.every` method
// https://tc39.github.io/ecma262/#sec-array.prototype.every
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.fill.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.fill.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var fill = __webpack_require__(/*! ../internals/array-fill */ "../../node_modules/core-js/internals/array-fill.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "../../node_modules/core-js/internals/add-to-unscopables.js");

// `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.filter.js":
/*!************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.filter.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $filter = __webpack_require__(/*! ../internals/array-iteration */ "../../node_modules/core-js/internals/array-iteration.js").filter;
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "../../node_modules/core-js/internals/array-method-has-species-support.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
// Edge 14- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('filter');

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.find-index.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.find-index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $findIndex = __webpack_require__(/*! ../internals/array-iteration */ "../../node_modules/core-js/internals/array-iteration.js").findIndex;
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "../../node_modules/core-js/internals/add-to-unscopables.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.find.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.find.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $find = __webpack_require__(/*! ../internals/array-iteration */ "../../node_modules/core-js/internals/array-iteration.js").find;
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "../../node_modules/core-js/internals/add-to-unscopables.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var FIND = 'find';
var SKIPS_HOLES = true;

var USES_TO_LENGTH = arrayMethodUsesToLength(FIND);

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.flat-map.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.flat-map.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var flattenIntoArray = __webpack_require__(/*! ../internals/flatten-into-array */ "../../node_modules/core-js/internals/flatten-into-array.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "../../node_modules/core-js/internals/a-function.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "../../node_modules/core-js/internals/array-species-create.js");

// `Array.prototype.flatMap` method
// https://github.com/tc39/proposal-flatMap
$({ target: 'Array', proto: true }, {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A;
    aFunction(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.flat.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.flat.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var flattenIntoArray = __webpack_require__(/*! ../internals/flatten-into-array */ "../../node_modules/core-js/internals/flatten-into-array.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "../../node_modules/core-js/internals/to-integer.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "../../node_modules/core-js/internals/array-species-create.js");

// `Array.prototype.flat` method
// https://github.com/tc39/proposal-flatMap
$({ target: 'Array', proto: true }, {
  flat: function flat(/* depthArg = 1 */) {
    var depthArg = arguments.length ? arguments[0] : undefined;
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.for-each.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.for-each.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var forEach = __webpack_require__(/*! ../internals/array-for-each */ "../../node_modules/core-js/internals/array-for-each.js");

// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
$({ target: 'Array', proto: true, forced: [].forEach != forEach }, {
  forEach: forEach
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.from.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.from.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var from = __webpack_require__(/*! ../internals/array-from */ "../../node_modules/core-js/internals/array-from.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "../../node_modules/core-js/internals/check-correctness-of-iteration.js");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.includes.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.includes.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $includes = __webpack_require__(/*! ../internals/array-includes */ "../../node_modules/core-js/internals/array-includes.js").includes;
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "../../node_modules/core-js/internals/add-to-unscopables.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: !USES_TO_LENGTH }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.index-of.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.index-of.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $indexOf = __webpack_require__(/*! ../internals/array-includes */ "../../node_modules/core-js/internals/array-includes.js").indexOf;
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "../../node_modules/core-js/internals/array-method-is-strict.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('indexOf');
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
$({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.is-array.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.is-array.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "../../node_modules/core-js/internals/is-array.js");

// `Array.isArray` method
// https://tc39.github.io/ecma262/#sec-array.isarray
$({ target: 'Array', stat: true }, {
  isArray: isArray
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.iterator.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.iterator.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "../../node_modules/core-js/internals/add-to-unscopables.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "../../node_modules/core-js/internals/iterators.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "../../node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "../../node_modules/core-js/internals/define-iterator.js");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.join.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.join.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "../../node_modules/core-js/internals/indexed-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "../../node_modules/core-js/internals/array-method-is-strict.js");

var nativeJoin = [].join;

var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.last-index-of.js":
/*!*******************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.last-index-of.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var lastIndexOf = __webpack_require__(/*! ../internals/array-last-index-of */ "../../node_modules/core-js/internals/array-last-index-of.js");

// `Array.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
$({ target: 'Array', proto: true, forced: lastIndexOf !== [].lastIndexOf }, {
  lastIndexOf: lastIndexOf
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.map.js":
/*!*********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.map.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $map = __webpack_require__(/*! ../internals/array-iteration */ "../../node_modules/core-js/internals/array-iteration.js").map;
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "../../node_modules/core-js/internals/array-method-has-species-support.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
// FF49- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('map');

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.of.js":
/*!********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.of.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "../../node_modules/core-js/internals/create-property.js");

var ISNT_GENERIC = fails(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
});

// `Array.of` method
// https://tc39.github.io/ecma262/#sec-array.of
// WebKit Array.of isn't generic
$({ target: 'Array', stat: true, forced: ISNT_GENERIC }, {
  of: function of(/* ...args */) {
    var index = 0;
    var argumentsLength = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(argumentsLength);
    while (argumentsLength > index) createProperty(result, index, arguments[index++]);
    result.length = argumentsLength;
    return result;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.reduce-right.js":
/*!******************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.reduce-right.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $reduceRight = __webpack_require__(/*! ../internals/array-reduce */ "../../node_modules/core-js/internals/array-reduce.js").right;
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "../../node_modules/core-js/internals/array-method-is-strict.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");
var CHROME_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "../../node_modules/core-js/internals/engine-v8-version.js");
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ "../../node_modules/core-js/internals/engine-is-node.js");

var STRICT_METHOD = arrayMethodIsStrict('reduceRight');
// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', { 1: 0 });
// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;

// `Array.prototype.reduceRight` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH || CHROME_BUG }, {
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.reduce.js":
/*!************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.reduce.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $reduce = __webpack_require__(/*! ../internals/array-reduce */ "../../node_modules/core-js/internals/array-reduce.js").left;
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "../../node_modules/core-js/internals/array-method-is-strict.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");
var CHROME_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "../../node_modules/core-js/internals/engine-v8-version.js");
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ "../../node_modules/core-js/internals/engine-is-node.js");

var STRICT_METHOD = arrayMethodIsStrict('reduce');
var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', { 1: 0 });
// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH || CHROME_BUG }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.reverse.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.reverse.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "../../node_modules/core-js/internals/is-array.js");

var nativeReverse = [].reverse;
var test = [1, 2];

// `Array.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
$({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign
    if (isArray(this)) this.length = this.length;
    return nativeReverse.call(this);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.slice.js":
/*!***********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.slice.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "../../node_modules/core-js/internals/is-array.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "../../node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "../../node_modules/core-js/internals/create-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "../../node_modules/core-js/internals/array-method-has-species-support.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
var USES_TO_LENGTH = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.some.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.some.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $some = __webpack_require__(/*! ../internals/array-iteration */ "../../node_modules/core-js/internals/array-iteration.js").some;
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "../../node_modules/core-js/internals/array-method-is-strict.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var STRICT_METHOD = arrayMethodIsStrict('some');
var USES_TO_LENGTH = arrayMethodUsesToLength('some');

// `Array.prototype.some` method
// https://tc39.github.io/ecma262/#sec-array.prototype.some
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.sort.js":
/*!**********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.sort.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "../../node_modules/core-js/internals/a-function.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "../../node_modules/core-js/internals/array-method-is-strict.js");

var test = [];
var nativeSort = test.sort;

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD;

// `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? nativeSort.call(toObject(this))
      : nativeSort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.species.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.species.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setSpecies = __webpack_require__(/*! ../internals/set-species */ "../../node_modules/core-js/internals/set-species.js");

// `Array[@@species]` getter
// https://tc39.github.io/ecma262/#sec-get-array-@@species
setSpecies('Array');


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.splice.js":
/*!************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.splice.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "../../node_modules/core-js/internals/to-absolute-index.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "../../node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "../../node_modules/core-js/internals/to-length.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "../../node_modules/core-js/internals/array-species-create.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "../../node_modules/core-js/internals/create-property.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "../../node_modules/core-js/internals/array-method-has-species-support.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "../../node_modules/core-js/internals/array-method-uses-to-length.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
var USES_TO_LENGTH = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.unscopables.flat-map.js":
/*!**************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.unscopables.flat-map.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "../../node_modules/core-js/internals/add-to-unscopables.js");

addToUnscopables('flatMap');


/***/ }),

/***/ "../../node_modules/core-js/modules/es.array.unscopables.flat.js":
/*!**********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.array.unscopables.flat.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "../../node_modules/core-js/internals/add-to-unscopables.js");

addToUnscopables('flat');


/***/ }),

/***/ "../../node_modules/core-js/modules/es.function.bind.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.function.bind.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind */ "../../node_modules/core-js/internals/function-bind.js");

// `Function.prototype.bind` method
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
$({ target: 'Function', proto: true }, {
  bind: bind
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.function.has-instance.js":
/*!*********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.function.has-instance.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "../../node_modules/core-js/internals/object-get-prototype-of.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");

var HAS_INSTANCE = wellKnownSymbol('hasInstance');
var FunctionPrototype = Function.prototype;

// `Function.prototype[@@hasInstance]` method
// https://tc39.github.io/ecma262/#sec-function.prototype-@@hasinstance
if (!(HAS_INSTANCE in FunctionPrototype)) {
  definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, { value: function (O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this;
    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
    while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
    return false;
  } });
}


/***/ }),

/***/ "../../node_modules/core-js/modules/es.function.name.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.function.name.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js").f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ "../../node_modules/core-js/modules/es.json.to-string-tag.js":
/*!******************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.json.to-string-tag.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "../../node_modules/core-js/internals/set-to-string-tag.js");

// JSON[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "../../node_modules/core-js/modules/es.math.to-string-tag.js":
/*!******************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.math.to-string-tag.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "../../node_modules/core-js/internals/set-to-string-tag.js");

// Math[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.assign.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.assign.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var assign = __webpack_require__(/*! ../internals/object-assign */ "../../node_modules/core-js/internals/object-assign.js");

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {
  assign: assign
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.create.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.create.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var create = __webpack_require__(/*! ../internals/object-create */ "../../node_modules/core-js/internals/object-create.js");

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  create: create
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.define-getter.js":
/*!********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.define-getter.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var FORCED = __webpack_require__(/*! ../internals/object-prototype-accessors-forced */ "../../node_modules/core-js/internals/object-prototype-accessors-forced.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "../../node_modules/core-js/internals/a-function.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");

// `Object.prototype.__defineGetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__defineGetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __defineGetter__: function __defineGetter__(P, getter) {
      definePropertyModule.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
    }
  });
}


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.define-properties.js":
/*!************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.define-properties.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "../../node_modules/core-js/internals/object-define-properties.js");

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
$({ target: 'Object', stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
  defineProperties: defineProperties
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.define-property.js":
/*!**********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.define-property.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var objectDefinePropertyModile = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
$({ target: 'Object', stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
  defineProperty: objectDefinePropertyModile.f
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.define-setter.js":
/*!********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.define-setter.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var FORCED = __webpack_require__(/*! ../internals/object-prototype-accessors-forced */ "../../node_modules/core-js/internals/object-prototype-accessors-forced.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "../../node_modules/core-js/internals/a-function.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");

// `Object.prototype.__defineSetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__defineSetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __defineSetter__: function __defineSetter__(P, setter) {
      definePropertyModule.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
    }
  });
}


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.entries.js":
/*!**************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.entries.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $entries = __webpack_require__(/*! ../internals/object-to-array */ "../../node_modules/core-js/internals/object-to-array.js").entries;

// `Object.entries` method
// https://tc39.github.io/ecma262/#sec-object.entries
$({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.freeze.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.freeze.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "../../node_modules/core-js/internals/freezing.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");
var onFreeze = __webpack_require__(/*! ../internals/internal-metadata */ "../../node_modules/core-js/internals/internal-metadata.js").onFreeze;

var nativeFreeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () { nativeFreeze(1); });

// `Object.freeze` method
// https://tc39.github.io/ecma262/#sec-object.freeze
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  freeze: function freeze(it) {
    return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.from-entries.js":
/*!*******************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.from-entries.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "../../node_modules/core-js/internals/iterate.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "../../node_modules/core-js/internals/create-property.js");

// `Object.fromEntries` method
// https://github.com/tc39/proposal-object-from-entries
$({ target: 'Object', stat: true }, {
  fromEntries: function fromEntries(iterable) {
    var obj = {};
    iterate(iterable, function (k, v) {
      createProperty(obj, k, v);
    }, { AS_ENTRIES: true });
    return obj;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js":
/*!**********************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.get-own-property-descriptor.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "../../node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.get-own-property-descriptors.js":
/*!***********************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.get-own-property-descriptors.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "../../node_modules/core-js/internals/own-keys.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "../../node_modules/core-js/internals/object-get-own-property-descriptor.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "../../node_modules/core-js/internals/create-property.js");

// `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.get-own-property-names.js":
/*!*****************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.get-own-property-names.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var nativeGetOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "../../node_modules/core-js/internals/object-get-own-property-names-external.js").f;

var FAILS_ON_PRIMITIVES = fails(function () { return !Object.getOwnPropertyNames(1); });

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  getOwnPropertyNames: nativeGetOwnPropertyNames
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.get-prototype-of.js":
/*!***********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.get-prototype-of.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var nativeGetPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "../../node_modules/core-js/internals/object-get-prototype-of.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "../../node_modules/core-js/internals/correct-prototype-getter.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.is-extensible.js":
/*!********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.is-extensible.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");

var nativeIsExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { nativeIsExtensible(1); });

// `Object.isExtensible` method
// https://tc39.github.io/ecma262/#sec-object.isextensible
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  isExtensible: function isExtensible(it) {
    return isObject(it) ? nativeIsExtensible ? nativeIsExtensible(it) : true : false;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.is-frozen.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.is-frozen.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");

var nativeIsFrozen = Object.isFrozen;
var FAILS_ON_PRIMITIVES = fails(function () { nativeIsFrozen(1); });

// `Object.isFrozen` method
// https://tc39.github.io/ecma262/#sec-object.isfrozen
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  isFrozen: function isFrozen(it) {
    return isObject(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.is-sealed.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.is-sealed.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");

var nativeIsSealed = Object.isSealed;
var FAILS_ON_PRIMITIVES = fails(function () { nativeIsSealed(1); });

// `Object.isSealed` method
// https://tc39.github.io/ecma262/#sec-object.issealed
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  isSealed: function isSealed(it) {
    return isObject(it) ? nativeIsSealed ? nativeIsSealed(it) : false : true;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.is.js":
/*!*********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.is.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var is = __webpack_require__(/*! ../internals/same-value */ "../../node_modules/core-js/internals/same-value.js");

// `Object.is` method
// https://tc39.github.io/ecma262/#sec-object.is
$({ target: 'Object', stat: true }, {
  is: is
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.keys.js":
/*!***********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.keys.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var nativeKeys = __webpack_require__(/*! ../internals/object-keys */ "../../node_modules/core-js/internals/object-keys.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.lookup-getter.js":
/*!********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.lookup-getter.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var FORCED = __webpack_require__(/*! ../internals/object-prototype-accessors-forced */ "../../node_modules/core-js/internals/object-prototype-accessors-forced.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "../../node_modules/core-js/internals/to-primitive.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "../../node_modules/core-js/internals/object-get-prototype-of.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "../../node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

// `Object.prototype.__lookupGetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupGetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __lookupGetter__: function __lookupGetter__(P) {
      var O = toObject(this);
      var key = toPrimitive(P, true);
      var desc;
      do {
        if (desc = getOwnPropertyDescriptor(O, key)) return desc.get;
      } while (O = getPrototypeOf(O));
    }
  });
}


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.lookup-setter.js":
/*!********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.lookup-setter.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var FORCED = __webpack_require__(/*! ../internals/object-prototype-accessors-forced */ "../../node_modules/core-js/internals/object-prototype-accessors-forced.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "../../node_modules/core-js/internals/to-primitive.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "../../node_modules/core-js/internals/object-get-prototype-of.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "../../node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

// `Object.prototype.__lookupSetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupSetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __lookupSetter__: function __lookupSetter__(P) {
      var O = toObject(this);
      var key = toPrimitive(P, true);
      var desc;
      do {
        if (desc = getOwnPropertyDescriptor(O, key)) return desc.set;
      } while (O = getPrototypeOf(O));
    }
  });
}


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.prevent-extensions.js":
/*!*************************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.prevent-extensions.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");
var onFreeze = __webpack_require__(/*! ../internals/internal-metadata */ "../../node_modules/core-js/internals/internal-metadata.js").onFreeze;
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "../../node_modules/core-js/internals/freezing.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");

var nativePreventExtensions = Object.preventExtensions;
var FAILS_ON_PRIMITIVES = fails(function () { nativePreventExtensions(1); });

// `Object.preventExtensions` method
// https://tc39.github.io/ecma262/#sec-object.preventextensions
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  preventExtensions: function preventExtensions(it) {
    return nativePreventExtensions && isObject(it) ? nativePreventExtensions(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.seal.js":
/*!***********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.seal.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");
var onFreeze = __webpack_require__(/*! ../internals/internal-metadata */ "../../node_modules/core-js/internals/internal-metadata.js").onFreeze;
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "../../node_modules/core-js/internals/freezing.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");

var nativeSeal = Object.seal;
var FAILS_ON_PRIMITIVES = fails(function () { nativeSeal(1); });

// `Object.seal` method
// https://tc39.github.io/ecma262/#sec-object.seal
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  seal: function seal(it) {
    return nativeSeal && isObject(it) ? nativeSeal(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.set-prototype-of.js":
/*!***********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.set-prototype-of.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "../../node_modules/core-js/internals/object-set-prototype-of.js");

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.to-string.js":
/*!****************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.to-string.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "../../node_modules/core-js/internals/to-string-tag-support.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "../../node_modules/core-js/internals/redefine.js");
var toString = __webpack_require__(/*! ../internals/object-to-string */ "../../node_modules/core-js/internals/object-to-string.js");

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "../../node_modules/core-js/modules/es.object.values.js":
/*!*************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.object.values.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var $values = __webpack_require__(/*! ../internals/object-to-array */ "../../node_modules/core-js/internals/object-to-array.js").values;

// `Object.values` method
// https://tc39.github.io/ecma262/#sec-object.values
$({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.reflect.to-string-tag.js":
/*!*********************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.reflect.to-string-tag.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "../../node_modules/core-js/internals/set-to-string-tag.js");

$({ global: true }, { Reflect: {} });

// Reflect[@@toStringTag] property
// https://tc39.es/ecma262/#sec-reflect-@@tostringtag
setToStringTag(global.Reflect, 'Reflect', true);


/***/ }),

/***/ "../../node_modules/core-js/modules/es.string.iterator.js":
/*!***************************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.string.iterator.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__(/*! ../internals/string-multibyte */ "../../node_modules/core-js/internals/string-multibyte.js").charAt;
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "../../node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "../../node_modules/core-js/internals/define-iterator.js");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "../../node_modules/core-js/modules/es.symbol.js":
/*!******************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/core-js/modules/es.symbol.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "../../node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "../../node_modules/core-js/internals/global.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "../../node_modules/core-js/internals/get-built-in.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "../../node_modules/core-js/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "../../node_modules/core-js/internals/descriptors.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "../../node_modules/core-js/internals/native-symbol.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "../../node_modules/core-js/internals/use-symbol-as-uid.js");
var fails = __webpack_require__(/*! ../internals/fails */ "../../node_modules/core-js/internals/fails.js");
var has = __webpack_require__(/*! ../internals/has */ "../../node_modules/core-js/internals/has.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "../../node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "../../node_modules/core-js/internals/is-object.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "../../node_modules/core-js/internals/an-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "../../node_modules/core-js/internals/to-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "../../node_modules/core-js/internals/to-indexed-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "../../node_modules/core-js/internals/to-primitive.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "../../node_modules/core-js/internals/create-property-descriptor.js");
var nativeObjectCreate = __webpack_require__(/*! ../internals/object-create */ "../../node_modules/core-js/internals/object-create.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "../../node_modules/core-js/internals/object-keys.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "../../node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternal = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "../../node_modules/core-js/internals/object-get-own-property-names-external.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "../../node_modules/core-js/internals/object-get-own-property-symbols.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "../../node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "../../node_modules/core-js/internals/object-define-property.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "../../node_modules/core-js/internals/object-property-is-enumerable.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "../../node_modules/core-js/internals/create-non-enumerable-property.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "../../node_modules/core-js/internals/redefine.js");
var shared = __webpack_require__(/*! ../internals/shared */ "../../node_modules/core-js/internals/shared.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "../../node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "../../node_modules/core-js/internals/hidden-keys.js");
var uid = __webpack_require__(/*! ../internals/uid */ "../../node_modules/core-js/internals/uid.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "../../node_modules/core-js/internals/well-known-symbol.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "../../node_modules/core-js/internals/well-known-symbol-wrapped.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "../../node_modules/core-js/internals/define-well-known-symbol.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "../../node_modules/core-js/internals/set-to-string-tag.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "../../node_modules/core-js/internals/internal-state.js");
var $forEach = __webpack_require__(/*! ../internals/array-iteration */ "../../node_modules/core-js/internals/array-iteration.js").forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "../../node_modules/css-loader/dist/runtime/api.js":
/*!********************************************************************************************!*\
  !*** /home/travis/build/excaliburjs/Excalibur/node_modules/css-loader/dist/runtime/api.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./Actions/Action.ts":
/*!***************************!*\
  !*** ./Actions/Action.ts ***!
  \***************************/
/*! exports provided: EaseTo, MoveTo, MoveBy, Follow, Meet, RotateTo, RotateBy, ScaleTo, ScaleBy, Delay, Blink, Fade, Die, CallMethod, Repeat, RepeatForever, ActionQueue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EaseTo", function() { return EaseTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MoveTo", function() { return MoveTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MoveBy", function() { return MoveBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Follow", function() { return Follow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Meet", function() { return Meet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RotateTo", function() { return RotateTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RotateBy", function() { return RotateBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScaleTo", function() { return ScaleTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScaleBy", function() { return ScaleBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Delay", function() { return Delay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Blink", function() { return Blink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fade", function() { return Fade; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Die", function() { return Die; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CallMethod", function() { return CallMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Repeat", function() { return Repeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatForever", function() { return RepeatForever; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionQueue", function() { return ActionQueue; });
/* harmony import */ var _RotationType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RotationType */ "./Actions/RotationType.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Util/Decorators */ "./Util/Decorators.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class EaseTo {
    constructor(actor, x, y, duration, easingFcn) {
        this.actor = actor;
        this.easingFcn = easingFcn;
        this._currentLerpTime = 0;
        this._lerpDuration = 1 * 1000; // 1 second
        this._lerpStart = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0);
        this._lerpEnd = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0);
        this._initialized = false;
        this._stopped = false;
        this._distance = 0;
        this._lerpDuration = duration;
        this._lerpEnd = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](x, y);
    }
    _initialize() {
        this._lerpStart = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](this.actor.pos.x, this.actor.pos.y);
        this._currentLerpTime = 0;
        this._distance = this._lerpStart.distance(this._lerpEnd);
    }
    update(delta) {
        if (!this._initialized) {
            this._initialize();
            this._initialized = true;
        }
        // Need to update lerp time first, otherwise the first update will always be zero
        this._currentLerpTime += delta;
        let newX = this.actor.pos.x;
        let newY = this.actor.pos.y;
        if (this._currentLerpTime < this._lerpDuration) {
            if (this._lerpEnd.x < this._lerpStart.x) {
                newX =
                    this._lerpStart.x -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
            }
            else {
                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
            }
            if (this._lerpEnd.y < this._lerpStart.y) {
                newY =
                    this._lerpStart.y -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
            }
            else {
                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
            }
            // Given the lerp position figure out the velocity in pixels per second
            this.actor.vel.x = (newX - this.actor.pos.x) / (delta / 1000);
            this.actor.vel.y = (newY - this.actor.pos.y) / (delta / 1000);
        }
        else {
            this.actor.pos.x = this._lerpEnd.x;
            this.actor.pos.y = this._lerpEnd.y;
            this.actor.vel = _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].Zero;
            //this._lerpStart = null;
            //this._lerpEnd = null;
            //this._currentLerpTime = 0;
        }
    }
    isComplete(actor) {
        return this._stopped || new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](actor.pos.x, actor.pos.y).distance(this._lerpStart) >= this._distance;
    }
    reset() {
        this._initialized = false;
    }
    stop() {
        this.actor.vel.y = 0;
        this.actor.vel.x = 0;
        this._stopped = true;
    }
}
class MoveTo {
    constructor(actor, destx, desty, speed) {
        this._started = false;
        this._stopped = false;
        this._actor = actor;
        this._end = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](destx, desty);
        this._speed = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](this._actor.pos.x, this._actor.pos.y);
            this._distance = this._start.distance(this._end);
            this._dir = this._end.sub(this._start).normalize();
        }
        const m = this._dir.scale(this._speed);
        this._actor.vel.x = m.x;
        this._actor.vel.y = m.y;
        if (this.isComplete(this._actor)) {
            this._actor.pos.x = this._end.x;
            this._actor.pos.y = this._end.y;
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
        }
    }
    isComplete(actor) {
        return this._stopped || new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](actor.pos.x, actor.pos.y).distance(this._start) >= this._distance;
    }
    stop() {
        this._actor.vel.y = 0;
        this._actor.vel.x = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}
class MoveBy {
    constructor(actor, offsetX, offsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._actor = actor;
        this._speed = speed;
        this._offset = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](offsetX, offsetY);
        if (speed <= 0) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_2__["Logger"].getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);
            throw new Error('Speed must be greater than 0 pixels per second');
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](this._actor.pos.x, this._actor.pos.y);
            this._end = this._start.add(this._offset);
            this._distance = this._offset.size;
            this._dir = this._end.sub(this._start).normalize();
        }
        this._actor.vel = this._dir.scale(this._speed);
        if (this.isComplete(this._actor)) {
            this._actor.pos.x = this._end.x;
            this._actor.pos.y = this._end.y;
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
        }
    }
    isComplete(actor) {
        return this._stopped || actor.pos.distance(this._start) >= this._distance;
    }
    stop() {
        this._actor.vel.y = 0;
        this._actor.vel.x = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}
class Follow {
    constructor(actor, actorToFollow, followDistance) {
        this._started = false;
        this._stopped = false;
        this._actor = actor;
        this._actorToFollow = actorToFollow;
        this._current = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](this._actor.pos.x, this._actor.pos.y);
        this._end = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](actorToFollow.pos.x, actorToFollow.pos.y);
        this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);
        this._speed = 0;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToFollowSpeed = Math.sqrt(Math.pow(this._actorToFollow.vel.x, 2) + Math.pow(this._actorToFollow.vel.y, 2));
        if (actorToFollowSpeed !== 0) {
            this._speed = actorToFollowSpeed;
        }
        this._current.x = this._actor.pos.x;
        this._current.y = this._actor.pos.y;
        this._end.x = this._actorToFollow.pos.x;
        this._end.y = this._actorToFollow.pos.y;
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        if (this._distanceBetween >= this._maximumDistance) {
            const m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
        }
        else {
            this._actor.vel.x = 0;
            this._actor.vel.y = 0;
        }
        if (this.isComplete()) {
            this._actor.pos.x = this._end.x;
            this._actor.pos.y = this._end.y;
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
        }
    }
    stop() {
        this._actor.vel.y = 0;
        this._actor.vel.x = 0;
        this._stopped = true;
    }
    isComplete() {
        // the actor following should never stop unless specified to do so
        return this._stopped;
    }
    reset() {
        this._started = false;
    }
}
class Meet {
    constructor(actor, actorToMeet, speed) {
        this._started = false;
        this._stopped = false;
        this._speedWasSpecified = false;
        this._actor = actor;
        this._actorToMeet = actorToMeet;
        this._current = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](this._actor.pos.x, this._actor.pos.y);
        this._end = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](actorToMeet.pos.x, actorToMeet.pos.y);
        this._speed = speed || 0;
        if (speed !== undefined) {
            this._speedWasSpecified = true;
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToMeetSpeed = Math.sqrt(Math.pow(this._actorToMeet.vel.x, 2) + Math.pow(this._actorToMeet.vel.y, 2));
        if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {
            this._speed = actorToMeetSpeed;
        }
        this._current.x = this._actor.pos.x;
        this._current.y = this._actor.pos.y;
        this._end.x = this._actorToMeet.pos.x;
        this._end.y = this._actorToMeet.pos.y;
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        const m = this._dir.scale(this._speed);
        this._actor.vel.x = m.x;
        this._actor.vel.y = m.y;
        if (this.isComplete()) {
            this._actor.pos.x = this._end.x;
            this._actor.pos.y = this._end.y;
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
        }
    }
    isComplete() {
        return this._stopped || this._distanceBetween <= 1;
    }
    stop() {
        this._actor.vel.y = 0;
        this._actor.vel.x = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}
class RotateTo {
    constructor(actor, angleRadians, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._actor = actor;
        this._end = angleRadians;
        this._speed = speed;
        this._rotationType = rotationType || _RotationType__WEBPACK_IMPORTED_MODULE_0__["RotationType"].ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._actor.rotation;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["TwoPI"] - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + _Util_Util__WEBPACK_IMPORTED_MODULE_3__["TwoPI"]) % _Util_Util__WEBPACK_IMPORTED_MODULE_3__["TwoPI"] >= Math.PI;
            switch (this._rotationType) {
                case _RotationType__WEBPACK_IMPORTED_MODULE_0__["RotationType"].ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case _RotationType__WEBPACK_IMPORTED_MODULE_0__["RotationType"].LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case _RotationType__WEBPACK_IMPORTED_MODULE_0__["RotationType"].Clockwise:
                    this._direction = 1;
                    if (this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case _RotationType__WEBPACK_IMPORTED_MODULE_0__["RotationType"].CounterClockwise:
                    this._direction = -1;
                    if (!this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._actor.rx = this._direction * this._speed;
        if (this.isComplete()) {
            this._actor.rotation = this._end;
            this._actor.rx = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTravelled = Math.abs(this._actor.rotation - this._start);
        return this._stopped || distanceTravelled >= Math.abs(this._distance);
    }
    stop() {
        this._actor.rx = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}
class RotateBy {
    constructor(actor, angleRadiansOffset, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._actor = actor;
        this._speed = speed;
        this._offset = angleRadiansOffset;
        this._rotationType = rotationType || _RotationType__WEBPACK_IMPORTED_MODULE_0__["RotationType"].ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._actor.rotation;
            this._end = this._start + this._offset;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["TwoPI"] - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + _Util_Util__WEBPACK_IMPORTED_MODULE_3__["TwoPI"]) % _Util_Util__WEBPACK_IMPORTED_MODULE_3__["TwoPI"] >= Math.PI;
            switch (this._rotationType) {
                case _RotationType__WEBPACK_IMPORTED_MODULE_0__["RotationType"].ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case _RotationType__WEBPACK_IMPORTED_MODULE_0__["RotationType"].LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case _RotationType__WEBPACK_IMPORTED_MODULE_0__["RotationType"].Clockwise:
                    this._direction = 1;
                    if (this._shortDistance >= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case _RotationType__WEBPACK_IMPORTED_MODULE_0__["RotationType"].CounterClockwise:
                    this._direction = -1;
                    if (this._shortDistance <= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._actor.rx = this._direction * this._speed;
        if (this.isComplete()) {
            this._actor.rotation = this._end;
            this._actor.rx = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTravelled = Math.abs(this._actor.rotation - this._start);
        return this._stopped || distanceTravelled >= Math.abs(this._distance);
    }
    stop() {
        this._actor.rx = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}
let ScaleTo = class ScaleTo {
    constructor(actor, scaleX, scaleY, speedX, speedY) {
        this._started = false;
        this._stopped = false;
        this._actor = actor;
        this._endX = scaleX;
        this._endY = scaleY;
        this._speedX = speedX;
        this._speedY = speedY;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startX = this._actor.scale.x;
            this._startY = this._actor.scale.y;
            this._distanceX = Math.abs(this._endX - this._startX);
            this._distanceY = Math.abs(this._endY - this._startY);
        }
        if (!(Math.abs(this._actor.scale.x - this._startX) >= this._distanceX)) {
            const directionX = this._endY < this._startY ? -1 : 1;
            this._actor.sx = this._speedX * directionX;
        }
        else {
            this._actor.sx = 0;
        }
        if (!(Math.abs(this._actor.scale.y - this._startY) >= this._distanceY)) {
            const directionY = this._endY < this._startY ? -1 : 1;
            this._actor.sy = this._speedY * directionY;
        }
        else {
            this._actor.sy = 0;
        }
        if (this.isComplete()) {
            this._actor.scale.x = this._endX;
            this._actor.scale.y = this._endY;
            this._actor.sx = 0;
            this._actor.sy = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._actor.scale.y - this._startX) >= this._distanceX && Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));
    }
    stop() {
        this._actor.sx = 0;
        this._actor.sy = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
};
ScaleTo = __decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_4__["obsolete"])({ message: 'ex.Action.ScaleTo will be removed in v0.25.0', alternateMethod: 'Set width and hight directly' })
], ScaleTo);

let ScaleBy = class ScaleBy {
    constructor(actor, scaleOffsetX, scaleOffsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._actor = actor;
        this._offset = new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](scaleOffsetX, scaleOffsetY);
        this._speedX = this._speedY = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startScale = this._actor.scale.clone();
            this._endScale = this._startScale.add(this._offset);
            this._distanceX = Math.abs(this._endScale.x - this._startScale.x);
            this._distanceY = Math.abs(this._endScale.y - this._startScale.y);
            this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;
            this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;
        }
        this._actor.sx = this._speedX * this._directionX;
        this._actor.sy = this._speedY * this._directionY;
        if (this.isComplete()) {
            this._actor.scale = this._endScale;
            this._actor.sx = 0;
            this._actor.sy = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._actor.scale.x - this._startScale.x) >= this._distanceX &&
                Math.abs(this._actor.scale.y - this._startScale.y) >= this._distanceY));
    }
    stop() {
        this._actor.sx = 0;
        this._actor.sy = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
};
ScaleBy = __decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_4__["obsolete"])({ message: 'ex.Action.ScaleBy will be removed in v0.25.0', alternateMethod: 'Set width and hight directly' })
], ScaleBy);

class Delay {
    constructor(actor, delay) {
        this._elapsedTime = 0;
        this._started = false;
        this._stopped = false;
        this._actor = actor;
        this._delay = delay;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
        }
        this.x = this._actor.pos.x;
        this.y = this._actor.pos.y;
        this._elapsedTime += delta;
    }
    isComplete() {
        return this._stopped || this._elapsedTime >= this._delay;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._elapsedTime = 0;
        this._started = false;
    }
}
class Blink {
    constructor(actor, timeVisible, timeNotVisible, numBlinks = 1) {
        this._timeVisible = 0;
        this._timeNotVisible = 0;
        this._elapsedTime = 0;
        this._totalTime = 0;
        this._stopped = false;
        this._started = false;
        this._actor = actor;
        this._timeVisible = timeVisible;
        this._timeNotVisible = timeNotVisible;
        this._duration = (timeVisible + timeNotVisible) * numBlinks;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
        }
        this._elapsedTime += delta;
        this._totalTime += delta;
        if (this._actor.visible && this._elapsedTime >= this._timeVisible) {
            this._actor.visible = false;
            this._elapsedTime = 0;
        }
        if (!this._actor.visible && this._elapsedTime >= this._timeNotVisible) {
            this._actor.visible = true;
            this._elapsedTime = 0;
        }
        if (this.isComplete()) {
            this._actor.visible = true;
        }
    }
    isComplete() {
        return this._stopped || this._totalTime >= this._duration;
    }
    stop() {
        this._actor.visible = true;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._elapsedTime = 0;
        this._totalTime = 0;
    }
}
class Fade {
    constructor(actor, endOpacity, speed) {
        this._multiplier = 1;
        this._started = false;
        this._stopped = false;
        this._actor = actor;
        this._endOpacity = endOpacity;
        this._speed = speed;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
            // determine direction when we start
            if (this._endOpacity < this._actor.opacity) {
                this._multiplier = -1;
            }
            else {
                this._multiplier = 1;
            }
        }
        if (this._speed > 0) {
            this._actor.opacity += (this._multiplier * (Math.abs(this._actor.opacity - this._endOpacity) * delta)) / this._speed;
        }
        this._speed -= delta;
        if (this.isComplete()) {
            this._actor.opacity = this._endOpacity;
        }
        _Util_Log__WEBPACK_IMPORTED_MODULE_2__["Logger"].getInstance().debug('[Action fade] Actor opacity:', this._actor.opacity);
    }
    isComplete() {
        return this._stopped || Math.abs(this._actor.opacity - this._endOpacity) < 0.05;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}
class Die {
    constructor(actor) {
        this._stopped = false;
        this._actor = actor;
    }
    update(_delta) {
        this._actor.actionQueue.clearActions();
        this._actor.kill();
        this._stopped = true;
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        return;
    }
    reset() {
        return;
    }
}
class CallMethod {
    constructor(actor, method) {
        this._method = null;
        this._actor = null;
        this._hasBeenCalled = false;
        this._actor = actor;
        this._method = method;
    }
    update(_delta) {
        this._method.call(this._actor);
        this._hasBeenCalled = true;
    }
    isComplete() {
        return this._hasBeenCalled;
    }
    reset() {
        this._hasBeenCalled = false;
    }
    stop() {
        this._hasBeenCalled = true;
    }
}
class Repeat {
    constructor(actor, repeat, actions) {
        this._stopped = false;
        this._actor = actor;
        this._actionQueue = new ActionQueue(actor);
        this._repeat = repeat;
        this._originalRepeat = repeat;
        const len = actions.length;
        for (let i = 0; i < len; i++) {
            actions[i].reset();
            this._actionQueue.add(actions[i]);
        }
    }
    update(delta) {
        this.x = this._actor.pos.x;
        this.y = this._actor.pos.y;
        if (!this._actionQueue.hasNext()) {
            this._actionQueue.reset();
            this._repeat--;
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped || this._repeat <= 0;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._repeat = this._originalRepeat;
    }
}
class RepeatForever {
    constructor(actor, actions) {
        this._stopped = false;
        this._actor = actor;
        this._actionQueue = new ActionQueue(actor);
        const len = actions.length;
        for (let i = 0; i < len; i++) {
            actions[i].reset();
            this._actionQueue.add(actions[i]);
        }
    }
    update(delta) {
        this.x = this._actor.pos.x;
        this.y = this._actor.pos.y;
        if (this._stopped) {
            return;
        }
        if (!this._actionQueue.hasNext()) {
            this._actionQueue.reset();
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        this._stopped = true;
        this._actionQueue.clearActions();
    }
    reset() {
        return;
    }
}
/**
 * Action Queues
 *
 * Action queues are part of the [[ActionContext|Action API]] and
 * store the list of actions to be executed for an [[Actor]].
 *
 * Actors implement [[Actor.actions]] which can be manipulated by
 * advanced users to adjust the actions currently being executed in the
 * queue.
 */
class ActionQueue {
    constructor(actor) {
        this._actions = [];
        this._completedActions = [];
        this._actor = actor;
    }
    add(action) {
        this._actions.push(action);
    }
    remove(action) {
        const index = this._actions.indexOf(action);
        this._actions.splice(index, 1);
    }
    clearActions() {
        this._actions.length = 0;
        this._completedActions.length = 0;
        if (this._currentAction) {
            this._currentAction.stop();
        }
    }
    getActions() {
        return this._actions.concat(this._completedActions);
    }
    hasNext() {
        return this._actions.length > 0;
    }
    reset() {
        this._actions = this.getActions();
        const len = this._actions.length;
        for (let i = 0; i < len; i++) {
            this._actions[i].reset();
        }
        this._completedActions = [];
    }
    update(delta) {
        if (this._actions.length > 0) {
            this._currentAction = this._actions[0];
            this._currentAction.update(delta);
            if (this._currentAction.isComplete(this._actor)) {
                this._completedActions.push(this._actions.shift());
            }
        }
    }
}


/***/ }),

/***/ "./Actions/ActionContext.ts":
/*!**********************************!*\
  !*** ./Actions/ActionContext.ts ***!
  \**********************************/
/*! exports provided: ActionContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionContext", function() { return ActionContext; });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Action */ "./Actions/Action.ts");
/* harmony import */ var _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util/EasingFunctions */ "./Util/EasingFunctions.ts");


/**
 * The fluent Action API allows you to perform "actions" on
 * [[Actor|Actors]] such as following, moving, rotating, and
 * more. You can implement your own actions by implementing
 * the [[Action]] interface.
 */
class ActionContext {
    constructor() {
        this._actors = [];
        this._queues = [];
        if (arguments !== null) {
            this._actors = Array.prototype.slice.call(arguments, 0);
            this._queues = this._actors.map((a) => {
                return a.actionQueue;
            });
        }
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].clearActions();
        }
    }
    addActorToContext(actor) {
        this._actors.push(actor);
        // if we run into problems replace the line below with:
        this._queues.push(actor.actionQueue);
    }
    removeActorFromContext(actor) {
        const index = this._actors.indexOf(actor);
        if (index > -1) {
            this._actors.splice(index, 1);
            this._queues.splice(index, 1);
        }
    }
    /**
     * This method will move an actor to the specified `x` and `y` position over the
     * specified duration using a given [[EasingFunctions]] and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param x         The x location to move the actor to
     * @param y         The y location to move the actor to
     * @param duration  The time it should take the actor to move to the new location in milliseconds
     * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position
     */
    easeTo(x, y, duration, easingFcn = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_1__["EasingFunctions"].Linear) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["EaseTo"](this._actors[i], x, y, duration, easingFcn));
        }
        return this;
    }
    /**
     * This method will move an actor to the specified x and y position at the
     * speed specified (in pixels per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param x      The x location to move the actor to
     * @param y      The y location to move the actor to
     * @param speed  The speed in pixels per second to move
     */
    moveTo(x, y, speed) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["MoveTo"](this._actors[i], x, y, speed));
        }
        return this;
    }
    /**
     * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param xOffset     The x offset to apply to this actor
     * @param yOffset     The y location to move the actor to
     * @param speed  The speed in pixels per second the actor should move
     */
    moveBy(xOffset, yOffset, speed) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["MoveBy"](this._actors[i], xOffset, yOffset, speed));
        }
        return this;
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["RotateTo"](this._actors[i], angleRadians, speed, rotationType));
        }
        return this;
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["RotateBy"](this._actors[i], angleRadiansOffset, speed, rotationType));
        }
        return this;
    }
    /**
     * This method will scale an actor to the specified size at the speed
     * specified (in magnitude increase per second) and return back the
     * actor. This method is part of the actor 'Action' fluent API allowing
     * action chaining.
     * @param sizeX   The scaling factor to apply on X axis
     * @param sizeY   The scaling factor to apply on Y axis
     * @param speedX  The speed of scaling specified in magnitude increase per second on X axis
     * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis
     */
    scaleTo(sizeX, sizeY, speedX, speedY) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["ScaleTo"](this._actors[i], sizeX, sizeY, speedX, speedY));
        }
        return this;
    }
    /**
     * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec
     * and return back the actor. This method is part of the
     * actor 'Action' fluent API allowing action chaining.
     * @param sizeOffsetX   The scaling factor to apply on X axis
     * @param sizeOffsetY   The scaling factor to apply on Y axis
     * @param speed    The speed to scale at in scale units/sec
     */
    scaleBy(sizeOffsetX, sizeOffsetY, speed) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["ScaleBy"](this._actors[i], sizeOffsetX, sizeOffsetY, speed));
        }
        return this;
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks = 1) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["Blink"](this._actors[i], timeVisible, timeNotVisible, numBlinks));
        }
        return this;
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["Fade"](this._actors[i], opacity, time));
        }
        return this;
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["Delay"](this._actors[i], time));
        }
        return this;
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous actions. Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["Die"](this._actors[i]));
        }
        return this;
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["CallMethod"](this._actors[i], method));
        }
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the previously
     * called actions a certain number of times. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(times) {
        if (!times) {
            this.repeatForever();
            return this;
        }
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["Repeat"](this._actors[i], times, this._actors[i].actionQueue.getActions()));
        }
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the previously
     * called actions forever. This method is part of the actor 'Action'
     * fluent API allowing action chaining.
     */
    repeatForever() {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["RepeatForever"](this._actors[i], this._actors[i].actionQueue.getActions()));
        }
        return this;
    }
    /**
     * This method will cause the actor to follow another at a specified distance
     * @param actor           The actor to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(actor, followDistance) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            if (followDistance === undefined) {
                this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["Follow"](this._actors[i], actor));
            }
            else {
                this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["Follow"](this._actors[i], actor, followDistance));
            }
        }
        return this;
    }
    /**
     * This method will cause the actor to move towards another until they
     * collide "meet" at a specified speed.
     * @param actor  The actor to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(actor, speed) {
        const len = this._queues.length;
        for (let i = 0; i < len; i++) {
            if (speed === undefined) {
                this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["Meet"](this._actors[i], actor));
            }
            else {
                this._queues[i].add(new _Action__WEBPACK_IMPORTED_MODULE_0__["Meet"](this._actors[i], actor, speed));
            }
        }
        return this;
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    asPromise() {
        const promises = this._queues.map((q, i) => {
            const temp = new Promise((resolve) => {
                q.add(new _Action__WEBPACK_IMPORTED_MODULE_0__["CallMethod"](this._actors[i], () => {
                    resolve();
                }));
            });
            return temp;
        });
        return Promise.all(promises);
    }
}


/***/ }),

/***/ "./Actions/Actionable.ts":
/*!*******************************!*\
  !*** ./Actions/Actionable.ts ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Actions/Index.ts":
/*!**************************!*\
  !*** ./Actions/Index.ts ***!
  \**************************/
/*! exports provided: ActionContext, RotationType, Actions, Internal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Internal", function() { return Internal; });
/* harmony import */ var _ActionContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionContext */ "./Actions/ActionContext.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActionContext", function() { return _ActionContext__WEBPACK_IMPORTED_MODULE_0__["ActionContext"]; });

/* harmony import */ var _Actionable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actionable */ "./Actions/Actionable.ts");
/* empty/unused harmony star reexport *//* harmony import */ var _RotationType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RotationType */ "./Actions/RotationType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RotationType", function() { return _RotationType__WEBPACK_IMPORTED_MODULE_2__["RotationType"]; });

/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Action */ "./Actions/Action.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Actions", function() { return _Action__WEBPACK_IMPORTED_MODULE_3__; });





// legacy Internal.Actions namespace support
const Internal = { Actions: _Action__WEBPACK_IMPORTED_MODULE_3__ };


/***/ }),

/***/ "./Actions/RotationType.ts":
/*!*********************************!*\
  !*** ./Actions/RotationType.ts ***!
  \*********************************/
/*! exports provided: RotationType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RotationType", function() { return RotationType; });
/**
 * An enum that describes the strategies that rotation actions can use
 */
var RotationType;
(function (RotationType) {
    /**
     * Rotation via `ShortestPath` will use the smallest angle
     * between the starting and ending points. This strategy is the default behavior.
     */
    RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";
    /**
     * Rotation via `LongestPath` will use the largest angle
     * between the starting and ending points.
     */
    RotationType[RotationType["LongestPath"] = 1] = "LongestPath";
    /**
     * Rotation via `Clockwise` will travel in a clockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["Clockwise"] = 2] = "Clockwise";
    /**
     * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";
})(RotationType || (RotationType = {}));


/***/ }),

/***/ "./Actor.ts":
/*!******************!*\
  !*** ./Actor.ts ***!
  \******************/
/*! exports provided: isActor, ActorImpl, Actor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isActor", function() { return isActor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActorImpl", function() { return ActorImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Actor", function() { return Actor; });
/* harmony import */ var _Resources_Texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Resources/Texture */ "./Resources/Texture.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Drawing_Sprite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Drawing/Sprite */ "./Drawing/Sprite.ts");
/* harmony import */ var _Drawing_Animation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Drawing/Animation */ "./Drawing/Animation.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Actions_ActionContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Actions/ActionContext */ "./Actions/ActionContext.ts");
/* harmony import */ var _Actions_Action__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Actions/Action */ "./Actions/Action.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Algebra */ "./Algebra.ts");
/* harmony import */ var _Collision_Body__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Collision/Body */ "./Collision/Body.ts");
/* harmony import */ var _Configurable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Configurable */ "./Configurable.ts");
/* harmony import */ var _Traits_Index__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Traits/Index */ "./Traits/Index.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Collision/CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Util/Decorators */ "./Util/Decorators.ts");
/* harmony import */ var _Collision_Collider__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Collision/Collider */ "./Collision/Collider.ts");
/* harmony import */ var _Collision_Shape__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Collision/Shape */ "./Collision/Shape.ts");
/* harmony import */ var _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./EntityComponentSystem/Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _Drawing_CanvasDrawComponent__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Drawing/CanvasDrawComponent */ "./Drawing/CanvasDrawComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




















/**
 * Type guard for checking if something is an Actor
 * @param x
 */
function isActor(x) {
    return x instanceof Actor;
}
/**
 * @hidden
 */
class ActorImpl extends _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_17__["Entity"] {
    // #endregion
    /**
     * @param xOrConfig The starting x coordinate of the actor, or an option bag of [[ActorArgs]]
     * @param y         The starting y coordinate of the actor
     * @param width     The starting width of the actor
     * @param height    The starting height of the actor
     * @param color     The starting color of the actor. Leave null to draw a transparent actor. The opacity of the color will be used as the
     * initial [[opacity]].
     */
    constructor(xOrConfig, y, width, height, color) {
        super();
        this._height = 0;
        this._width = 0;
        /**
         * Indicates whether the actor is physically in the viewport
         */
        this.isOffScreen = false;
        /**
         * The visibility of an actor
         */
        this.visible = true;
        /**
         * The opacity of an actor. Passing in a color in the [[constructor]] will use the
         * color's opacity.
         */
        this.opacity = 1;
        this.previousOpacity = 1;
        /**
         * Convenience reference to the global logger
         */
        this.logger = _Util_Log__WEBPACK_IMPORTED_MODULE_5__["Logger"].getInstance();
        /**
         * The scene that the actor is in
         */
        this.scene = null;
        /**
         * The parent of this actor
         */
        this.parent = null;
        /**
         * The children of this actor
         */
        this.children = [];
        this.frames = {};
        /**
         * Access to the current drawing for the actor, this can be
         * an [[Animation]], [[Sprite]], or [[Polygon]].
         * Set drawings with [[setDrawing]].
         */
        this.currentDrawing = null;
        /**
         * Draggable helper
         */
        this._draggable = false;
        this._dragging = false;
        this._pointerDragStartHandler = () => {
            this._dragging = true;
        };
        this._pointerDragEndHandler = () => {
            this._dragging = false;
        };
        this._pointerDragMoveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.pointer.lastWorldPos;
            }
        };
        this._pointerDragLeaveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.pointer.lastWorldPos;
            }
        };
        /**
         * Modify the current actor update pipeline.
         */
        this.traits = [];
        /**
         * Whether or not to enable the [[CapturePointer]] trait that propagates
         * pointer events to this actor
         */
        this.enableCapturePointer = false;
        /**
         * Configuration for [[CapturePointer]] trait
         */
        this.capturePointer = {
            captureMoveEvents: false,
            captureDragEvents: false
        };
        this._isKilled = false;
        // #region Events
        this._capturePointerEvents = [
            'pointerup',
            'pointerdown',
            'pointermove',
            'pointerenter',
            'pointerleave',
            'pointerdragstart',
            'pointerdragend',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        this._captureMoveEvents = [
            'pointermove',
            'pointerenter',
            'pointerleave',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        this._captureDragEvents = [
            'pointerdragstart',
            'pointerdragend',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        // initialize default options
        this._initDefaults();
        this.addComponent(new _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_19__["TransformComponent"]());
        this.addComponent(new _Drawing_CanvasDrawComponent__WEBPACK_IMPORTED_MODULE_18__["CanvasDrawComponent"]((ctx, delta) => this.draw(ctx, delta)));
        let shouldInitializeBody = true;
        let collisionType = _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_13__["CollisionType"].Passive;
        if (xOrConfig && typeof xOrConfig === 'object') {
            const config = xOrConfig;
            if (config.pos) {
                xOrConfig = config.pos ? config.pos.x : 0;
                y = config.pos ? config.pos.y : 0;
            }
            else {
                xOrConfig = config.x || 0;
                y = config.y || 0;
            }
            width = config.width;
            height = config.height;
            if (config.body) {
                shouldInitializeBody = false;
                this.body = config.body;
            }
            if (config.anchor) {
                this.anchor = config.anchor;
            }
            if (config.collisionType) {
                collisionType = config.collisionType;
            }
        }
        // Body and collider bounds are still determined by actor width/height
        this._width = width || 0;
        this._height = height || 0;
        // Initialize default collider to be a box
        if (shouldInitializeBody) {
            this.body = new _Collision_Body__WEBPACK_IMPORTED_MODULE_9__["Body"]({
                collider: new _Collision_Collider__WEBPACK_IMPORTED_MODULE_15__["Collider"]({
                    type: collisionType,
                    shape: _Collision_Shape__WEBPACK_IMPORTED_MODULE_16__["Shape"].Box(this._width, this._height, this.anchor)
                })
            });
        }
        // Position uses body to store values must be initialized after body
        this.pos.x = xOrConfig || 0;
        this.pos.y = y || 0;
        if (color) {
            this.color = color;
            // set default opacity of an actor to the color
            this.opacity = color.a;
        }
        // Build default pipeline
        this.traits.push(new _Traits_Index__WEBPACK_IMPORTED_MODULE_11__["TileMapCollisionDetection"]());
        this.traits.push(new _Traits_Index__WEBPACK_IMPORTED_MODULE_11__["OffscreenCulling"]());
        this.traits.push(new _Traits_Index__WEBPACK_IMPORTED_MODULE_11__["CapturePointer"]());
        // Build the action queue
        this.actionQueue = new _Actions_Action__WEBPACK_IMPORTED_MODULE_7__["ActionQueue"](this);
        this.actions = new _Actions_ActionContext__WEBPACK_IMPORTED_MODULE_6__["ActionContext"](this);
    }
    /**
     * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
     * acceleration, mass, inertia, etc.
     */
    get body() {
        return this._body;
    }
    set body(body) {
        this._body = body;
        this._body.actor = this;
    }
    /**
     * Gets the position vector of the actor in pixels
     */
    get pos() {
        return this.body.pos;
    }
    /**
     * Sets the position vector of the actor in pixels
     */
    set pos(thePos) {
        this.body.pos.setTo(thePos.x, thePos.y);
    }
    /**
     * Gets the position vector of the actor from the last frame
     */
    get oldPos() {
        return this.body.oldPos;
    }
    /**
     * Sets the position vector of the actor in the last frame
     */
    set oldPos(thePos) {
        this.body.oldPos.setTo(thePos.x, thePos.y);
    }
    /**
     * Gets the velocity vector of the actor in pixels/sec
     */
    get vel() {
        return this.body.vel;
    }
    /**
     * Sets the velocity vector of the actor in pixels/sec
     */
    set vel(theVel) {
        this.body.vel.setTo(theVel.x, theVel.y);
    }
    /**
     * Gets the velocity vector of the actor from the last frame
     */
    get oldVel() {
        return this.body.oldVel;
    }
    /**
     * Sets the velocity vector of the actor from the last frame
     */
    set oldVel(theVel) {
        this.body.oldVel.setTo(theVel.x, theVel.y);
    }
    /**
     * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
     * useful to simulate a gravitational effect.
     */
    get acc() {
        return this.body.acc;
    }
    /**
     * Sets the acceleration vector of teh actor in pixels/second/second
     */
    set acc(theAcc) {
        this.body.acc.setTo(theAcc.x, theAcc.y);
    }
    /**
     * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    set oldAcc(theAcc) {
        this.body.oldAcc.setTo(theAcc.x, theAcc.y);
    }
    /**
     * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    get oldAcc() {
        return this.body.oldAcc;
    }
    /**
     * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    get rotation() {
        return this.body.rotation;
    }
    /**
     * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    set rotation(theAngle) {
        this.body.rotation = theAngle;
    }
    /**
     * Gets the rotational velocity of the actor in radians/second
     */
    get rx() {
        return this.body.rx;
    }
    /**
     * Sets the rotational velocity of the actor in radians/sec
     */
    set rx(angularVelocity) {
        this.body.rx = angularVelocity;
    }
    /**
     * Gets the scale vector of the actor
     * @obsolete ex.Actor.scale will be removed in v0.25.0, set width and height directly in constructor
     */
    get scale() {
        return this.body.scale;
    }
    /**
     * Sets the scale vector of the actor for
     * @obsolete ex.Actor.scale will be removed in v0.25.0, set width and height directly in constructor
     */
    set scale(scale) {
        this.body.scale = scale;
    }
    /**
     * Gets the old scale of the actor last frame
     * @obsolete ex.Actor.scale will be removed in v0.25.0, set width and height directly in constructor
     */
    get oldScale() {
        return this.body.oldScale;
    }
    /**
     * Sets the the old scale of the actor last frame
     * @obsolete ex.Actor.scale will be removed in v0.25.0, set width and height directly in constructor
     */
    set oldScale(scale) {
        this.body.oldScale = scale;
    }
    /**
     * Gets the x scalar velocity of the actor in scale/second
     * @obsolete ex.Actor.sx will be removed in v0.25.0, set width and height directly in constructor
     */
    get sx() {
        return this.body.sx;
    }
    /**
     * Sets the x scalar velocity of the actor in scale/second
     * @obsolete ex.Actor.sx will be removed in v0.25.0, set width and height directly in constructor
     */
    set sx(scalePerSecondX) {
        this.body.sx = scalePerSecondX;
    }
    /**
     * Gets the y scalar velocity of the actor in scale/second
     * @obsolete ex.Actor.sy will be removed in v0.25.0, set width and height directly in constructor
     */
    get sy() {
        return this.body.sy;
    }
    /**
     * Sets the y scale velocity of the actor in scale/second
     * @obsolete ex.Actor.sy will be removed in v0.25.0, set width and height directly in constructor
     */
    set sy(scalePerSecondY) {
        this.body.sy = scalePerSecondY;
    }
    get draggable() {
        return this._draggable;
    }
    set draggable(isDraggable) {
        if (isDraggable) {
            if (isDraggable && !this._draggable) {
                this.on('pointerdragstart', this._pointerDragStartHandler);
                this.on('pointerdragend', this._pointerDragEndHandler);
                this.on('pointerdragmove', this._pointerDragMoveHandler);
                this.on('pointerdragleave', this._pointerDragLeaveHandler);
            }
            else if (!isDraggable && this._draggable) {
                this.off('pointerdragstart', this._pointerDragStartHandler);
                this.off('pointerdragend', this._pointerDragEndHandler);
                this.off('pointerdragmove', this._pointerDragMoveHandler);
                this.off('pointerdragleave', this._pointerDragLeaveHandler);
            }
            this._draggable = isDraggable;
        }
    }
    /**
     * Sets the color of the actor. A rectangle of this color will be
     * drawn if no [[Drawable]] is specified as the actors drawing.
     *
     * The default is `null` which prevents a rectangle from being drawn.
     */
    get color() {
        return this._color;
    }
    set color(v) {
        this._color = v.clone();
    }
    /**
     * `onInitialize` is called before the first update of the actor. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        super._initialize(engine);
        for (const child of this.children) {
            child._initialize(engine);
        }
    }
    _initDefaults() {
        this.anchor = Actor.defaults.anchor.clone();
    }
    _checkForPointerOptIn(eventName) {
        if (eventName) {
            const normalized = eventName.toLowerCase();
            if (this._capturePointerEvents.indexOf(normalized) !== -1) {
                this.enableCapturePointer = true;
                if (this._captureMoveEvents.indexOf(normalized) !== -1) {
                    this.capturePointer.captureMoveEvents = true;
                }
                if (this._captureDragEvents.indexOf(normalized) !== -1) {
                    this.capturePointer.captureDragEvents = true;
                }
            }
        }
    }
    on(eventName, handler) {
        this._checkForPointerOptIn(eventName);
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        this._checkForPointerOptIn(eventName);
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    // #endregion
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPreKill]] lifecycle event
     * @internal
     */
    _prekill(_scene) {
        super.emit('prekill', new _Events__WEBPACK_IMPORTED_MODULE_1__["PreKillEvent"](this));
        this.onPreKill(_scene);
    }
    /**
     * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`
     *
     * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].
     */
    onPreKill(_scene) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPostKill]] lifecycle event
     * @internal
     */
    _postkill(_scene) {
        super.emit('postkill', new _Events__WEBPACK_IMPORTED_MODULE_1__["PostKillEvent"](this));
        this.onPostKill(_scene);
    }
    /**
     * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`
     *
     * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].
     */
    onPostKill(_scene) {
        // Override me
    }
    /**
     * If the current actor is a member of the scene, this will remove
     * it from the scene graph. It will no longer be drawn or updated.
     */
    kill() {
        if (this.scene) {
            this._prekill(this.scene);
            this.emit('kill', new _Events__WEBPACK_IMPORTED_MODULE_1__["KillEvent"](this));
            this._isKilled = true;
            this.scene.remove(this);
            this._postkill(this.scene);
        }
        else {
            this.logger.warn('Cannot kill actor, it was never added to the Scene');
        }
    }
    /**
     * If the current actor is killed, it will now not be killed.
     */
    unkill() {
        this._isKilled = false;
    }
    /**
     * Indicates wether the actor has been killed.
     */
    isKilled() {
        return this._isKilled;
    }
    /**
     * Adds a child actor to this actor. All movement of the child actor will be
     * relative to the parent actor. Meaning if the parent moves the child will
     * move with it.
     * @param actor The child actor to add
     */
    add(actor) {
        actor.body.collider.type = _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_13__["CollisionType"].PreventCollision;
        if (_Util_Util__WEBPACK_IMPORTED_MODULE_12__["addItemToArray"](actor, this.children)) {
            actor.parent = this;
            if (this.scene) {
                this.scene.world.add(actor);
            }
        }
    }
    /**
     * Removes a child actor from this actor.
     * @param actor The child actor to remove
     */
    remove(actor) {
        if (_Util_Util__WEBPACK_IMPORTED_MODULE_12__["removeItemFromArray"](actor, this.children)) {
            actor.parent = null;
        }
    }
    setDrawing(key) {
        key = key.toString();
        if (this.currentDrawing !== this.frames[key]) {
            if (this.frames[key] != null) {
                this.frames[key].reset();
                this.currentDrawing = this.frames[key];
            }
            else {
                _Util_Log__WEBPACK_IMPORTED_MODULE_5__["Logger"].getInstance().error(`the specified drawing key ${key} does not exist`);
            }
        }
        if (this.currentDrawing && this.currentDrawing instanceof _Drawing_Animation__WEBPACK_IMPORTED_MODULE_4__["Animation"]) {
            this.currentDrawing.tick(0);
        }
    }
    addDrawing() {
        if (arguments.length === 2) {
            this.frames[arguments[0]] = arguments[1];
            if (!this.currentDrawing) {
                this.currentDrawing = arguments[1];
            }
        }
        else {
            if (arguments[0] instanceof _Drawing_Sprite__WEBPACK_IMPORTED_MODULE_3__["Sprite"]) {
                this.addDrawing('default', arguments[0]);
            }
            if (arguments[0] instanceof _Resources_Texture__WEBPACK_IMPORTED_MODULE_0__["Texture"]) {
                this.addDrawing('default', arguments[0].asSprite());
            }
        }
    }
    get z() {
        return this.getZIndex();
    }
    set z(newZ) {
        this.setZIndex(newZ);
    }
    /**
     * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     * @deprecated Use actor.z
     */
    getZIndex() {
        return this.components.transform.z;
    }
    /**
     * Sets the z-index of an actor and updates it in the drawing list for the scene.
     * The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     * @param newIndex new z-index to assign
     * @deprecated Use actor.z
     */
    setZIndex(newIndex) {
        this.components.transform.z = newIndex;
    }
    /**
     * Get the center point of an actor
     */
    get center() {
        return new _Algebra__WEBPACK_IMPORTED_MODULE_8__["Vector"](this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);
    }
    get width() {
        return this._width * this.getGlobalScale().x;
    }
    set width(width) {
        this._width = width / this.scale.x;
        this.body.collider.shape = _Collision_Shape__WEBPACK_IMPORTED_MODULE_16__["Shape"].Box(this._width, this._height, this.anchor);
        this.body.markCollisionShapeDirty();
    }
    get height() {
        return this._height * this.getGlobalScale().y;
    }
    set height(height) {
        this._height = height / this.scale.y;
        this.body.collider.shape = _Collision_Shape__WEBPACK_IMPORTED_MODULE_16__["Shape"].Box(this._width, this._height, this.anchor);
        this.body.markCollisionShapeDirty();
    }
    /**
     * Gets this actor's rotation taking into account any parent relationships
     *
     * @returns Rotation angle in radians
     */
    getWorldRotation() {
        if (!this.parent) {
            return this.rotation;
        }
        return this.rotation + this.parent.getWorldRotation();
    }
    /**
     * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
     *
     * @returns Position in world coordinates
     */
    getWorldPos() {
        if (!this.parent) {
            return this.pos.clone();
        }
        // collect parents
        const parents = [];
        let root = this;
        parents.push(this);
        // find parents
        while (root.parent) {
            root = root.parent;
            parents.push(root);
        }
        // calculate position
        const x = parents.reduceRight((px, p) => {
            if (p.parent) {
                return px + p.pos.x * p.getGlobalScale().x;
            }
            return px + p.pos.x;
        }, 0);
        const y = parents.reduceRight((py, p) => {
            if (p.parent) {
                return py + p.pos.y * p.getGlobalScale().y;
            }
            return py + p.pos.y;
        }, 0);
        // rotate around root anchor
        const ra = root.getWorldPos(); // 10, 10
        const r = this.getWorldRotation();
        return new _Algebra__WEBPACK_IMPORTED_MODULE_8__["Vector"](x, y).rotate(r, ra);
    }
    /**
     * Gets the global scale of the Actor
     */
    getGlobalScale() {
        if (!this.parent) {
            return new _Algebra__WEBPACK_IMPORTED_MODULE_8__["Vector"](this.scale.x, this.scale.y);
        }
        const parentScale = this.parent.getGlobalScale();
        return new _Algebra__WEBPACK_IMPORTED_MODULE_8__["Vector"](this.scale.x * parentScale.x, this.scale.y * parentScale.y);
    }
    // #region Collision
    /**
     * Tests whether the x/y specified are contained in the actor
     * @param x  X coordinate to test (in world coordinates)
     * @param y  Y coordinate to test (in world coordinates)
     * @param recurse checks whether the x/y are contained in any child actors (if they exist).
     */
    contains(x, y, recurse = false) {
        // These shenanigans are to handle child actor containment,
        // the only time getWorldPos and pos are different is a child actor
        const childShift = this.getWorldPos().sub(this.pos);
        const containment = this.body.collider.bounds.translate(childShift).contains(new _Algebra__WEBPACK_IMPORTED_MODULE_8__["Vector"](x, y));
        if (recurse) {
            return (containment ||
                this.children.some((child) => {
                    return child.contains(x, y, true);
                }));
        }
        return containment;
    }
    /**
     * Returns true if the two actor.body.collider.shape's surfaces are less than or equal to the distance specified from each other
     * @param actor     Actor to test
     * @param distance  Distance in pixels to test
     */
    within(actor, distance) {
        return this.body.collider.shape.getClosestLineBetween(actor.body.collider.shape).getLength() <= distance;
    }
    // #endregion
    // #region Update
    /**
     * Called by the Engine, updates the state of the actor
     * @param engine The reference to the current game engine
     * @param delta  The time elapsed since the last update in milliseconds
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        // Tick animations
        const drawing = this.currentDrawing;
        if (drawing && drawing instanceof _Drawing_Animation__WEBPACK_IMPORTED_MODULE_4__["Animation"]) {
            drawing.tick(delta, engine.stats.currFrame.id);
        }
        // Update action queue
        this.actionQueue.update(delta);
        // Update color only opacity
        if (this.color) {
            this.color.a = this.opacity;
        }
        if (this.opacity === 0) {
            this.visible = false;
        }
        // capture old transform
        this.body.captureOldTransform();
        // Run Euler integration
        this.body.integrate(delta);
        // Update actor pipeline (movement, collision detection, event propagation, offscreen culling)
        for (const trait of this.traits) {
            trait.update(this, engine, delta);
        }
        // Update child actors
        for (let i = 0; i < this.children.length; i++) {
            this.children[i].update(engine, delta);
        }
        this._postupdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an actor is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an actor is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_1__["PreUpdateEvent"](engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_1__["PreUpdateEvent"](engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    // endregion
    // #region Drawing
    /**
     * Called by the Engine, draws the actor to the screen
     * @param ctx   The rendering context
     * @param delta The time since the last draw in milliseconds
     */
    draw(ctx, delta) {
        // translate canvas by anchor offset
        ctx.save();
        ctx.translate(-(this._width * this.anchor.x), -(this._height * this.anchor.y));
        this._predraw(ctx, delta);
        if (this.currentDrawing) {
            const drawing = this.currentDrawing;
            // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula
            const offsetX = (this._width - drawing.width * drawing.scale.x) * this.anchor.x;
            const offsetY = (this._height - drawing.height * drawing.scale.y) * this.anchor.y;
            this.currentDrawing.draw({ ctx, x: offsetX, y: offsetY, opacity: this.opacity });
        }
        else {
            if (this.color && this.body && this.body.collider && this.body.collider.shape) {
                this.body.collider.shape.draw(ctx, this.color, new _Algebra__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0));
            }
        }
        ctx.restore();
        this._postdraw(ctx, delta);
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('predraw', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before an actor is drawn, but after local transforms are made.
     */
    onPreDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('postdraw', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after an actor is drawn, and before local transforms are removed.
     */
    onPostDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     * @internal
     */
    _predraw(ctx, delta) {
        this.emit('predraw', new _Events__WEBPACK_IMPORTED_MODULE_1__["PreDrawEvent"](ctx, delta, this));
        this.onPreDraw(ctx, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     * @internal
     */
    _postdraw(ctx, delta) {
        this.emit('postdraw', new _Events__WEBPACK_IMPORTED_MODULE_1__["PreDrawEvent"](ctx, delta, this));
        this.onPostDraw(ctx, delta);
    }
    /**
     * Called by the Engine, draws the actors debugging to the screen
     * @param ctx The rendering context
     */
    /* istanbul ignore next */
    debugDraw(ctx) {
        this.emit('predebugdraw', new _Events__WEBPACK_IMPORTED_MODULE_1__["PreDebugDrawEvent"](ctx, this));
        this.body.collider.debugDraw(ctx);
        // Draw actor bounding box
        const bb = this.body.collider.localBounds.translate(this.getWorldPos());
        bb.debugDraw(ctx);
        // Draw actor Id
        ctx.fillText('id: ' + this.id, bb.left + 3, bb.top + 10);
        // Draw actor anchor Vector
        ctx.fillStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].Yellow.toString();
        ctx.beginPath();
        ctx.arc(this.getWorldPos().x, this.getWorldPos().y, 3, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        // Culling Box debug draw
        for (let j = 0; j < this.traits.length; j++) {
            if (this.traits[j] instanceof _Traits_Index__WEBPACK_IMPORTED_MODULE_11__["OffscreenCulling"]) {
                this.traits[j].cullingBox.debugDraw(ctx); // eslint-disable-line
            }
        }
        // Unit Circle debug draw
        ctx.strokeStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].Yellow.toString();
        ctx.beginPath();
        const radius = Math.min(this.width, this.height);
        ctx.arc(this.getWorldPos().x, this.getWorldPos().y, radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
        const ticks = {
            '0 Pi': 0,
            'Pi/2': Math.PI / 2,
            Pi: Math.PI,
            '3/2 Pi': (3 * Math.PI) / 2
        };
        const oldFont = ctx.font;
        for (const tick in ticks) {
            ctx.fillStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].Yellow.toString();
            ctx.font = '14px';
            ctx.textAlign = 'center';
            ctx.fillText(tick, this.getWorldPos().x + Math.cos(ticks[tick]) * (radius + 10), this.getWorldPos().y + Math.sin(ticks[tick]) * (radius + 10));
        }
        ctx.font = oldFont;
        // Draw child actors
        for (let i = 0; i < this.children.length; i++) {
            this.children[i].debugDraw(ctx);
        }
        this.emit('postdebugdraw', new _Events__WEBPACK_IMPORTED_MODULE_1__["PostDebugDrawEvent"](ctx, this));
    }
    /**
     * Returns the full array of ancestors
     */
    getAncestors() {
        const path = [this];
        let currentActor = this;
        let parent;
        while ((parent = currentActor.parent)) {
            currentActor = parent;
            path.push(currentActor);
        }
        return path.reverse();
    }
}
// #region Properties
/**
 * Indicates the next id to be set
 */
ActorImpl.defaults = {
    anchor: _Algebra__WEBPACK_IMPORTED_MODULE_8__["Vector"].Half
};
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_14__["obsolete"])({ message: 'ex.Actor.sx will be removed in v0.25.0', alternateMethod: 'Set width and height directly in constructor' })
], ActorImpl.prototype, "sx", null);
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_14__["obsolete"])({ message: 'ex.Actor.sy will be removed in v0.25.0', alternateMethod: 'Set width and height directly in constructor' })
], ActorImpl.prototype, "sy", null);
/**
 * The most important primitive in Excalibur is an `Actor`. Anything that
 * can move on the screen, collide with another `Actor`, respond to events,
 * or interact with the current scene, must be an actor. An `Actor` **must**
 * be part of a [[Scene]] for it to be drawn to the screen.
 */
class Actor extends Object(_Configurable__WEBPACK_IMPORTED_MODULE_10__["Configurable"])(ActorImpl) {
    constructor(xOrConfig, y, width, height, color) {
        super(xOrConfig, y, width, height, color);
    }
}


/***/ }),

/***/ "./Algebra.ts":
/*!********************!*\
  !*** ./Algebra.ts ***!
  \********************/
/*! exports provided: Vector, Ray, Line, Projection, GlobalCoordinates, vec */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Projection", function() { return Projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GlobalCoordinates", function() { return GlobalCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec", function() { return vec; });
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Util/Decorators */ "./Util/Decorators.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * A 2D vector on a plane.
 */
class Vector {
    /**
     * @param x  X component of the Vector
     * @param y  Y component of the Vector
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * A (0, 0) vector
     */
    static get Zero() {
        return new Vector(0, 0);
    }
    /**
     * A (1, 1) vector
     */
    static get One() {
        return new Vector(1, 1);
    }
    /**
     * A (0.5, 0.5) vector
     */
    static get Half() {
        return new Vector(0.5, 0.5);
    }
    /**
     * A unit vector pointing up (0, -1)
     */
    static get Up() {
        return new Vector(0, -1);
    }
    /**
     * A unit vector pointing down (0, 1)
     */
    static get Down() {
        return new Vector(0, 1);
    }
    /**
     * A unit vector pointing left (-1, 0)
     */
    static get Left() {
        return new Vector(-1, 0);
    }
    /**
     * A unit vector pointing right (1, 0)
     */
    static get Right() {
        return new Vector(1, 0);
    }
    /**
     * Returns a vector of unit length in the direction of the specified angle in Radians.
     * @param angle The angle to generate the vector
     */
    static fromAngle(angle) {
        return new Vector(Math.cos(angle), Math.sin(angle));
    }
    /**
     * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
     */
    static isValid(vec) {
        if (vec === null || vec === undefined) {
            return false;
        }
        if (isNaN(vec.x) || isNaN(vec.y)) {
            return false;
        }
        if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {
            return false;
        }
        return true;
    }
    /**
     * Calculates distance between two Vectors
     * @param vec1
     * @param vec2
     */
    static distance(vec1, vec2) {
        return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
    }
    /**
     * Sets the x and y components at once
     */
    setTo(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Compares this point against another and tests for equality
     * @param vector The other point to compare to
     * @param tolerance Amount of euclidean distance off we are willing to tolerate
     */
    equals(vector, tolerance = 0.001) {
        return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
    }
    /**
     * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
     * @param v  The other vector. Leave blank to use origin vector.
     */
    distance(v) {
        if (!v) {
            v = Vector.Zero;
        }
        return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
    }
    /**
     * The magnitude (size) of the Vector
     * @obsolete magnitude will be removed in favour of '.size' in version 0.25.0
     */
    magnitude() {
        return this.distance();
    }
    /**
     * The size(magnitude) of the Vector
     */
    get size() {
        return this.distance();
    }
    set size(newLength) {
        const v = this.normalize().scale(newLength);
        this.x = v.x;
        this.y = v.y;
    }
    /**
     * Normalizes a vector to have a magnitude of 1.
     */
    normalize() {
        const d = this.distance();
        if (d > 0) {
            return new Vector(this.x / d, this.y / d);
        }
        else {
            return new Vector(0, 1);
        }
    }
    /**
     * Returns the average (midpoint) between the current point and the specified
     */
    average(vec) {
        return this.add(vec).scale(0.5);
    }
    scale(sizeOrScale) {
        if (sizeOrScale instanceof Vector) {
            return new Vector(this.x * sizeOrScale.x, this.y * sizeOrScale.y);
        }
        else {
            return new Vector(this.x * sizeOrScale, this.y * sizeOrScale);
        }
    }
    /**
     * Adds one vector to another
     * @param v The vector to add
     */
    add(v) {
        return new Vector(this.x + v.x, this.y + v.y);
    }
    /**
     * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B
     * @param v The vector to subtract
     */
    sub(v) {
        return new Vector(this.x - v.x, this.y - v.y);
    }
    /**
     * Adds one vector to this one modifying the original
     * @param v The vector to add
     */
    addEqual(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    /**
     * Subtracts a vector from this one modifying the original
     * @param v The vector to subtract
     */
    subEqual(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    /**
     * Scales this vector by a factor of size and modifies the original
     */
    scaleEqual(size) {
        this.x *= size;
        this.y *= size;
        return this;
    }
    /**
     * Performs a dot product with another vector
     * @param v  The vector to dot
     */
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        if (v instanceof Vector) {
            return this.x * v.y - this.y * v.x;
        }
        else if (typeof v === 'number') {
            return new Vector(v * this.y, -v * this.x);
        }
    }
    /**
     * Returns the perpendicular vector to this one
     */
    perpendicular() {
        return new Vector(this.y, -this.x);
    }
    /**
     * Returns the normal vector to this one, same as the perpendicular of length 1
     */
    normal() {
        return this.perpendicular().normalize();
    }
    /**
     * Negate the current vector
     */
    negate() {
        return this.scale(-1);
    }
    /**
     * Returns the angle of this vector.
     */
    toAngle() {
        return Math.atan2(this.y, this.x);
    }
    /**
     * Rotates the current vector around a point by a certain number of
     * degrees in radians
     */
    rotate(angle, anchor) {
        if (!anchor) {
            anchor = new Vector(0, 0);
        }
        const sinAngle = Math.sin(angle);
        const cosAngle = Math.cos(angle);
        const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
        const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
        return new Vector(x, y);
    }
    /**
     * Creates new vector that has the same values as the previous.
     */
    clone() {
        return new Vector(this.x, this.y);
    }
    /**
     * Returns a string representation of the vector.
     */
    toString() {
        return `(${this.x}, ${this.y})`;
    }
}
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_1__["obsolete"])({ message: 'will be removed in favour of `.size` in version 0.25.0' })
], Vector.prototype, "magnitude", null);
/**
 * A 2D ray that can be cast into the scene to do collision detection
 */
class Ray {
    /**
     * @param pos The starting position for the ray
     * @param dir The vector indicating the direction of the ray
     */
    constructor(pos, dir) {
        this.pos = pos;
        this.dir = dir.normalize();
    }
    /**
     * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
     * This number indicates the mathematical intersection time.
     * @param line  The line to test
     */
    intersect(line) {
        const numerator = line.begin.sub(this.pos);
        // Test is line and ray are parallel and non intersecting
        if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
            return -1;
        }
        // Lines are parallel
        const divisor = this.dir.cross(line.getSlope());
        if (divisor === 0) {
            return -1;
        }
        const t = numerator.cross(line.getSlope()) / divisor;
        if (t >= 0) {
            const u = numerator.cross(this.dir) / divisor / line.getLength();
            if (u >= 0 && u <= 1) {
                return t;
            }
        }
        return -1;
    }
    /**
     * Returns the point of intersection given the intersection time
     */
    getPoint(time) {
        return this.pos.add(this.dir.scale(time));
    }
}
/**
 * A 2D line segment
 */
class Line {
    /**
     * @param begin  The starting point of the line segment
     * @param end  The ending point of the line segment
     */
    constructor(begin, end) {
        this.begin = begin;
        this.end = end;
    }
    /**
     * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
     */
    get slope() {
        return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
    }
    /**
     * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
     */
    get intercept() {
        return this.begin.y - this.slope * this.begin.x;
    }
    /**
     * Gets the normal of the line
     */
    normal() {
        return this.end.sub(this.begin).normal();
    }
    /**
     * Returns the slope of the line in the form of a vector of length 1
     */
    getSlope() {
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the edge of the line as vector, the length of the vector is the length of the edge
     */
    getEdge() {
        const begin = this.begin;
        const end = this.end;
        return end.sub(begin);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Returns the midpoint of the edge
     */
    get midpoint() {
        return this.begin.add(this.end).scale(0.5);
    }
    /**
     * Flips the direction of the line segment
     */
    flip() {
        return new Line(this.end, this.begin);
    }
    /**
     * Find the perpendicular distance from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * @param point
     */
    distanceToPoint(point) {
        const x0 = point.x;
        const y0 = point.y;
        const l = this.getLength();
        const dy = this.end.y - this.begin.y;
        const dx = this.end.x - this.begin.x;
        const distance = Math.abs(dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
        return distance;
    }
    /**
     * Find the perpendicular line from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * (a - p) - ((a - p) * n)n
     * a is a point on the line
     * p is the arbitrary point above the line
     * n is a unit vector in direction of the line
     * @param point
     */
    findVectorToPoint(point) {
        const aMinusP = this.begin.sub(point);
        const n = this.getSlope();
        return aMinusP.sub(n.scale(aMinusP.dot(n)));
    }
    /**
     * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
     * a new point with the calculated Y value and vice-versa.
     *
     * @param x The known X value of the target point
     * @param y The known Y value of the target point
     * @returns A new point with the other calculated axis value
     */
    findPoint(x = null, y = null) {
        const m = this.slope;
        const b = this.intercept;
        if (x !== null) {
            return new Vector(x, m * x + b);
        }
        else if (y !== null) {
            return new Vector((y - b) / m, y);
        }
        else {
            throw new Error('You must provide an X or a Y value');
        }
    }
    /**
     * @see http://stackoverflow.com/a/11908158/109458
     */
    hasPoint() {
        let currPoint;
        let threshold = 0;
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            currPoint = new Vector(arguments[0], arguments[1]);
            threshold = arguments[2] || 0;
        }
        else if (arguments[0] instanceof Vector) {
            currPoint = arguments[0];
            threshold = arguments[1] || 0;
        }
        else {
            throw 'Could not determine the arguments for Vector.hasPoint';
        }
        const dxc = currPoint.x - this.begin.x;
        const dyc = currPoint.y - this.begin.y;
        const dx1 = this.end.x - this.begin.x;
        const dy1 = this.end.y - this.begin.y;
        const cross = dxc * dy1 - dyc * dx1;
        // check whether point lines on the line
        if (Math.abs(cross) > threshold) {
            return false;
        }
        // check whether point lies in-between start and end
        if (Math.abs(dx1) >= Math.abs(dy1)) {
            return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
        }
        else {
            return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
        }
    }
}
/**
 * A 1 dimensional projection on an axis, used to test overlaps
 */
class Projection {
    constructor(min, max) {
        this.min = min;
        this.max = max;
    }
    overlaps(projection) {
        return this.max > projection.min && projection.max > this.min;
    }
    getOverlap(projection) {
        if (this.overlaps(projection)) {
            if (this.max > projection.max) {
                return projection.max - this.min;
            }
            else {
                return this.max - projection.min;
            }
        }
        return 0;
    }
}
class GlobalCoordinates {
    constructor(worldPos, pagePos, screenPos) {
        this.worldPos = worldPos;
        this.pagePos = pagePos;
        this.screenPos = screenPos;
    }
    static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {
        let pageX;
        let pageY;
        let pagePos;
        let engine;
        if (arguments.length === 3) {
            pageX = xOrPos;
            pageY = yOrEngine;
            pagePos = new Vector(pageX, pageY);
            engine = engineOrUndefined;
        }
        else {
            pagePos = xOrPos;
            pageX = pagePos.x;
            pageY = pagePos.y;
            engine = yOrEngine;
        }
        const screenX = pageX - _Util_Util__WEBPACK_IMPORTED_MODULE_0__["getPosition"](engine.canvas).x;
        const screenY = pageY - _Util_Util__WEBPACK_IMPORTED_MODULE_0__["getPosition"](engine.canvas).y;
        const screenPos = new Vector(screenX, screenY);
        const worldPos = engine.screenToWorldCoordinates(screenPos);
        return new GlobalCoordinates(worldPos, pagePos, screenPos);
    }
}
/**
 * Shorthand for creating new Vectors - returns a new Vector instance with the
 * provided X and Y components.
 *
 * @param x  X component of the Vector
 * @param y  Y component of the Vector
 */
function vec(x, y) {
    return new Vector(x, y);
}


/***/ }),

/***/ "./Camera.ts":
/*!*******************!*\
  !*** ./Camera.ts ***!
  \*******************/
/*! exports provided: StrategyContainer, Axis, LockCameraToActorStrategy, LockCameraToActorAxisStrategy, ElasticToActorStrategy, RadiusAroundActorStrategy, LimitCameraBoundsStrategy, Camera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StrategyContainer", function() { return StrategyContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Axis", function() { return Axis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LockCameraToActorStrategy", function() { return LockCameraToActorStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LockCameraToActorAxisStrategy", function() { return LockCameraToActorAxisStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ElasticToActorStrategy", function() { return ElasticToActorStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RadiusAroundActorStrategy", function() { return RadiusAroundActorStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LimitCameraBoundsStrategy", function() { return LimitCameraBoundsStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony import */ var _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util/EasingFunctions */ "./Util/EasingFunctions.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Algebra */ "./Algebra.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Class */ "./Class.ts");
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Collision/BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Util/Log */ "./Util/Log.ts");







/**
 * Container to house convenience strategy methods
 * @internal
 */
class StrategyContainer {
    constructor(camera) {
        this.camera = camera;
    }
    /**
     * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
     * @param actor The actor to lock the camera to
     */
    lockToActor(actor) {
        this.camera.addStrategy(new LockCameraToActorStrategy(actor));
    }
    /**
     * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
     * @param actor The actor to lock the camera to
     * @param axis The axis to follow the actor on
     */
    lockToActorAxis(actor, axis) {
        this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
    }
    /**
     * Creates and adds the [[ElasticToActorStrategy]] on the current camera
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param actor Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    elasticToActor(actor, cameraElasticity, cameraFriction) {
        this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
    }
    /**
     * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
     * @param actor Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    radiusAroundActor(actor, radius) {
        this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
    }
    /**
     * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera
     * @param box The bounding box to limit the camera to.
     */
    limitCameraBounds(box) {
        this.camera.addStrategy(new LimitCameraBoundsStrategy(box));
    }
}
/**
 * Camera axis enum
 */
var Axis;
(function (Axis) {
    Axis[Axis["X"] = 0] = "X";
    Axis[Axis["Y"] = 1] = "Y";
})(Axis || (Axis = {}));
/**
 * Lock a camera to the exact x/y position of an actor.
 */
class LockCameraToActorStrategy {
    constructor(target) {
        this.target = target;
        this.action = (target, _cam, _eng, _delta) => {
            const center = target.center;
            return center;
        };
    }
}
/**
 * Lock a camera to a specific axis around an actor.
 */
class LockCameraToActorAxisStrategy {
    constructor(target, axis) {
        this.target = target;
        this.axis = axis;
        this.action = (target, cam, _eng, _delta) => {
            const center = target.center;
            const currentFocus = cam.getFocus();
            if (this.axis === Axis.X) {
                return new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](center.x, currentFocus.y);
            }
            else {
                return new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](currentFocus.x, center.y);
            }
        };
    }
}
/**
 * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
 */
class ElasticToActorStrategy {
    /**
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param target Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    constructor(target, cameraElasticity, cameraFriction) {
        this.target = target;
        this.cameraElasticity = cameraElasticity;
        this.cameraFriction = cameraFriction;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            let focus = cam.getFocus();
            let cameraVel = cam.vel.clone();
            // Calculate the stretch vector, using the spring equation
            // F = kX
            // https://en.wikipedia.org/wiki/Hooke's_law
            // Apply to the current camera velocity
            const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X
            cameraVel = cameraVel.add(stretch);
            // Calculate the friction (-1 to apply a force in the opposition of motion)
            // Apply to the current camera velocity
            const friction = cameraVel.scale(-1).scale(this.cameraFriction);
            cameraVel = cameraVel.add(friction);
            // Update position by velocity deltas
            focus = focus.add(cameraVel);
            return focus;
        };
    }
}
class RadiusAroundActorStrategy {
    /**
     *
     * @param target Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    constructor(target, radius) {
        this.target = target;
        this.radius = radius;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            const focus = cam.getFocus();
            const direction = position.sub(focus);
            const distance = direction.size;
            if (distance >= this.radius) {
                const offset = distance - this.radius;
                return focus.add(direction.normalize().scale(offset));
            }
            return focus;
        };
    }
}
/**
 * Prevent a camera from going beyond the given camera dimensions.
 */
class LimitCameraBoundsStrategy {
    constructor(target) {
        this.target = target;
        /**
         * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.
         *
         * Note that this strategy does not perform any movement by itself.
         * It only sets the camera position to within the given bounds when the camera has gone beyond them.
         * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.
         *
         * Make sure that the camera bounds are at least as large as the viewport size.
         *
         * @param target The bounding box to limit the camera to
         */
        this.boundSizeChecked = false; // Check and warn only once
        this.action = (target, cam, _eng, _delta) => {
            const focus = cam.getFocus();
            if (!this.boundSizeChecked) {
                if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {
                    _Util_Log__WEBPACK_IMPORTED_MODULE_6__["Logger"].getInstance().warn('Camera bounds should not be smaller than the engine viewport');
                }
                this.boundSizeChecked = true;
            }
            if (focus.x < target.left + _eng.halfDrawWidth) {
                focus.x = target.left + _eng.halfDrawWidth;
            }
            else if (focus.x > target.right - _eng.halfDrawWidth) {
                focus.x = target.right - _eng.halfDrawWidth;
            }
            if (focus.y < target.top + _eng.halfDrawHeight) {
                focus.y = target.top + _eng.halfDrawHeight;
            }
            else if (focus.y > target.bottom - _eng.halfDrawHeight) {
                focus.y = target.bottom - _eng.halfDrawHeight;
            }
            return focus;
        };
    }
}
/**
 * Cameras
 *
 * [[Camera]] is the base class for all Excalibur cameras. Cameras are used
 * to move around your game and set focus. They are used to determine
 * what is "off screen" and can be used to scale the game.
 *
 */
class Camera extends _Class__WEBPACK_IMPORTED_MODULE_4__["Class"] {
    constructor() {
        super(...arguments);
        this._cameraStrategies = [];
        this.strategy = new StrategyContainer(this);
        /**
         * Get or set current zoom of the camera, defaults to 1
         */
        this.z = 1;
        /**
         * Get or set rate of change in zoom, defaults to 0
         */
        this.dz = 0;
        /**
         * Get or set zoom acceleration
         */
        this.az = 0;
        /**
         * Current rotation of the camera
         */
        this.rotation = 0;
        /**
         * Current angular velocity
         */
        this.rx = 0;
        /**
         * Get or set the camera's position
         */
        this.pos = _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].Zero;
        /**
         * Get or set the camera's velocity
         */
        this.vel = _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].Zero;
        /**
         * GEt or set the camera's acceleration
         */
        this.acc = _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].Zero;
        this._cameraMoving = false;
        this._currentLerpTime = 0;
        this._lerpDuration = 1000; // 1 second
        this._lerpStart = null;
        this._lerpEnd = null;
        //camera effects
        this._isShaking = false;
        this._shakeMagnitudeX = 0;
        this._shakeMagnitudeY = 0;
        this._shakeDuration = 0;
        this._elapsedShakeTime = 0;
        this._xShake = 0;
        this._yShake = 0;
        this._isZooming = false;
        this._zoomStart = 1;
        this._zoomEnd = 1;
        this._currentZoomTime = 0;
        this._zoomDuration = 0;
        this._zoomEasing = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_0__["EasingFunctions"].EaseInOutCubic;
        this._easing = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_0__["EasingFunctions"].EaseInOutCubic;
        this._isInitialized = false;
    }
    /**
     * Get or set the camera's angular velocity
     */
    get angularVelocity() {
        return this.rx;
    }
    set angularVelocity(value) {
        this.rx = value;
    }
    /**
     * Get the camera's x position
     */
    get x() {
        return this.pos.x;
    }
    /**
     * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
     */
    set x(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos.x = value;
        }
    }
    /**
     * Get the camera's y position
     */
    get y() {
        return this.pos.y;
    }
    /**
     * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
     */
    set y(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos.y = value;
        }
    }
    /**
     * Get or set the camera's x velocity
     */
    get dx() {
        return this.vel.x;
    }
    set dx(value) {
        this.vel.x = value;
    }
    /**
     * Get or set the camera's y velocity
     */
    get dy() {
        return this.vel.y;
    }
    set dy(value) {
        this.vel.y = value;
    }
    /**
     * Get or set the camera's x acceleration
     */
    get ax() {
        return this.acc.x;
    }
    set ax(value) {
        this.acc.x = value;
    }
    /**
     * Get or set the camera's y acceleration
     */
    get ay() {
        return this.acc.y;
    }
    set ay(value) {
        this.acc.y = value;
    }
    /**
     * Returns the focal point of the camera, a new point giving the x and y position of the camera
     */
    getFocus() {
        return this.pos;
    }
    /**
     * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
     *
     * @param pos The target position to move to
     * @param duration The duration in milliseconds the move should last
     * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
     * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
     *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
     */
    move(pos, duration, easingFn = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_0__["EasingFunctions"].EaseInOutCubic) {
        if (typeof easingFn !== 'function') {
            throw 'Please specify an EasingFunction';
        }
        // cannot move when following an actor
        if (this._follow) {
            return Promise.reject(pos);
        }
        // resolve existing promise, if any
        if (this._lerpPromise && this._lerpResolve) {
            this._lerpResolve(pos);
        }
        this._lerpPromise = new Promise((resolve) => {
            this._lerpResolve = resolve;
        });
        this._lerpStart = this.getFocus().clone();
        this._lerpDuration = duration;
        this._lerpEnd = pos;
        this._currentLerpTime = 0;
        this._cameraMoving = true;
        this._easing = easingFn;
        return this._lerpPromise;
    }
    /**
     * Sets the camera to shake at the specified magnitudes for the specified duration
     * @param magnitudeX  The x magnitude of the shake
     * @param magnitudeY  The y magnitude of the shake
     * @param duration    The duration of the shake in milliseconds
     */
    shake(magnitudeX, magnitudeY, duration) {
        this._isShaking = true;
        this._shakeMagnitudeX = magnitudeX;
        this._shakeMagnitudeY = magnitudeY;
        this._shakeDuration = duration;
    }
    /**
     * Zooms the camera in or out by the specified scale over the specified duration.
     * If no duration is specified, it take effect immediately.
     * @param scale    The scale of the zoom
     * @param duration The duration of the zoom in milliseconds
     */
    zoom(scale, duration = 0, easingFn = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_0__["EasingFunctions"].EaseInOutCubic) {
        this._zoomPromise = new Promise((resolve) => {
            this._zoomResolve = resolve;
        });
        if (duration) {
            this._isZooming = true;
            this._zoomEasing = easingFn;
            this._currentZoomTime = 0;
            this._zoomDuration = duration;
            this._zoomStart = this.z;
            this._zoomEnd = scale;
        }
        else {
            this._isZooming = false;
            this.z = scale;
            return Promise.resolve(true);
        }
        return this._zoomPromise;
    }
    /**
     * Gets the current zoom scale
     */
    getZoom() {
        return this.z;
    }
    /**
     * Gets the bounding box of the viewport of this camera in world coordinates
     */
    get viewport() {
        if (this._engine) {
            const halfWidth = this._engine.halfDrawWidth;
            const halfHeight = this._engine.halfDrawHeight;
            return new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_5__["BoundingBox"](this.x - halfWidth, this.y - halfHeight, this.x + halfWidth, this.y + halfHeight);
        }
        return new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_5__["BoundingBox"](0, 0, 0, 0);
    }
    /**
     * Adds a new camera strategy to this camera
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    addStrategy(cameraStrategy) {
        this._cameraStrategies.push(cameraStrategy);
    }
    /**
     * Removes a camera strategy by reference
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    removeStrategy(cameraStrategy) {
        Object(_Util_Util__WEBPACK_IMPORTED_MODULE_2__["removeItemFromArray"])(cameraStrategy, this._cameraStrategies);
    }
    /**
     * Clears all camera strategies from the camera
     */
    clearAllStrategies() {
        this._cameraStrategies.length = 0;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_3__["PreUpdateEvent"](engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Overridable
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_3__["PostUpdateEvent"](engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Overridable
    }
    get isInitialized() {
        return this._isInitialized;
    }
    _initialize(_engine) {
        if (!this.isInitialized) {
            this.onInitialize(_engine);
            super.emit('initialize', new _Events__WEBPACK_IMPORTED_MODULE_3__["InitializeEvent"](_engine, this));
            this._isInitialized = true;
            this._engine = _engine;
        }
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onInitialize(_engine) {
        // Overridable
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    update(_engine, delta) {
        this._initialize(_engine);
        this._preupdate(_engine, delta);
        // Update placements based on linear algebra
        this.pos = this.pos.add(this.vel.scale(delta / 1000));
        this.z += (this.dz * delta) / 1000;
        this.vel = this.vel.add(this.acc.scale(delta / 1000));
        this.dz += (this.az * delta) / 1000;
        this.rotation += (this.angularVelocity * delta) / 1000;
        if (this._isZooming) {
            if (this._currentZoomTime < this._zoomDuration) {
                const zoomEasing = this._zoomEasing;
                const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);
                this.z = newZoom;
                this._currentZoomTime += delta;
            }
            else {
                this._isZooming = false;
                this.z = this._zoomEnd;
                this._currentZoomTime = 0;
                this._zoomResolve(true);
            }
        }
        if (this._cameraMoving) {
            if (this._currentLerpTime < this._lerpDuration) {
                const moveEasing = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_0__["EasingFunctions"].CreateVectorEasingFunction(this._easing);
                const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);
                this.pos = lerpPoint;
                this._currentLerpTime += delta;
            }
            else {
                this.pos = this._lerpEnd;
                const end = this._lerpEnd.clone();
                this._lerpStart = null;
                this._lerpEnd = null;
                this._currentLerpTime = 0;
                this._cameraMoving = false;
                // Order matters here, resolve should be last so any chain promises have a clean slate
                this._lerpResolve(end);
            }
        }
        if (this._isDoneShaking()) {
            this._isShaking = false;
            this._elapsedShakeTime = 0;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._xShake = 0;
            this._yShake = 0;
        }
        else {
            this._elapsedShakeTime += delta;
            this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;
            this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;
        }
        for (const s of this._cameraStrategies) {
            this.pos = s.action.call(s, s.target, this, _engine, delta);
        }
        this._postupdate(_engine, delta);
    }
    /**
     * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
     * @param ctx    Canvas context to apply transformations
     */
    draw(ctx) {
        const focus = this.getFocus();
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;
        const pixelRatio = this._engine ? this._engine.pixelRatio : window.devicePixelRatio;
        const zoom = this.getZoom();
        const newCanvasWidth = canvasWidth / zoom / pixelRatio;
        const newCanvasHeight = canvasHeight / zoom / pixelRatio;
        ctx.scale(zoom, zoom);
        ctx.translate(-focus.x + newCanvasWidth / 2 + this._xShake, -focus.y + newCanvasHeight / 2 + this._yShake);
    }
    /* istanbul ignore next */
    debugDraw(ctx) {
        const focus = this.getFocus();
        ctx.fillStyle = 'red';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(focus.x, focus.y, 15, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(focus.x, focus.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.setLineDash([5, 15]);
        ctx.lineWidth = 5;
        ctx.strokeStyle = 'white';
        ctx.strokeRect(this.viewport.left, this.viewport.top, this.viewport.width, this.viewport.height);
        ctx.closePath();
    }
    _isDoneShaking() {
        return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;
    }
}


/***/ }),

/***/ "./Class.ts":
/*!******************!*\
  !*** ./Class.ts ***!
  \******************/
/*! exports provided: Class */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Class", function() { return Class; });
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventDispatcher */ "./EventDispatcher.ts");

/**
 * Excalibur base class that provides basic functionality such as [[EventDispatcher]]
 * and extending abilities for vanilla Javascript projects
 */
class Class {
    constructor() {
        this.eventDispatcher = new _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"](this);
    }
    /**
     * Alias for `addEventListener`. You can listen for a variety of
     * events off of the engine; see the events section below for a complete list.
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    on(eventName, handler) {
        this.eventDispatcher.on(eventName, handler);
    }
    /**
     * Alias for `removeEventListener`. If only the eventName is specified
     * it will remove all handlers registered for that specific event. If the eventName
     * and the handler instance are specified only that handler will be removed.
     *
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    off(eventName, handler) {
        this.eventDispatcher.off(eventName, handler);
    }
    /**
     * Emits a new event
     * @param eventName   Name of the event to emit
     * @param eventObject Data associated with this event
     */
    emit(eventName, eventObject) {
        this.eventDispatcher.emit(eventName, eventObject);
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        this.eventDispatcher.once(eventName, handler);
    }
}


/***/ }),

/***/ "./Collision/Body.ts":
/*!***************************!*\
  !*** ./Collision/Body.ts ***!
  \***************************/
/*! exports provided: Body */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Body", function() { return Body; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Physics */ "./Physics.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Shape */ "./Collision/Shape.ts");





/**
 * Body describes all the physical properties pos, vel, acc, rotation, angular velocity
 */
class Body {
    /**
     * Constructs a new physics body associated with an actor
     */
    constructor({ actor, collider }) {
        /**
         * The position of the actor last frame (x, y) in pixels
         */
        this.oldPos = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0);
        /**
         * The current velocity vector (vx, vy) of the actor in pixels/second
         */
        this.vel = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0);
        /**
         * The velocity of the actor last frame (vx, vy) in pixels/second
         */
        this.oldVel = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0);
        /**
         * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
         * be useful to simulate a gravitational effect.
         */
        this.acc = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0);
        /**
         * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
         */
        this.oldAcc = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Zero;
        /**
         * The current torque applied to the actor
         */
        this.torque = 0;
        /**
         * The current "motion" of the actor, used to calculated sleep in the physics simulation
         */
        this.motion = 10;
        /**
         * Gets/sets the rotation of the body from the last frame.
         */
        this.oldRotation = 0; // radians
        /**
         * The scale vector of the actor
         * @obsolete ex.Body.scale will be removed in v0.25.0
         */
        this.scale = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].One;
        /**
         * The scale of the actor last frame
         * @obsolete ex.Body.scale will be removed in v0.25.0
         */
        this.oldScale = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].One;
        /**
         * The x scalar velocity of the actor in scale/second
         * @obsolete ex.Body.scale will be removed in v0.25.0
         */
        this.sx = 0; //scale/sec
        /**
         * The y scalar velocity of the actor in scale/second
         * @obsolete ex.Body.scale will be removed in v0.25.0
         */
        this.sy = 0; //scale/sec
        /**
         * The rotational velocity of the actor in radians/second
         */
        this.rx = 0; //radians/sec
        this._geometryDirty = false;
        this._totalMtv = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Zero;
        if (!actor && !collider) {
            throw new Error('An actor or collider are required to create a body');
        }
        this.actor = actor;
        if (!collider && actor) {
            this.collider = this.useBoxCollider(actor.width, actor.height, actor.anchor);
        }
        else {
            this.collider = collider;
        }
    }
    get id() {
        return this.actor ? this.actor.id : -1;
    }
    /**
     * Returns a clone of this body, not associated with any actor
     */
    clone() {
        return new Body({
            actor: null,
            collider: this.collider.clone()
        });
    }
    get active() {
        return this.actor ? !this.actor.isKilled() : false;
    }
    get center() {
        return this.pos;
    }
    // TODO allow multiple colliders for a single body
    set collider(collider) {
        if (collider) {
            this._collider = collider;
            this._collider.body = this;
            this._wireColliderEventsToActor();
        }
    }
    get collider() {
        return this._collider;
    }
    get transform() {
        return this.actor.components.transform;
    }
    /**
     * The (x, y) position of the actor this will be in the middle of the actor if the
     * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
     * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
     */
    get pos() {
        return this.transform.pos;
    }
    set pos(val) {
        this.transform.pos = val;
    }
    /**
     * The rotation of the actor in radians
     */
    get rotation() {
        return this.transform.rotation;
    }
    set rotation(val) {
        this.transform.rotation = val;
    }
    /**
     * Add minimum translation vectors accumulated during the current frame to resolve collisions.
     */
    addMtv(mtv) {
        this._totalMtv.addEqual(mtv);
    }
    /**
     * Applies the accumulated translation vectors to the actors position
     */
    applyMtv() {
        this.pos.addEqual(this._totalMtv);
        this._totalMtv.setTo(0, 0);
    }
    /**
     * Flags the shape dirty and must be recalculated in world space
     */
    markCollisionShapeDirty() {
        this._geometryDirty = true;
    }
    get isColliderShapeDirty() {
        return this._geometryDirty;
    }
    /**
     * Sets the old versions of pos, vel, acc, and scale.
     */
    captureOldTransform() {
        // Capture old values before integration step updates them
        this.oldVel.setTo(this.vel.x, this.vel.y);
        this.oldPos.setTo(this.pos.x, this.pos.y);
        this.oldAcc.setTo(this.acc.x, this.acc.y);
        this.oldScale.setTo(this.scale.x, this.scale.y);
        this.oldRotation = this.rotation;
    }
    /**
     * Perform euler integration at the specified time step
     */
    integrate(delta) {
        // Update placements based on linear algebra
        const seconds = delta / 1000;
        const totalAcc = this.acc.clone();
        // Only active vanilla actors are affected by global acceleration
        if (this.collider.type === _CollisionType__WEBPACK_IMPORTED_MODULE_1__["CollisionType"].Active) {
            totalAcc.addEqual(_Physics__WEBPACK_IMPORTED_MODULE_2__["Physics"].acc);
        }
        this.vel.addEqual(totalAcc.scale(seconds));
        this.pos.addEqual(this.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
        this.rx += this.torque * (1.0 / this.collider.inertia) * seconds;
        this.rotation += this.rx * seconds;
        this.scale.x += (this.sx * delta) / 1000;
        this.scale.y += (this.sy * delta) / 1000;
        if (!this.scale.equals(this.oldScale)) {
            // change in scale effects the geometry
            this._geometryDirty = true;
        }
        // Update colliders
        this.collider.update();
        this._geometryDirty = false;
    }
    /**
     * Sets up a box geometry based on the current bounds of the associated actor of this physics body.
     *
     * If no width/height are specified the body will attempt to use the associated actor's width/height.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useBoxCollider(width, height, anchor = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Half, center = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Zero) {
        if (width === null || width === undefined) {
            width = this.actor ? this.actor.width : 0;
        }
        if (height === null || height === undefined) {
            height = this.actor ? this.actor.height : 0;
        }
        this.collider.shape = _Shape__WEBPACK_IMPORTED_MODULE_4__["Shape"].Box(width, height, anchor, center);
        return this.collider;
    }
    /**
     * Sets up a [[ConvexPolygon|convex polygon]] collision geometry based on a list of of points relative
     *  to the anchor of the associated actor
     * of this physics body.
     *
     * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    usePolygonCollider(points, center = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Zero) {
        this.collider.shape = _Shape__WEBPACK_IMPORTED_MODULE_4__["Shape"].Polygon(points, false, center);
        return this.collider;
    }
    /**
     * Sets up a [[Circle|circle collision geometry]] with a specified radius in pixels.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useCircleCollider(radius, center = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Zero) {
        this.collider.shape = _Shape__WEBPACK_IMPORTED_MODULE_4__["Shape"].Circle(radius, center);
        return this.collider;
    }
    /**
     * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor
     * of this physics body.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useEdgeCollider(begin, end) {
        this.collider.shape = _Shape__WEBPACK_IMPORTED_MODULE_4__["Shape"].Edge(begin, end);
        return this.collider;
    }
    // TODO remove this, eventually events will stay local to the thing they are around
    _wireColliderEventsToActor() {
        this.collider.clear();
        this.collider.on('precollision', (evt) => {
            if (this.actor) {
                this.actor.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_3__["PreCollisionEvent"](evt.target.body.actor, evt.other.body.actor, evt.side, evt.intersection));
            }
        });
        this.collider.on('postcollision', (evt) => {
            if (this.actor) {
                this.actor.emit('postcollision', new _Events__WEBPACK_IMPORTED_MODULE_3__["PostCollisionEvent"](evt.target.body.actor, evt.other.body.actor, evt.side, evt.intersection));
            }
        });
        this.collider.on('collisionstart', (evt) => {
            if (this.actor) {
                this.actor.emit('collisionstart', new _Events__WEBPACK_IMPORTED_MODULE_3__["CollisionStartEvent"](evt.target.body.actor, evt.other.body.actor, evt.pair));
            }
        });
        this.collider.on('collisionend', (evt) => {
            if (this.actor) {
                this.actor.emit('collisionend', new _Events__WEBPACK_IMPORTED_MODULE_3__["CollisionEndEvent"](evt.target.body.actor, evt.other.body.actor));
            }
        });
    }
}


/***/ }),

/***/ "./Collision/BoundingBox.ts":
/*!**********************************!*\
  !*** ./Collision/BoundingBox.ts ***!
  \**********************************/
/*! exports provided: BoundingBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return BoundingBox; });
/* harmony import */ var _ConvexPolygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConvexPolygon */ "./Collision/ConvexPolygon.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Side__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Side */ "./Collision/Side.ts");




/**
 * Axis Aligned collision primitive for Excalibur.
 */
class BoundingBox {
    /**
     * Constructor allows passing of either an object with all coordinate components,
     * or the coordinate components passed separately.
     * @param leftOrOptions    Either x coordinate of the left edge or an options object
     * containing the four coordinate components.
     * @param top     y coordinate of the top edge
     * @param right   x coordinate of the right edge
     * @param bottom  y coordinate of the bottom edge
     */
    constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0) {
        if (typeof leftOrOptions === 'object') {
            this.left = leftOrOptions.left;
            this.top = leftOrOptions.top;
            this.right = leftOrOptions.right;
            this.bottom = leftOrOptions.bottom;
        }
        else if (typeof leftOrOptions === 'number') {
            this.left = leftOrOptions;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
    }
    /**
     * Given bounding box A & B, returns the side relative to A when intersection is performed.
     * @param intersection Intersection vector between 2 bounding boxes
     */
    static getSideFromIntersection(intersection) {
        if (!intersection) {
            return _Side__WEBPACK_IMPORTED_MODULE_3__["Side"].None;
        }
        if (intersection) {
            if (Math.abs(intersection.x) > Math.abs(intersection.y)) {
                if (intersection.x < 0) {
                    return _Side__WEBPACK_IMPORTED_MODULE_3__["Side"].Right;
                }
                return _Side__WEBPACK_IMPORTED_MODULE_3__["Side"].Left;
            }
            else {
                if (intersection.y < 0) {
                    return _Side__WEBPACK_IMPORTED_MODULE_3__["Side"].Bottom;
                }
                return _Side__WEBPACK_IMPORTED_MODULE_3__["Side"].Top;
            }
        }
        return _Side__WEBPACK_IMPORTED_MODULE_3__["Side"].None;
    }
    static fromPoints(points) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < points.length; i++) {
            if (points[i].x < minX) {
                minX = points[i].x;
            }
            if (points[i].x > maxX) {
                maxX = points[i].x;
            }
            if (points[i].y < minY) {
                minY = points[i].y;
            }
            if (points[i].y > maxY) {
                maxY = points[i].y;
            }
        }
        return new BoundingBox(minX, minY, maxX, maxY);
    }
    static fromDimension(width, height, anchor = _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].Half, pos = _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].Zero) {
        return new BoundingBox(-width * anchor.x + pos.x, -height * anchor.y + pos.y, width - width * anchor.x + pos.x, height - height * anchor.y + pos.y);
    }
    /**
     * Returns the calculated width of the bounding box
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * Returns the calculated height of the bounding box
     */
    get height() {
        return this.bottom - this.top;
    }
    /**
     * Returns the center of the bounding box
     */
    get center() {
        return new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"]((this.left + this.right) / 2, (this.top + this.bottom) / 2);
    }
    translate(pos) {
        return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);
    }
    /**
     * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding
     * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.
     */
    rotate(angle, point = _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].Zero) {
        const points = this.getPoints().map((p) => p.rotate(angle, point));
        return BoundingBox.fromPoints(points);
    }
    scale(scale, point = _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].Zero) {
        const shifted = this.translate(point);
        return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);
    }
    /**
     * Returns the perimeter of the bounding box
     */
    getPerimeter() {
        const wx = this.width;
        const wy = this.height;
        return 2 * (wx + wy);
    }
    getPoints() {
        const results = [];
        results.push(new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](this.left, this.top));
        results.push(new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](this.right, this.top));
        results.push(new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](this.right, this.bottom));
        results.push(new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](this.left, this.bottom));
        return results;
    }
    /**
     * Creates a Polygon collision area from the points of the bounding box
     */
    toPolygon(actor) {
        let maybeCollider = null;
        if (actor && actor.body && actor.body.collider) {
            maybeCollider = actor.body.collider;
        }
        return new _ConvexPolygon__WEBPACK_IMPORTED_MODULE_0__["ConvexPolygon"]({
            collider: maybeCollider,
            points: this.getPoints(),
            offset: _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].Zero
        });
    }
    /**
     * Determines whether a ray intersects with a bounding box
     */
    rayCast(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
    }
    rayCastTime(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
            return tmin;
        }
        return -1;
    }
    contains(val) {
        if (val instanceof _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"]) {
            return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;
        }
        else if (val instanceof BoundingBox) {
            if (this.left < val.left && this.top < val.top && val.bottom < this.bottom && val.right < this.right) {
                return true;
            }
            return false;
        }
        return false;
    }
    /**
     * Combines this bounding box and another together returning a new bounding box
     * @param other  The bounding box to combine
     */
    combine(other) {
        const compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
        return compositeBB;
    }
    get dimensions() {
        return new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](this.width, this.height);
    }
    /**
     * Test wether this bounding box intersects with another returning
     * the intersection vector that can be used to resolve the collision. If there
     * is no intersection null is returned.
     *
     * @param other  Other [[BoundingBox]] to test intersection with
     * @returns A Vector in the direction of the current BoundingBox, this <- other
     */
    intersect(other) {
        const totalBoundingBox = this.combine(other);
        // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision
        if (totalBoundingBox.width < other.width + this.width &&
            totalBoundingBox.height < other.height + this.height &&
            !totalBoundingBox.dimensions.equals(other.dimensions) &&
            !totalBoundingBox.dimensions.equals(this.dimensions)) {
            // collision
            let overlapX = 0;
            // right edge is between the other's left and right edge
            /**
             *     +-this-+
             *     |      |
             *     |    +-other-+
             *     +----|-+     |
             *          |       |
             *          +-------+
             *         <---
             *          ^ overlap
             */
            if (this.right >= other.left && this.right <= other.right) {
                overlapX = other.left - this.right;
                // right edge is past the other's right edge
                /**
                 *     +-other-+
                 *     |       |
                 *     |    +-this-+
                 *     +----|--+   |
                 *          |      |
                 *          +------+
                 *          --->
                 *          ^ overlap
                 */
            }
            else {
                overlapX = other.right - this.left;
            }
            let overlapY = 0;
            // top edge is between the other's top and bottom edge
            /**
             *     +-other-+
             *     |       |
             *     |    +-this-+   | <- overlap
             *     +----|--+   |   |
             *          |      |  \ /
             *          +------+   '
             */
            if (this.top <= other.bottom && this.top >= other.top) {
                overlapY = other.bottom - this.top;
                // top edge is above the other top edge
                /**
                 *     +-this-+         .
                 *     |      |        / \
                 *     |    +-other-+   | <- overlap
                 *     +----|-+     |   |
                 *          |       |
                 *          +-------+
                 */
            }
            else {
                overlapY = other.top - this.bottom;
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](overlapX, 0);
            }
            else {
                return new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, overlapY);
            }
            // Case of total containment of one bounding box by another
        }
        else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {
            let overlapX = 0;
            // this is wider than the other
            if (this.width - other.width >= 0) {
                // This right edge is closest to the others right edge
                if (this.right - other.right <= other.left - this.left) {
                    overlapX = other.left - this.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = other.right - this.left;
                }
                // other is wider than this
            }
            else {
                // This right edge is closest to the others right edge
                if (other.right - this.right <= this.left - other.left) {
                    overlapX = this.left - other.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = this.right - other.left;
                }
            }
            let overlapY = 0;
            // this is taller than other
            if (this.height - other.height >= 0) {
                // The bottom edge is closest to the others bottom edge
                if (this.bottom - other.bottom <= other.top - this.top) {
                    overlapY = other.top - this.bottom;
                }
                else {
                    overlapY = other.bottom - this.top;
                }
                // other is taller than this
            }
            else {
                // The bottom edge is closest to the others bottom edge
                if (other.bottom - this.bottom <= this.top - other.top) {
                    overlapY = this.top - other.bottom;
                }
                else {
                    overlapY = this.bottom - other.top;
                }
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](overlapX, 0);
            }
            else {
                return new _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, overlapY);
            }
        }
        else {
            return null;
        }
    }
    /**
     * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.
     * @param bb The other actor to test
     */
    intersectWithSide(bb) {
        const intersect = this.intersect(bb);
        return BoundingBox.getSideFromIntersection(intersect);
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].Yellow) {
        ctx.strokeStyle = color.toString();
        ctx.strokeRect(this.left, this.top, this.width, this.height);
    }
}


/***/ }),

/***/ "./Collision/Circle.ts":
/*!*****************************!*\
  !*** ./Collision/Circle.ts ***!
  \*****************************/
/*! exports provided: Circle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CollisionJumpTable */ "./Collision/CollisionJumpTable.ts");
/* harmony import */ var _ConvexPolygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ConvexPolygon */ "./Collision/ConvexPolygon.ts");
/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Edge */ "./Collision/Edge.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Physics */ "./Physics.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ClosestLineJumpTable */ "./Collision/ClosestLineJumpTable.ts");








/**
 * This is a circle collision shape for the excalibur rigid body physics simulation
 */
class Circle {
    constructor(options) {
        /**
         * Position of the circle relative to the collider, by default (0, 0) meaning the shape is positioned on top of the collider.
         */
        this.offset = _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero;
        this.offset = options.offset || _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero;
        this.radius = options.radius || 0;
        this.collider = options.collider || null;
    }
    get worldPos() {
        if (this.collider && this.collider.body) {
            return this.collider.body.pos.add(this.offset);
        }
        return this.offset;
    }
    /**
     * Returns a clone of this shape, not associated with any collider
     */
    clone() {
        return new Circle({
            offset: this.offset.clone(),
            radius: this.radius,
            collider: null
        });
    }
    /**
     * Get the center of the collision shape in world coordinates
     */
    get center() {
        if (this.collider && this.collider.body) {
            return this.offset.add(this.collider.body.pos);
        }
        return this.offset;
    }
    /**
     * Tests if a point is contained in this collision shape
     */
    contains(point) {
        let pos = this.offset;
        if (this.collider && this.collider.body) {
            pos = this.collider.body.pos;
        }
        const distance = pos.distance(point);
        if (distance <= this.radius) {
            return true;
        }
        return false;
    }
    /**
     * Casts a ray at the Circle shape and returns the nearest point of collision
     * @param ray
     */
    rayCast(ray, max = Infinity) {
        //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
        const c = this.center;
        const dir = ray.dir;
        const orig = ray.pos;
        const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));
        if (discriminant < 0) {
            // no intersection
            return null;
        }
        else {
            let toi = 0;
            if (discriminant === 0) {
                toi = -dir.dot(orig.sub(c));
                if (toi > 0 && toi < max) {
                    return ray.getPoint(toi);
                }
                return null;
            }
            else {
                const toi1 = -dir.dot(orig.sub(c)) + discriminant;
                const toi2 = -dir.dot(orig.sub(c)) - discriminant;
                const positiveToi = [];
                if (toi1 >= 0) {
                    positiveToi.push(toi1);
                }
                if (toi2 >= 0) {
                    positiveToi.push(toi2);
                }
                const mintoi = Math.min(...positiveToi);
                if (mintoi <= max) {
                    return ray.getPoint(mintoi);
                }
                return null;
            }
        }
    }
    getClosestLineBetween(shape) {
        if (shape instanceof Circle) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__["ClosestLineJumpTable"].CircleCircleClosestLine(this, shape);
        }
        else if (shape instanceof _ConvexPolygon__WEBPACK_IMPORTED_MODULE_2__["ConvexPolygon"]) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__["ClosestLineJumpTable"].PolygonCircleClosestLine(shape, this).flip();
        }
        else if (shape instanceof _Edge__WEBPACK_IMPORTED_MODULE_3__["Edge"]) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__["ClosestLineJumpTable"].CircleEdgeClosestLine(this, shape).flip();
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(shape) {
        if (shape instanceof Circle) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_1__["CollisionJumpTable"].CollideCircleCircle(this, shape);
        }
        else if (shape instanceof _ConvexPolygon__WEBPACK_IMPORTED_MODULE_2__["ConvexPolygon"]) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_1__["CollisionJumpTable"].CollideCirclePolygon(this, shape);
        }
        else if (shape instanceof _Edge__WEBPACK_IMPORTED_MODULE_3__["Edge"]) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_1__["CollisionJumpTable"].CollideCircleEdge(this, shape);
        }
        else {
            throw new Error(`Circle could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * Find the point on the shape furthest in the direction specified
     */
    getFurthestPoint(direction) {
        return this.center.add(direction.normalize().scale(this.radius));
    }
    /**
     * Get the axis aligned bounding box for the circle shape in world coordinates
     */
    get bounds() {
        let bodyPos = _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero;
        if (this.collider && this.collider.body) {
            bodyPos = this.collider.body.pos;
        }
        return new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__["BoundingBox"](this.offset.x + bodyPos.x - this.radius, this.offset.y + bodyPos.y - this.radius, this.offset.x + bodyPos.x + this.radius, this.offset.y + bodyPos.y + this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle shape in local coordinates
     */
    get localBounds() {
        return new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__["BoundingBox"](this.offset.x - this.radius, this.offset.y - this.radius, this.offset.x + this.radius, this.offset.y + this.radius);
    }
    /**
     * Get axis not implemented on circles, since there are infinite axis in a circle
     */
    get axes() {
        return null;
    }
    /**
     * Returns the moment of inertia of a circle given it's mass
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    get inertia() {
        const mass = this.collider ? this.collider.mass : _Physics__WEBPACK_IMPORTED_MODULE_5__["Physics"].defaultMass;
        return (mass * this.radius * this.radius) / 2;
    }
    /**
     * Tests the separating axis theorem for circles against polygons
     */
    testSeparatingAxisTheorem(polygon) {
        const axes = polygon.axes;
        const pc = polygon.center;
        // Special SAT with circles
        const closestPointOnPoly = polygon.getFurthestPoint(this.offset.sub(pc));
        axes.push(this.offset.sub(closestPointOnPoly).normalize());
        let minOverlap = Number.MAX_VALUE;
        let minAxis = null;
        let minIndex = -1;
        for (let i = 0; i < axes.length; i++) {
            const proj1 = polygon.project(axes[i]);
            const proj2 = this.project(axes[i]);
            const overlap = proj1.getOverlap(proj2);
            if (overlap <= 0) {
                return null;
            }
            else {
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    minAxis = axes[i];
                    minIndex = i;
                }
            }
        }
        if (minIndex < 0) {
            return null;
        }
        return minAxis.normalize().scale(minOverlap);
    }
    /* istanbul ignore next */
    recalc() {
        // circles don't cache
    }
    /**
     * Project the circle along a specified axis
     */
    project(axis) {
        const scalars = [];
        const point = this.center;
        const dotProduct = point.dot(axis);
        scalars.push(dotProduct);
        scalars.push(dotProduct + this.radius);
        scalars.push(dotProduct - this.radius);
        return new _Algebra__WEBPACK_IMPORTED_MODULE_4__["Projection"](Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    draw(ctx, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_6__["Color"].Green, pos = _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero) {
        const newPos = pos.add(this.offset);
        ctx.beginPath();
        ctx.fillStyle = color.toString();
        ctx.arc(newPos.x, newPos.y, this.radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_6__["Color"].Green) {
        const body = this.collider.body;
        const pos = body ? body.pos.add(this.offset) : this.offset;
        const rotation = body ? body.rotation : 0;
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(Math.cos(rotation) * this.radius + pos.x, Math.sin(rotation) * this.radius + pos.y);
        ctx.closePath();
        ctx.stroke();
    }
}


/***/ }),

/***/ "./Collision/ClosestLineJumpTable.ts":
/*!*******************************************!*\
  !*** ./Collision/ClosestLineJumpTable.ts ***!
  \*******************************************/
/*! exports provided: ClosestLine, ClosestLineJumpTable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClosestLine", function() { return ClosestLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClosestLineJumpTable", function() { return ClosestLineJumpTable; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");

/**
 * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment
 * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
 * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
 * @param p0 Point where L1 begins
 * @param u Direction and length of L1
 * @param q0 Point were L2 begins
 * @param v Direction and length of L2
 */
function ClosestLine(p0, u, q0, v) {
    // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html
    // w(s, t) = P(s) - Q(t)
    // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest
    //
    // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.
    // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0
    //
    // The closest point between 2 lines then satisfies this pair of equations
    // 1: u * wClosest = 0
    // 2: v * wClosest = 0
    //
    // Substituting wClosest into the equations we get
    //
    // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0
    // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0
    // simplify w0
    const w0 = p0.sub(q0);
    // simplify (u * u);
    const a = u.dot(u);
    // simplify (u * v);
    const b = u.dot(v);
    // simplify (v * v)
    const c = v.dot(v);
    // simplify (u * w0)
    const d = u.dot(w0);
    // simplify (v * w0)
    const e = v.dot(w0);
    // denominator ac - b^2
    const denom = a * c - b * b;
    let sDenom = denom;
    let tDenom = denom;
    // if denom is 0 they are parallel, use any point from either as the start in this case p0
    if (denom === 0 || denom <= 0.01) {
        const tClosestParallel = d / b;
        return new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Line"](p0, q0.add(v.scale(tClosestParallel)));
    }
    // Solve for sClosest for infinite line
    let sClosest = b * e - c * d; // / denom;
    // Solve for tClosest for infinite line
    let tClosest = a * e - b * d; // / denom;
    // Solve for segments candidate edges, if sClosest and tClosest are outside their segments
    if (sClosest < 0) {
        sClosest = 0;
        tClosest = e;
        tDenom = c;
    }
    else if (sClosest > sDenom) {
        sClosest = sDenom;
        tClosest = e + b;
        tDenom = c;
    }
    if (tClosest < 0) {
        tClosest = 0;
        if (-d < 0) {
            sClosest = 0;
        }
        else if (-d > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d;
            sDenom = a;
        }
    }
    else if (tClosest > tDenom) {
        tClosest = tDenom;
        if (-d + b < 0) {
            sClosest = 0;
        }
        else if (-d + b > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d + b;
            sDenom = a;
        }
    }
    sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;
    tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;
    return new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Line"](p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));
}
const ClosestLineJumpTable = {
    PolygonPolygonClosestLine(polygonA, polygonB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = polygonB.worldPos;
        const otherDirection = otherWorldPos.sub(polygonA.worldPos);
        const thisDirection = otherDirection.negate();
        const rayTowardsOther = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Ray"](polygonA.worldPos, otherDirection);
        const rayTowardsThis = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Ray"](otherWorldPos, thisDirection);
        const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));
        const thisFace = polygonA.getClosestFace(thisPoint);
        const otherFace = polygonB.getClosestFace(otherPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const q0 = otherFace.face.begin;
        const v = otherFace.face.getEdge();
        return ClosestLine(p0, u, q0, v);
    },
    PolygonEdgeClosestLine(polygon, edge) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = edge.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Ray"](polygon.worldPos, otherDirection);
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const q0 = edgeStart;
        const v = edgeVector;
        return ClosestLine(p0, u, q0, v);
    },
    PolygonCircleClosestLine(polygon, circle) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circle.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Ray"](polygon.worldPos, otherDirection.normalize());
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // Time of minimum distance
        let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);
        return new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Line"](u.scale(t).add(p0), new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](otherWorldPos.x + circlex, otherWorldPos.y + circley));
    },
    CircleCircleClosestLine(circleA, circleB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circleB.worldPos;
        const otherDirection = otherWorldPos.sub(circleA.worldPos);
        const thisWorldPos = circleA.worldPos;
        const thisDirection = thisWorldPos.sub(circleB.worldPos);
        const rayTowardsOther = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Ray"](circleA.worldPos, otherDirection);
        const rayTowardsThis = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Ray"](circleB.worldPos, thisDirection);
        const thisPoint = circleA.rayCast(rayTowardsOther);
        const otherPoint = circleB.rayCast(rayTowardsThis);
        return new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Line"](thisPoint, otherPoint);
    },
    CircleEdgeClosestLine(circle, edge) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        const circleWorlPos = circle.worldPos;
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const p0 = edgeStart;
        const u = edgeVector;
        // Time of minimum distance
        let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp to edge
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);
        return new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Line"](u.scale(t).add(p0), new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](circleWorlPos.x + circlex, circleWorlPos.y + circley));
    },
    EdgeEdgeClosestLine(edgeA, edgeB) {
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLineA = edgeA.asLine();
        const edgeStartA = edgeLineA.begin;
        const edgeVectorA = edgeLineA.getEdge();
        const p0 = edgeStartA;
        const u = edgeVectorA;
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLineB = edgeB.asLine();
        const edgeStartB = edgeLineB.begin;
        const edgeVectorB = edgeLineB.getEdge();
        const q0 = edgeStartB;
        const v = edgeVectorB;
        return ClosestLine(p0, u, q0, v);
    }
};


/***/ }),

/***/ "./Collision/Collider.ts":
/*!*******************************!*\
  !*** ./Collision/Collider.ts ***!
  \*******************************/
/*! exports provided: isCollider, Collider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCollider", function() { return isCollider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Collider", function() { return Collider; });
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util/DrawUtil */ "./Util/DrawUtil.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Physics */ "./Physics.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _CollisionGroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CollisionGroup */ "./Collision/CollisionGroup.ts");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../EventDispatcher */ "./EventDispatcher.ts");
/* harmony import */ var _Pair__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Pair */ "./Collision/Pair.ts");









/**
 * Type guard function to determine whether something is a Collider
 */
function isCollider(x) {
    return x instanceof Collider;
}
/**
 * Collider describes material properties like shape,
 * bounds, friction of the physics object. Only **one** collider can be associated with a body at a time
 */
class Collider {
    constructor({ body, type, group, shape, offset, useShapeInertia = true }) {
        this._events = new _EventDispatcher__WEBPACK_IMPORTED_MODULE_7__["EventDispatcher"](this);
        /**
         * Gets or sets the current collision type of this collider. By
         * default it is ([[CollisionType.PreventCollision]]).
         */
        this.type = _CollisionType__WEBPACK_IMPORTED_MODULE_5__["CollisionType"].PreventCollision;
        /**
         * Gets or sets the current [[CollisionGroup|collision group]] for the collider, colliders with like collision groups do not collide.
         * By default, the collider will collide with [[CollisionGroup|all groups]].
         */
        this.group = _CollisionGroup__WEBPACK_IMPORTED_MODULE_6__["CollisionGroup"].All;
        /**
         * The current mass of the actor, mass can be thought of as the resistance to acceleration.
         */
        this.mass = 1.0;
        /**
         * The current moment of inertia, moment of inertia can be thought of as the resistance to rotation.
         */
        this.inertia = 1000;
        /**
         * The coefficient of friction on this actor
         */
        this.friction = 0.99;
        /**
         * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the
         * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.
         */
        this.bounciness = 0.2;
        // If shape is not supplied see if the body has an existing collider with a shape
        if (body && body.collider && !shape) {
            this._shape = body.collider.shape;
        }
        else {
            this._shape = shape;
            this.body = body;
        }
        this.useShapeInertia = useShapeInertia;
        this._shape.collider = this;
        this.type = type || this.type;
        this.group = group || this.group;
        this.offset = offset || _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"].Zero;
    }
    /**
     * Returns a clone of the current collider, not associated with any body
     */
    clone() {
        return new Collider({
            body: null,
            type: this.type,
            shape: this._shape.clone(),
            group: this.group,
            offset: this.offset
        });
    }
    /**
     * Get the unique id of the collider
     */
    get id() {
        return this.body ? this.body.id : -1;
    }
    /*
     * Get the shape of the collider as a [[CollisionShape]]
     */
    get shape() {
        return this._shape;
    }
    /**
     * Set the shape of the collider as a [[CollisionShape]], if useShapeInertia is set the collider will use inertia from the shape.
     */
    set shape(shape) {
        this._shape = shape;
        this._shape.collider = this;
        if (this.useShapeInertia) {
            this.inertia = isNaN(this._shape.inertia) ? this.inertia : this._shape.inertia;
        }
    }
    /**
     * The center of the collider in world space
     */
    get center() {
        return this.bounds.center;
    }
    /**
     * Is this collider active, if false it wont collide
     */
    get active() {
        return this.body.active;
    }
    /**
     * Collide 2 colliders and product a collision contact if there is a collision, null if none
     *
     * Collision vector is in the direction of the other collider. Away from this collider, this -> other.
     * @param other
     */
    collide(other) {
        return this.shape.collide(other.shape);
    }
    /**
     * Find the closest line between 2 colliders
     *
     * Line is in the direction of the other collider. Away from this collider, this -> other.
     * @param other Other collider
     */
    getClosestLineBetween(other) {
        return this.shape.getClosestLineBetween(other.shape);
    }
    /**
     * Gets the current pixel offset of the collider
     */
    get offset() {
        return this.shape.offset.clone();
    }
    /**
     * Sets the pixel offset of the collider
     */
    set offset(offset) {
        this.shape.offset = offset.clone();
    }
    /**
     * Returns a boolean indicating whether this body collided with
     * or was in stationary contact with
     * the body of the other [[Collider]]
     */
    touching(other) {
        const pair = new _Pair__WEBPACK_IMPORTED_MODULE_8__["Pair"](this, other);
        pair.collide();
        if (pair.collision) {
            return true;
        }
        return false;
    }
    /**
     * Returns the collider's [[BoundingBox]] calculated for this instant in world space.
     * If there is no shape, a point bounding box is returned
     */
    get bounds() {
        if (this.shape) {
            return this.shape.bounds;
        }
        if (this.body) {
            return new _BoundingBox__WEBPACK_IMPORTED_MODULE_4__["BoundingBox"]().translate(this.body.pos);
        }
        return new _BoundingBox__WEBPACK_IMPORTED_MODULE_4__["BoundingBox"]();
    }
    /**
     * Returns the collider's [[BoundingBox]] relative to the body's position.
     * If there is no shape, a point bounding box is returned
     */
    get localBounds() {
        if (this.shape) {
            return this.shape.localBounds;
        }
        return new _BoundingBox__WEBPACK_IMPORTED_MODULE_4__["BoundingBox"]();
    }
    /**
     * Updates the collision shapes geometry and internal caches if needed
     */
    update() {
        if (this.shape) {
            this.shape.recalc();
        }
    }
    emit(eventName, event) {
        this._events.emit(eventName, event);
    }
    on(eventName, handler) {
        this._events.on(eventName, handler);
    }
    off(eventName, handler) {
        this._events.off(eventName, handler);
    }
    once(eventName, handler) {
        this._events.once(eventName, handler);
    }
    clear() {
        this._events.clear();
    }
    /* istanbul ignore next */
    debugDraw(ctx) {
        // Draw motion vectors
        if (_Physics__WEBPACK_IMPORTED_MODULE_3__["Physics"].showMotionVectors) {
            _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_1__["vector"](ctx, _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Yellow, this.body.pos, this.body.acc.add(_Physics__WEBPACK_IMPORTED_MODULE_3__["Physics"].acc));
            _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_1__["vector"](ctx, _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Red, this.body.pos, this.body.vel);
            _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_1__["point"](ctx, _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Red, this.body.pos);
        }
        if (_Physics__WEBPACK_IMPORTED_MODULE_3__["Physics"].showBounds) {
            this.bounds.debugDraw(ctx, _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Yellow);
        }
        if (_Physics__WEBPACK_IMPORTED_MODULE_3__["Physics"].showArea) {
            this.shape.debugDraw(ctx, _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Green);
        }
    }
}


/***/ }),

/***/ "./Collision/CollisionContact.ts":
/*!***************************************!*\
  !*** ./Collision/CollisionContact.ts ***!
  \***************************************/
/*! exports provided: CollisionContact */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollisionContact", function() { return CollisionContact; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Physics */ "./Physics.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Util/Util */ "./Util/Util.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CollisionType */ "./Collision/CollisionType.ts");





/**
 * Collision contacts are used internally by Excalibur to resolve collision between colliders. This
 * Pair prevents collisions from being evaluated more than one time
 */
class CollisionContact {
    constructor(colliderA, colliderB, mtv, point, normal) {
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.mtv = mtv;
        this.point = point;
        this.normal = normal;
    }
    resolve(strategy) {
        if (strategy === _Physics__WEBPACK_IMPORTED_MODULE_1__["CollisionResolutionStrategy"].RigidBody) {
            this._resolveRigidBodyCollision();
        }
        else if (strategy === _Physics__WEBPACK_IMPORTED_MODULE_1__["CollisionResolutionStrategy"].Box) {
            this._resolveBoxCollision();
        }
        else {
            throw new Error('Unknown collision resolution strategy');
        }
    }
    _applyBoxImpulse(colliderA, colliderB, mtv) {
        if (colliderA.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Active && colliderB.type !== _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Passive) {
            // Resolve overlaps
            if (colliderA.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Active && colliderB.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Active) {
                // split overlaps if both are Active
                mtv = mtv.scale(0.5);
            }
            // Apply mtv
            colliderA.body.pos.y += mtv.y;
            colliderA.body.pos.x += mtv.x;
            const mtvDir = mtv.normalize();
            // only adjust if velocity is opposite
            if (mtvDir.dot(colliderA.body.vel) < 0) {
                // Cancel out velocity in direction of mtv
                const velAdj = mtvDir.scale(mtvDir.dot(colliderA.body.vel.negate()));
                colliderA.body.vel = colliderA.body.vel.add(velAdj);
            }
            colliderA.emit('postcollision', new _Events__WEBPACK_IMPORTED_MODULE_2__["PostCollisionEvent"](colliderA, colliderB, _Util_Util__WEBPACK_IMPORTED_MODULE_3__["getSideFromDirection"](mtv), mtv));
        }
    }
    _resolveBoxCollision() {
        const side = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["getSideFromDirection"](this.mtv);
        const mtv = this.mtv.negate();
        // Publish collision events on both participants
        this.colliderA.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_2__["PreCollisionEvent"](this.colliderA, this.colliderB, side, mtv));
        this.colliderB.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_2__["PreCollisionEvent"](this.colliderB, this.colliderA, _Util_Util__WEBPACK_IMPORTED_MODULE_3__["getOppositeSide"](side), mtv.negate()));
        this._applyBoxImpulse(this.colliderA, this.colliderB, mtv);
        this._applyBoxImpulse(this.colliderB, this.colliderA, mtv.negate());
    }
    _resolveRigidBodyCollision() {
        // perform collision on bounding areas
        const bodyA = this.colliderA.body;
        const bodyB = this.colliderB.body;
        const mtv = this.mtv; // normal pointing away from colliderA
        let normal = this.normal; // normal pointing away from colliderA
        if (bodyA === bodyB) {
            // sanity check for existing pairs
            return;
        }
        // Publish collision events on both participants
        const side = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["getSideFromDirection"](this.mtv);
        this.colliderA.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_2__["PreCollisionEvent"](this.colliderA, this.colliderB, side, this.mtv));
        this.colliderB.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_2__["PreCollisionEvent"](this.colliderB, this.colliderA, _Util_Util__WEBPACK_IMPORTED_MODULE_3__["getOppositeSide"](side), this.mtv.negate()));
        // If any of the participants are passive then short circuit
        if (this.colliderA.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Passive || this.colliderB.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Passive) {
            return;
        }
        const invMassA = this.colliderA.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Fixed ? 0 : 1 / this.colliderA.mass;
        const invMassB = this.colliderB.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Fixed ? 0 : 1 / this.colliderB.mass;
        const invMoiA = this.colliderA.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Fixed ? 0 : 1 / this.colliderA.inertia;
        const invMoiB = this.colliderB.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Fixed ? 0 : 1 / this.colliderB.inertia;
        // average restitution more realistic
        const coefRestitution = Math.min(this.colliderA.bounciness, this.colliderB.bounciness);
        const coefFriction = Math.min(this.colliderA.friction, this.colliderB.friction);
        normal = normal.normalize();
        const tangent = normal.normal().normalize();
        const ra = this.point.sub(this.colliderA.center); // point relative to colliderA position
        const rb = this.point.sub(this.colliderB.center); /// point relative to colliderB
        // Relative velocity in linear terms
        // Angular to linear velocity formula -> omega = v/r
        const rv = bodyB.vel.add(rb.cross(-bodyB.rx)).sub(bodyA.vel.sub(ra.cross(bodyA.rx)));
        const rvNormal = rv.dot(normal);
        const rvTangent = rv.dot(tangent);
        const raTangent = ra.dot(tangent);
        const raNormal = ra.dot(normal);
        const rbTangent = rb.dot(tangent);
        const rbNormal = rb.dot(normal);
        // If objects are moving away ignore
        if (rvNormal > 0) {
            return;
        }
        // Collision impulse formula from Chris Hecker
        // https://en.wikipedia.org/wiki/Collision_response
        const impulse = -((1 + coefRestitution) * rvNormal) / (invMassA + invMassB + invMoiA * raTangent * raTangent + invMoiB * rbTangent * rbTangent);
        if (this.colliderA.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Fixed) {
            bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));
            if (_Physics__WEBPACK_IMPORTED_MODULE_1__["Physics"].allowRigidBodyRotation) {
                bodyB.rx -= impulse * invMoiB * -rb.cross(normal);
            }
            bodyB.addMtv(mtv);
        }
        else if (this.colliderB.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Fixed) {
            bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));
            if (_Physics__WEBPACK_IMPORTED_MODULE_1__["Physics"].allowRigidBodyRotation) {
                bodyA.rx += impulse * invMoiA * -ra.cross(normal);
            }
            bodyA.addMtv(mtv.negate());
        }
        else {
            bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));
            bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));
            if (_Physics__WEBPACK_IMPORTED_MODULE_1__["Physics"].allowRigidBodyRotation) {
                bodyB.rx -= impulse * invMoiB * -rb.cross(normal);
                bodyA.rx += impulse * invMoiA * -ra.cross(normal);
            }
            // Split the mtv in half for the two bodies, potentially we could do something smarter here
            bodyB.addMtv(mtv.scale(0.5));
            bodyA.addMtv(mtv.scale(-0.5));
        }
        // Friction portion of impulse
        if (coefFriction && rvTangent) {
            // Columb model of friction, formula for impulse due to friction from
            // https://en.wikipedia.org/wiki/Collision_response
            // tangent force exerted by body on another in contact
            const t = rv.sub(normal.scale(rv.dot(normal))).normalize();
            // impulse in the direction of tangent force
            const jt = rv.dot(t) / (invMassA + invMassB + raNormal * raNormal * invMoiA + rbNormal * rbNormal * invMoiB);
            let frictionImpulse = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0);
            if (Math.abs(jt) <= impulse * coefFriction) {
                frictionImpulse = t.scale(jt).negate();
            }
            else {
                frictionImpulse = t.scale(-impulse * coefFriction);
            }
            if (this.colliderA.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Fixed) {
                // apply frictional impulse
                bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));
                if (_Physics__WEBPACK_IMPORTED_MODULE_1__["Physics"].allowRigidBodyRotation) {
                    bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);
                }
            }
            else if (this.colliderB.type === _CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].Fixed) {
                // apply frictional impulse
                bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));
                if (_Physics__WEBPACK_IMPORTED_MODULE_1__["Physics"].allowRigidBodyRotation) {
                    bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);
                }
            }
            else {
                // apply frictional impulse
                bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));
                bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));
                // apply frictional impulse
                if (_Physics__WEBPACK_IMPORTED_MODULE_1__["Physics"].allowRigidBodyRotation) {
                    bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);
                    bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);
                }
            }
        }
        this.colliderA.emit('postcollision', new _Events__WEBPACK_IMPORTED_MODULE_2__["PostCollisionEvent"](this.colliderA, this.colliderB, side, this.mtv));
        this.colliderB.emit('postcollision', new _Events__WEBPACK_IMPORTED_MODULE_2__["PostCollisionEvent"](this.colliderB, this.colliderA, _Util_Util__WEBPACK_IMPORTED_MODULE_3__["getOppositeSide"](side), this.mtv.negate()));
    }
}


/***/ }),

/***/ "./Collision/CollisionGroup.ts":
/*!*************************************!*\
  !*** ./Collision/CollisionGroup.ts ***!
  \*************************************/
/*! exports provided: CollisionGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollisionGroup", function() { return CollisionGroup; });
/**
 * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s
 *
 * For example:
 *
 * Players have collision group "player"
 *
 * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)
 *
 * Enemies have collision group "enemy"
 *
 * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)
 *
 * Blocks have collision group "ground"
 *
 * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)
 *
 * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide
 * with players and blocks.
 *
 * This is done with bitmasking, see the following pseudo-code
 *
 * PlayerGroup = `0b001`
 * PlayerGroupMask = `0b110`
 *
 * EnemyGroup = `0b010`
 * EnemyGroupMask = `0b101`
 *
 * BlockGroup = `0b100`
 * BlockGroupMask = `0b011`
 *
 * Should Players collide? No because the bitwise mask evaluates to 0
 * `(player1.group & player2.mask) === 0`
 * `(0b001 & 0b110) === 0`
 *
 * Should Players and Enemies collide? Yes because the bitwise mask is non-zero
 * `(player1.group & enemy1.mask) === 1`
 * `(0b001 & 0b101) === 1`
 *
 * Should Players and Blocks collide? Yes because the bitwise mask is non-zero
 * `(player1.group & blocks1.mask) === 1`
 * `(0b001 & 0b011) === 1`
 */
class CollisionGroup {
    /**
     * **STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups
     *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.
     * @param name Name of the collision group
     * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`
     * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`
     */
    constructor(name, category, mask) {
        this._name = name;
        this._category = category;
        this._mask = mask;
    }
    /**
     * Get the name of the collision group
     */
    get name() {
        return this._name;
    }
    /**
     * Get the category of the collision group, a 32 bit number which should be a unique power of 2
     */
    get category() {
        return this._category;
    }
    /**
     * Get the mask for this collision group
     */
    get mask() {
        return this._mask;
    }
    /**
     * Evaluates whether 2 collision groups can collide
     * @param other  CollisionGroup
     */
    canCollide(other) {
        return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;
    }
}
/**
 * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,
 * it is the default collision group on colliders.
 */
CollisionGroup.All = new CollisionGroup('Collide with all groups', -1, -1);


/***/ }),

/***/ "./Collision/CollisionGroupManager.ts":
/*!********************************************!*\
  !*** ./Collision/CollisionGroupManager.ts ***!
  \********************************************/
/*! exports provided: CollisionGroupManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollisionGroupManager", function() { return CollisionGroupManager; });
/* harmony import */ var _CollisionGroup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CollisionGroup */ "./Collision/CollisionGroup.ts");

/**
 * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur
 */
class CollisionGroupManager {
    /**
     * Create a new named collision group up to a max of 32.
     * @param name Name for the collision group
     * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one
     */
    static create(name, mask) {
        if (this._CURRENT_GROUP > this._MAX_GROUPS) {
            throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);
        }
        if (this._GROUPS.get(name)) {
            throw new Error(`Collision group ${name} already exists`);
        }
        const group = new _CollisionGroup__WEBPACK_IMPORTED_MODULE_0__["CollisionGroup"](name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);
        this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;
        this._CURRENT_GROUP++;
        this._GROUPS.set(name, group);
        return group;
    }
    /**
     * Get all collision groups currently tracked by excalibur
     */
    static get groups() {
        return Array.from(this._GROUPS.values());
    }
    /**
     * Get a collision group by it's name
     * @param name
     */
    static groupByName(name) {
        return this._GROUPS.get(name);
    }
    /**
     * Resets the managers internal group management state
     */
    static reset() {
        this._GROUPS = new Map();
        this._CURRENT_BIT = this._STARTING_BIT;
        this._CURRENT_GROUP = 1;
    }
}
// using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.
CollisionGroupManager._STARTING_BIT = 0b1 | 0;
CollisionGroupManager._MAX_GROUPS = 32;
CollisionGroupManager._CURRENT_GROUP = 1;
CollisionGroupManager._CURRENT_BIT = CollisionGroupManager._STARTING_BIT;
CollisionGroupManager._GROUPS = new Map();


/***/ }),

/***/ "./Collision/CollisionJumpTable.ts":
/*!*****************************************!*\
  !*** ./Collision/CollisionJumpTable.ts ***!
  \*****************************************/
/*! exports provided: CollisionJumpTable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollisionJumpTable", function() { return CollisionJumpTable; });
/* harmony import */ var _CollisionContact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CollisionContact */ "./Collision/CollisionContact.ts");
/* harmony import */ var _ConvexPolygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConvexPolygon */ "./Collision/ConvexPolygon.ts");


const CollisionJumpTable = {
    CollideCircleCircle(circleA, circleB) {
        const radius = circleA.radius + circleB.radius;
        const circleAPos = circleA.worldPos;
        const circleBPos = circleB.worldPos;
        if (circleAPos.distance(circleBPos) > radius) {
            return null;
        }
        const axisOfCollision = circleBPos.sub(circleAPos).normalize();
        const mvt = axisOfCollision.scale(radius - circleBPos.distance(circleAPos));
        const pointOfCollision = circleA.getFurthestPoint(axisOfCollision);
        return new _CollisionContact__WEBPACK_IMPORTED_MODULE_0__["CollisionContact"](circleA.collider, circleB.collider, mvt, pointOfCollision, axisOfCollision);
    },
    CollideCirclePolygon(circle, polygon) {
        let minAxis = circle.testSeparatingAxisTheorem(polygon);
        if (!minAxis) {
            return null;
        }
        // make sure that the minAxis is pointing away from circle
        const samedir = minAxis.dot(polygon.center.sub(circle.center));
        minAxis = samedir < 0 ? minAxis.negate() : minAxis;
        const verts = [];
        const point1 = polygon.getFurthestPoint(minAxis.negate());
        const point2 = circle.getFurthestPoint(minAxis); //.add(cc);
        if (circle.contains(point1)) {
            verts.push(point1);
        }
        if (polygon.contains(point2)) {
            verts.push(point2);
        }
        if (verts.length === 0) {
            return null;
        }
        return new _CollisionContact__WEBPACK_IMPORTED_MODULE_0__["CollisionContact"](circle.collider, polygon.collider, minAxis, verts.length === 2 ? verts[0].average(verts[1]) : verts[0], minAxis.normalize());
    },
    CollideCircleEdge(circle, edge) {
        // center of the circle
        const cc = circle.center;
        // vector in the direction of the edge
        const e = edge.end.sub(edge.begin);
        // amount of overlap with the circle's center along the edge direction
        const u = e.dot(edge.end.sub(cc));
        const v = e.dot(cc.sub(edge.begin));
        // Potential region A collision (circle is on the left side of the edge, before the beginning)
        if (v <= 0) {
            const da = edge.begin.sub(cc);
            const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
            // save some sqrts
            if (dda > circle.radius * circle.radius) {
                return null; // no collision
            }
            return new _CollisionContact__WEBPACK_IMPORTED_MODULE_0__["CollisionContact"](circle.collider, edge.collider, da.normalize().scale(circle.radius - Math.sqrt(dda)), edge.begin, da.normalize());
        }
        // Potential region B collision (circle is on the right side of the edge, after the end)
        if (u <= 0) {
            const db = edge.end.sub(cc);
            const ddb = db.dot(db);
            if (ddb > circle.radius * circle.radius) {
                return null;
            }
            return new _CollisionContact__WEBPACK_IMPORTED_MODULE_0__["CollisionContact"](circle.collider, edge.collider, db.normalize().scale(circle.radius - Math.sqrt(ddb)), edge.end, db.normalize());
        }
        // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
        const den = e.dot(e);
        const pointOnEdge = edge.begin
            .scale(u)
            .add(edge.end.scale(v))
            .scale(1 / den);
        const d = cc.sub(pointOnEdge);
        const dd = d.dot(d);
        if (dd > circle.radius * circle.radius) {
            return null; // no collision
        }
        let n = e.perpendicular();
        // flip correct direction
        if (n.dot(cc.sub(edge.begin)) < 0) {
            n.x = -n.x;
            n.y = -n.y;
        }
        n = n.normalize();
        const mvt = n.scale(Math.abs(circle.radius - Math.sqrt(dd)));
        return new _CollisionContact__WEBPACK_IMPORTED_MODULE_0__["CollisionContact"](circle.collider, edge.collider, mvt.negate(), pointOnEdge, n.negate());
    },
    CollideEdgeEdge() {
        // Edge-edge collision doesn't make sense
        return null;
    },
    CollidePolygonEdge(polygon, edge) {
        // 3 cases:
        // (1) Polygon lands on the full face
        // (2) Polygon lands on the right point
        // (3) Polygon lands on the left point
        const e = edge.end.sub(edge.begin);
        let edgeNormal = e.normal();
        if (polygon.contains(edge.begin)) {
            const { distance: mtv, face } = polygon.getClosestFace(edge.begin);
            if (mtv) {
                return new _CollisionContact__WEBPACK_IMPORTED_MODULE_0__["CollisionContact"](polygon.collider, edge.collider, mtv.negate(), edge.begin.add(mtv.negate()), face.normal().negate());
            }
        }
        if (polygon.contains(edge.end)) {
            const { distance: mtv, face } = polygon.getClosestFace(edge.end);
            if (mtv) {
                return new _CollisionContact__WEBPACK_IMPORTED_MODULE_0__["CollisionContact"](polygon.collider, edge.collider, mtv.negate(), edge.end.add(mtv.negate()), face.normal().negate());
            }
        }
        const pc = polygon.center;
        const ec = edge.center;
        const dir = ec.sub(pc).normalize();
        // build a temporary polygon from the edge to use SAT
        const linePoly = new _ConvexPolygon__WEBPACK_IMPORTED_MODULE_1__["ConvexPolygon"]({
            collider: edge.collider,
            points: [edge.begin, edge.end, edge.end.add(dir.scale(30)), edge.begin.add(dir.scale(30))]
        });
        let minAxis = polygon.testSeparatingAxisTheorem(linePoly);
        // no minAxis, no overlap, no collision
        if (!minAxis) {
            return null;
        }
        // flip the normal and axis to always have positive collisions
        edgeNormal = edgeNormal.dot(dir) < 0 ? edgeNormal.negate() : edgeNormal;
        minAxis = minAxis.dot(dir) < 0 ? minAxis.negate() : minAxis;
        return new _CollisionContact__WEBPACK_IMPORTED_MODULE_0__["CollisionContact"](polygon.collider, edge.collider, minAxis, polygon.getFurthestPoint(edgeNormal), edgeNormal);
    },
    CollidePolygonPolygon(polyA, polyB) {
        // do a SAT test to find a min axis if it exists
        let minAxis = polyA.testSeparatingAxisTheorem(polyB);
        // no overlap, no collision return null
        if (!minAxis) {
            return null;
        }
        // make sure that minAxis is pointing from A -> B
        const sameDir = minAxis.dot(polyB.center.sub(polyA.center));
        minAxis = sameDir < 0 ? minAxis.negate() : minAxis;
        // find rough point of collision
        // todo this could be better
        const verts = [];
        const pointA = polyA.getFurthestPoint(minAxis);
        const pointB = polyB.getFurthestPoint(minAxis.negate());
        if (polyB.contains(pointA)) {
            verts.push(pointA);
        }
        if (polyA.contains(pointB)) {
            verts.push(pointB);
        }
        // no candidates, pick something
        if (verts.length === 0) {
            verts.push(pointB);
        }
        const contact = verts.length === 2 ? verts[0].add(verts[1]).scale(0.5) : verts[0];
        return new _CollisionContact__WEBPACK_IMPORTED_MODULE_0__["CollisionContact"](polyA.collider, polyB.collider, minAxis, contact, minAxis.normalize());
    }
};


/***/ }),

/***/ "./Collision/CollisionResolver.ts":
/*!****************************************!*\
  !*** ./Collision/CollisionResolver.ts ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Collision/CollisionShape.ts":
/*!*************************************!*\
  !*** ./Collision/CollisionShape.ts ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Collision/CollisionType.ts":
/*!************************************!*\
  !*** ./Collision/CollisionType.ts ***!
  \************************************/
/*! exports provided: CollisionType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollisionType", function() { return CollisionType; });
/**
 * An enum that describes the types of collisions actors can participate in
 */
var CollisionType;
(function (CollisionType) {
    /**
     * Actors with the `PreventCollision` setting do not participate in any
     * collisions and do not raise collision events.
     */
    CollisionType["PreventCollision"] = "PreventCollision";
    /**
     * Actors with the `Passive` setting only raise collision events, but are not
     * influenced or moved by other actors and do not influence or move other actors.
     */
    CollisionType["Passive"] = "Passive";
    /**
     * Actors with the `Active` setting raise collision events and participate
     * in collisions with other actors and will be push or moved by actors sharing
     * the `Active` or `Fixed` setting.
     */
    CollisionType["Active"] = "Active";
    /**
     * Actors with the `Fixed` setting raise collision events and participate in
     * collisions with other actors. Actors with the `Fixed` setting will not be
     * pushed or moved by other actors sharing the `Fixed`. Think of Fixed
     * actors as "immovable/unstoppable" objects. If two `Fixed` actors meet they will
     * not be pushed or moved by each other, they will not interact except to throw
     * collision events.
     */
    CollisionType["Fixed"] = "Fixed";
})(CollisionType || (CollisionType = {}));


/***/ }),

/***/ "./Collision/ConvexPolygon.ts":
/*!************************************!*\
  !*** ./Collision/ConvexPolygon.ts ***!
  \************************************/
/*! exports provided: ConvexPolygon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConvexPolygon", function() { return ConvexPolygon; });
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Physics */ "./Physics.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Edge */ "./Collision/Edge.ts");
/* harmony import */ var _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CollisionJumpTable */ "./Collision/CollisionJumpTable.ts");
/* harmony import */ var _Circle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Circle */ "./Collision/Circle.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ClosestLineJumpTable */ "./Collision/ClosestLineJumpTable.ts");








/**
 * Polygon collision shape for detecting collisions
 */
class ConvexPolygon {
    constructor(options) {
        this._transformedPoints = [];
        this._axes = [];
        this._sides = [];
        this.offset = options.offset || _Algebra__WEBPACK_IMPORTED_MODULE_6__["Vector"].Zero;
        const winding = !!options.clockwiseWinding;
        this.points = (winding ? options.points.reverse() : options.points) || [];
        this.collider = this.collider = options.collider || null;
        // calculate initial transformation
        this._calculateTransformation();
    }
    /**
     * Returns a clone of this ConvexPolygon, not associated with any collider
     */
    clone() {
        return new ConvexPolygon({
            offset: this.offset.clone(),
            points: this.points.map((p) => p.clone()),
            collider: null
        });
    }
    get worldPos() {
        if (this.collider && this.collider.body) {
            return this.collider.body.pos.add(this.offset);
        }
        return this.offset;
    }
    /**
     * Get the center of the collision shape in world coordinates
     */
    get center() {
        const body = this.collider ? this.collider.body : null;
        if (body) {
            return body.pos.add(this.offset);
        }
        return this.offset;
    }
    /**
     * Calculates the underlying transformation from the body relative space to world space
     */
    _calculateTransformation() {
        const body = this.collider ? this.collider.body : null;
        const pos = body ? body.pos.add(this.offset) : this.offset;
        const angle = body ? body.rotation : 0;
        const scale = body ? body.scale : _Algebra__WEBPACK_IMPORTED_MODULE_6__["Vector"].One;
        const len = this.points.length;
        this._transformedPoints.length = 0; // clear out old transform
        for (let i = 0; i < len; i++) {
            this._transformedPoints[i] = this.points[i].scale(scale).rotate(angle).add(pos);
        }
    }
    /**
     * Gets the points that make up the polygon in world space, from actor relative space (if specified)
     */
    getTransformedPoints() {
        // only recalculate geometry if, hasn't been calculated
        if (!this._transformedPoints.length ||
            // or the position or rotation has changed in world space
            (this.collider &&
                this.collider.body &&
                (!this.collider.body.oldPos.equals(this.collider.body.pos) ||
                    this.collider.body.oldRotation !== this.collider.body.rotation ||
                    this.collider.body.oldScale !== this.collider.body.scale))) {
            this._calculateTransformation();
        }
        return this._transformedPoints;
    }
    /**
     * Gets the sides of the polygon in world space
     */
    getSides() {
        if (this._sides.length) {
            return this._sides;
        }
        const lines = [];
        const points = this.getTransformedPoints();
        const len = points.length;
        for (let i = 0; i < len; i++) {
            lines.push(new _Algebra__WEBPACK_IMPORTED_MODULE_6__["Line"](points[i], points[(i - 1 + len) % len]));
        }
        this._sides = lines;
        return this._sides;
    }
    recalc() {
        this._sides.length = 0;
        this._axes.length = 0;
        this._transformedPoints.length = 0;
        this.getTransformedPoints();
        this.getSides();
    }
    /**
     * Tests if a point is contained in this collision shape in world space
     */
    contains(point) {
        // Always cast to the right, as long as we cast in a consistent fixed direction we
        // will be fine
        const testRay = new _Algebra__WEBPACK_IMPORTED_MODULE_6__["Ray"](point, new _Algebra__WEBPACK_IMPORTED_MODULE_6__["Vector"](1, 0));
        const intersectCount = this.getSides().reduce(function (accum, side) {
            if (testRay.intersect(side) >= 0) {
                return accum + 1;
            }
            return accum;
        }, 0);
        if (intersectCount % 2 === 0) {
            return false;
        }
        return true;
    }
    getClosestLineBetween(shape) {
        if (shape instanceof _Circle__WEBPACK_IMPORTED_MODULE_5__["Circle"]) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__["ClosestLineJumpTable"].PolygonCircleClosestLine(this, shape);
        }
        else if (shape instanceof ConvexPolygon) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__["ClosestLineJumpTable"].PolygonPolygonClosestLine(this, shape);
        }
        else if (shape instanceof _Edge__WEBPACK_IMPORTED_MODULE_3__["Edge"]) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__["ClosestLineJumpTable"].PolygonEdgeClosestLine(this, shape);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * Returns a collision contact if the 2 collision shapes collide, otherwise collide will
     * return null.
     * @param shape
     */
    collide(shape) {
        if (shape instanceof _Circle__WEBPACK_IMPORTED_MODULE_5__["Circle"]) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_4__["CollisionJumpTable"].CollideCirclePolygon(shape, this);
        }
        else if (shape instanceof ConvexPolygon) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_4__["CollisionJumpTable"].CollidePolygonPolygon(this, shape);
        }
        else if (shape instanceof _Edge__WEBPACK_IMPORTED_MODULE_3__["Edge"]) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_4__["CollisionJumpTable"].CollidePolygonEdge(this, shape);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * Find the point on the shape furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const pts = this.getTransformedPoints();
        let furthestPoint = null;
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Finds the closes face to the point using perpendicular distance
     * @param point point to test against polygon
     */
    getClosestFace(point) {
        const sides = this.getSides();
        let min = Number.POSITIVE_INFINITY;
        let faceIndex = -1;
        let distance = -1;
        for (let i = 0; i < sides.length; i++) {
            const dist = sides[i].distanceToPoint(point);
            if (dist < min) {
                min = dist;
                faceIndex = i;
                distance = dist;
            }
        }
        if (faceIndex !== -1) {
            return {
                distance: sides[faceIndex].normal().scale(distance),
                face: sides[faceIndex]
            };
        }
        return null;
    }
    /**
     * Get the axis aligned bounding box for the polygon shape in world coordinates
     */
    get bounds() {
        const points = this.getTransformedPoints();
        return _BoundingBox__WEBPACK_IMPORTED_MODULE_2__["BoundingBox"].fromPoints(points);
    }
    /**
     * Get the axis aligned bounding box for the polygon shape in local coordinates
     */
    get localBounds() {
        return _BoundingBox__WEBPACK_IMPORTED_MODULE_2__["BoundingBox"].fromPoints(this.points);
    }
    /**
     * Get the moment of inertia for an arbitrary polygon
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    get inertia() {
        const mass = this.collider ? this.collider.mass : _Physics__WEBPACK_IMPORTED_MODULE_1__["Physics"].defaultMass;
        let numerator = 0;
        let denominator = 0;
        for (let i = 0; i < this.points.length; i++) {
            const iplusone = (i + 1) % this.points.length;
            const crossTerm = this.points[iplusone].cross(this.points[i]);
            numerator +=
                crossTerm *
                    (this.points[i].dot(this.points[i]) + this.points[i].dot(this.points[iplusone]) + this.points[iplusone].dot(this.points[iplusone]));
            denominator += crossTerm;
        }
        return (mass / 6) * (numerator / denominator);
    }
    /**
     * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
     */
    rayCast(ray, max = Infinity) {
        // find the minimum contact time greater than 0
        // contact times less than 0 are behind the ray and we don't want those
        const sides = this.getSides();
        const len = sides.length;
        let minContactTime = Number.MAX_VALUE;
        let contactIndex = -1;
        for (let i = 0; i < len; i++) {
            const contactTime = ray.intersect(sides[i]);
            if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                minContactTime = contactTime;
                contactIndex = i;
            }
        }
        // contact was found
        if (contactIndex >= 0) {
            return ray.getPoint(minContactTime);
        }
        // no contact found
        return null;
    }
    /**
     * Get the axis associated with the convex polygon
     */
    get axes() {
        if (this._axes.length) {
            return this._axes;
        }
        const axes = [];
        const points = this.getTransformedPoints();
        const len = points.length;
        for (let i = 0; i < len; i++) {
            axes.push(points[i].sub(points[(i + 1) % len]).normal());
        }
        this._axes = axes;
        return this._axes;
    }
    /**
     * Perform Separating Axis test against another polygon, returns null if no overlap in polys
     * Reference http://www.dyn4j.org/2010/01/sat/
     */
    testSeparatingAxisTheorem(other) {
        const poly1 = this;
        const poly2 = other;
        const axes = poly1.axes.concat(poly2.axes);
        let minOverlap = Number.MAX_VALUE;
        let minAxis = null;
        let minIndex = -1;
        for (let i = 0; i < axes.length; i++) {
            const proj1 = poly1.project(axes[i]);
            const proj2 = poly2.project(axes[i]);
            const overlap = proj1.getOverlap(proj2);
            if (overlap <= 0) {
                return null;
            }
            else {
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    minAxis = axes[i];
                    minIndex = i;
                }
            }
        }
        // Sanity check
        if (minIndex === -1) {
            return null;
        }
        return minAxis.normalize().scale(minOverlap);
    }
    /**
     * Project the edges of the polygon along a specified axis
     */
    project(axis) {
        const points = this.getTransformedPoints();
        const len = points.length;
        let min = Number.MAX_VALUE;
        let max = -Number.MAX_VALUE;
        for (let i = 0; i < len; i++) {
            const scalar = points[i].dot(axis);
            min = Math.min(min, scalar);
            max = Math.max(max, scalar);
        }
        return new _Algebra__WEBPACK_IMPORTED_MODULE_6__["Projection"](min, max);
    }
    draw(ctx, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Green, pos = _Algebra__WEBPACK_IMPORTED_MODULE_6__["Vector"].Zero) {
        const basePos = pos.add(this.offset);
        ctx.beginPath();
        ctx.fillStyle = color.toString();
        ctx.moveTo(basePos.x, basePos.y);
        const diffToBase = this.points[0].sub(basePos);
        this.points
            .map((p) => p.sub(diffToBase))
            .forEach(function (point) {
            ctx.lineTo(point.x, point.y);
        });
        ctx.lineTo(basePos.x, basePos.y);
        ctx.closePath();
        ctx.fill();
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Red) {
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        // Iterate through the supplied points and construct a 'polygon'
        const firstPoint = this.getTransformedPoints()[0];
        ctx.moveTo(firstPoint.x, firstPoint.y);
        this.getTransformedPoints().forEach(function (point) {
            ctx.lineTo(point.x, point.y);
        });
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        ctx.stroke();
    }
}


/***/ }),

/***/ "./Collision/DynamicTree.ts":
/*!**********************************!*\
  !*** ./Collision/DynamicTree.ts ***!
  \**********************************/
/*! exports provided: TreeNode, DynamicTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TreeNode", function() { return TreeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicTree", function() { return DynamicTree; });
/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../Physics */ "./Physics.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util/Log */ "./Util/Log.ts");



/**
 * Dynamic Tree Node used for tracking bounds within the tree
 */
class TreeNode {
    constructor(parent) {
        this.parent = parent;
        this.parent = parent || null;
        this.body = null;
        this.bounds = new _BoundingBox__WEBPACK_IMPORTED_MODULE_1__["BoundingBox"]();
        this.left = null;
        this.right = null;
        this.height = 0;
    }
    isLeaf() {
        return !this.left && !this.right;
    }
}
/**
 * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for
 * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
 *
 * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
 * Every non-leaf node is a bounding box that contains child bounding boxes.
 */
class DynamicTree {
    constructor(worldBounds = new _BoundingBox__WEBPACK_IMPORTED_MODULE_1__["BoundingBox"](-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {
        this.worldBounds = worldBounds;
        this.root = null;
        this.nodes = {};
    }
    /**
     * Inserts a node into the dynamic tree
     */
    _insert(leaf) {
        // If there are no nodes in the tree, make this the root leaf
        if (this.root === null) {
            this.root = leaf;
            this.root.parent = null;
            return;
        }
        // Search the tree for a node that is not a leaf and find the best place to insert
        const leafAABB = leaf.bounds;
        let currentRoot = this.root;
        while (!currentRoot.isLeaf()) {
            const left = currentRoot.left;
            const right = currentRoot.right;
            const area = currentRoot.bounds.getPerimeter();
            const combinedAABB = currentRoot.bounds.combine(leafAABB);
            const combinedArea = combinedAABB.getPerimeter();
            // Calculate cost heuristic for creating a new parent and leaf
            const cost = 2 * combinedArea;
            // Minimum cost of pushing the leaf down the tree
            const inheritanceCost = 2 * (combinedArea - area);
            // Cost of descending
            let leftCost = 0;
            const leftCombined = leafAABB.combine(left.bounds);
            let newArea;
            let oldArea;
            if (left.isLeaf()) {
                leftCost = leftCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = left.bounds.getPerimeter();
                newArea = leftCombined.getPerimeter();
                leftCost = newArea - oldArea + inheritanceCost;
            }
            let rightCost = 0;
            const rightCombined = leafAABB.combine(right.bounds);
            if (right.isLeaf()) {
                rightCost = rightCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = right.bounds.getPerimeter();
                newArea = rightCombined.getPerimeter();
                rightCost = newArea - oldArea + inheritanceCost;
            }
            // cost is acceptable
            if (cost < leftCost && cost < rightCost) {
                break;
            }
            // Descend to the depths
            if (leftCost < rightCost) {
                currentRoot = left;
            }
            else {
                currentRoot = right;
            }
        }
        // Create the new parent node and insert into the tree
        const oldParent = currentRoot.parent;
        const newParent = new TreeNode(oldParent);
        newParent.bounds = leafAABB.combine(currentRoot.bounds);
        newParent.height = currentRoot.height + 1;
        if (oldParent !== null) {
            // The sibling node was not the root
            if (oldParent.left === currentRoot) {
                oldParent.left = newParent;
            }
            else {
                oldParent.right = newParent;
            }
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
        }
        else {
            // The sibling node was the root
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
            this.root = newParent;
        }
        // Walk up the tree fixing heights and AABBs
        let currentNode = leaf.parent;
        while (currentNode) {
            currentNode = this._balance(currentNode);
            if (!currentNode.left) {
                throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
            }
            if (!currentNode.right) {
                throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
            }
            currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
            currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
            currentNode = currentNode.parent;
        }
    }
    /**
     * Removes a node from the dynamic tree
     */
    _remove(leaf) {
        if (leaf === this.root) {
            this.root = null;
            return;
        }
        const parent = leaf.parent;
        const grandParent = parent.parent;
        let sibling;
        if (parent.left === leaf) {
            sibling = parent.right;
        }
        else {
            sibling = parent.left;
        }
        if (grandParent) {
            if (grandParent.left === parent) {
                grandParent.left = sibling;
            }
            else {
                grandParent.right = sibling;
            }
            sibling.parent = grandParent;
            let currentNode = grandParent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode = currentNode.parent;
            }
        }
        else {
            this.root = sibling;
            sibling.parent = null;
        }
    }
    /**
     * Tracks a body in the dynamic tree
     */
    trackBody(body) {
        const node = new TreeNode();
        node.body = body;
        node.bounds = body.collider.bounds;
        node.bounds.left -= 2;
        node.bounds.top -= 2;
        node.bounds.right += 2;
        node.bounds.bottom += 2;
        this.nodes[body.id] = node;
        this._insert(node);
    }
    /**
     * Updates the dynamic tree given the current bounds of each body being tracked
     */
    updateBody(body) {
        const node = this.nodes[body.id];
        if (!node) {
            return false;
        }
        const b = body.collider.bounds;
        // if the body is outside the world no longer update it
        if (!this.worldBounds.contains(b)) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_2__["Logger"].getInstance().warn('Collider with id ' + body.id + ' is outside the world bounds and will no longer be tracked for physics');
            this.untrackBody(body);
            return false;
        }
        if (node.bounds.contains(b)) {
            return false;
        }
        this._remove(node);
        b.left -= _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].boundsPadding;
        b.top -= _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].boundsPadding;
        b.right += _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].boundsPadding;
        b.bottom += _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].boundsPadding;
        const multdx = body.vel.x * _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].dynamicTreeVelocityMultiplier;
        const multdy = body.vel.y * _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].dynamicTreeVelocityMultiplier;
        if (multdx < 0) {
            b.left += multdx;
        }
        else {
            b.right += multdx;
        }
        if (multdy < 0) {
            b.top += multdy;
        }
        else {
            b.bottom += multdy;
        }
        node.bounds = b;
        this._insert(node);
        return true;
    }
    /**
     * Untracks a body from the dynamic tree
     */
    untrackBody(body) {
        const node = this.nodes[body.collider.id];
        if (!node) {
            return;
        }
        this._remove(node);
        this.nodes[body.collider.id] = null;
        delete this.nodes[body.collider.id];
    }
    /**
     * Balances the tree about a node
     */
    _balance(node) {
        if (node === null) {
            throw new Error('Cannot balance at null node');
        }
        if (node.isLeaf() || node.height < 2) {
            return node;
        }
        const left = node.left;
        const right = node.right;
        const a = node;
        const b = left;
        const c = right;
        const d = left.left;
        const e = left.right;
        const f = right.left;
        const g = right.right;
        const balance = c.height - b.height;
        // Rotate c node up
        if (balance > 1) {
            // Swap the right node with it's parent
            c.left = a;
            c.parent = a.parent;
            a.parent = c;
            // The original node's old parent should point to the right node
            // this is mega confusing
            if (c.parent) {
                if (c.parent.left === a) {
                    c.parent.left = c;
                }
                else {
                    c.parent.right = c;
                }
            }
            else {
                this.root = c;
            }
            // Rotate
            if (f.height > g.height) {
                c.right = f;
                a.right = g;
                g.parent = a;
                a.bounds = b.bounds.combine(g.bounds);
                c.bounds = a.bounds.combine(f.bounds);
                a.height = 1 + Math.max(b.height, g.height);
                c.height = 1 + Math.max(a.height, f.height);
            }
            else {
                c.right = g;
                a.right = f;
                f.parent = a;
                a.bounds = b.bounds.combine(f.bounds);
                c.bounds = a.bounds.combine(g.bounds);
                a.height = 1 + Math.max(b.height, f.height);
                c.height = 1 + Math.max(a.height, g.height);
            }
            return c;
        }
        // Rotate left node up
        if (balance < -1) {
            // swap
            b.left = a;
            b.parent = a.parent;
            a.parent = b;
            // node's old parent should point to b
            if (b.parent) {
                if (b.parent.left === a) {
                    b.parent.left = b;
                }
                else {
                    if (b.parent.right !== a) {
                        throw 'Error rotating Dynamic Tree';
                    }
                    b.parent.right = b;
                }
            }
            else {
                this.root = b;
            }
            // rotate
            if (d.height > e.height) {
                b.right = d;
                a.left = e;
                e.parent = a;
                a.bounds = c.bounds.combine(e.bounds);
                b.bounds = a.bounds.combine(d.bounds);
                a.height = 1 + Math.max(c.height, e.height);
                b.height = 1 + Math.max(a.height, d.height);
            }
            else {
                b.right = e;
                a.left = d;
                d.parent = a;
                a.bounds = c.bounds.combine(d.bounds);
                b.bounds = a.bounds.combine(e.bounds);
                a.height = 1 + Math.max(c.height, d.height);
                b.height = 1 + Math.max(a.height, e.height);
            }
            return b;
        }
        return node;
    }
    /**
     * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
     */
    getHeight() {
        if (this.root === null) {
            return 0;
        }
        return this.root.height;
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
     *
     * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
     * that you are complete with your query and you do not want to continue. Returning false will continue searching
     * the tree until all possible colliders have been returned.
     */
    query(body, callback) {
        const bounds = body.collider.bounds;
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.intersect(bounds)) {
                if (currentNode.isLeaf() && currentNode.body !== body) {
                    if (callback.call(body, currentNode.body)) {
                        return true;
                    }
                }
                else {
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false;
        };
        helper(this.root);
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
     * long ray to test the tree specified by `max`.
     *
     * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this
     * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
     * the tree until all possible bodies that would intersect with the ray have been returned.
     */
    rayCastQuery(ray, max = Infinity, callback) {
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                if (currentNode.isLeaf()) {
                    if (callback.call(ray, currentNode.body)) {
                        // ray hit a leaf! return the body
                        return true;
                    }
                }
                else {
                    // ray hit but not at a leaf, recurse deeper
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false; // ray missed
        };
        helper(this.root);
    }
    getNodes() {
        const helper = (currentNode) => {
            if (currentNode) {
                return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
            }
            else {
                return [];
            }
        };
        return helper(this.root);
    }
    debugDraw(ctx) {
        // draw all the nodes in the Dynamic Tree
        const helper = (currentNode) => {
            if (currentNode) {
                if (currentNode.isLeaf()) {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'green';
                }
                else {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'white';
                }
                currentNode.bounds.debugDraw(ctx);
                if (currentNode.left) {
                    helper(currentNode.left);
                }
                if (currentNode.right) {
                    helper(currentNode.right);
                }
            }
        };
        helper(this.root);
    }
}


/***/ }),

/***/ "./Collision/DynamicTreeCollisionBroadphase.ts":
/*!*****************************************************!*\
  !*** ./Collision/DynamicTreeCollisionBroadphase.ts ***!
  \*****************************************************/
/*! exports provided: DynamicTreeCollisionBroadphase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicTreeCollisionBroadphase", function() { return DynamicTreeCollisionBroadphase; });
/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../Physics */ "./Physics.ts");
/* harmony import */ var _DynamicTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DynamicTree */ "./Collision/DynamicTree.ts");
/* harmony import */ var _Pair__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pair */ "./Collision/Pair.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CollisionType */ "./Collision/CollisionType.ts");







class DynamicTreeCollisionBroadphase {
    constructor() {
        this._dynamicCollisionTree = new _DynamicTree__WEBPACK_IMPORTED_MODULE_1__["DynamicTree"]();
        this._collisionHash = {};
        this._collisionPairCache = [];
        this._lastFramePairs = [];
        this._lastFramePairsHash = {};
    }
    /**
     * Tracks a physics body for collisions
     */
    track(target) {
        if (!target) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_4__["Logger"].getInstance().warn('Cannot track null physics body');
            return;
        }
        this._dynamicCollisionTree.trackBody(target);
    }
    /**
     * Untracks a physics body
     */
    untrack(target) {
        if (!target) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_4__["Logger"].getInstance().warn('Cannot untrack a null physics body');
            return;
        }
        this._dynamicCollisionTree.untrackBody(target);
    }
    _shouldGenerateCollisionPair(colliderA, colliderB) {
        // if the collision pair has been calculated already short circuit
        const hash = _Pair__WEBPACK_IMPORTED_MODULE_2__["Pair"].calculatePairHash(colliderA, colliderB);
        if (this._collisionHash[hash]) {
            return false; // pair exists easy exit return false
        }
        return _Pair__WEBPACK_IMPORTED_MODULE_2__["Pair"].canCollide(colliderA, colliderB);
    }
    /**
     * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
     */
    broadphase(targets, delta, stats) {
        const seconds = delta / 1000;
        // Retrieve the list of potential colliders, exclude killed, prevented, and self
        const potentialColliders = targets
            .map((t) => t.collider)
            .filter((other) => {
            return other.active && other.type !== _CollisionType__WEBPACK_IMPORTED_MODULE_6__["CollisionType"].PreventCollision;
        });
        // clear old list of collision pairs
        this._collisionPairCache = [];
        this._collisionHash = {};
        // check for normal collision pairs
        let collider;
        for (let j = 0, l = potentialColliders.length; j < l; j++) {
            collider = potentialColliders[j];
            // Query the collision tree for potential colliders
            this._dynamicCollisionTree.query(collider.body, (other) => {
                if (this._shouldGenerateCollisionPair(collider, other.collider)) {
                    const pair = new _Pair__WEBPACK_IMPORTED_MODULE_2__["Pair"](collider, other.collider);
                    this._collisionHash[pair.id] = true;
                    this._collisionPairCache.push(pair);
                }
                // Always return false, to query whole tree. Returning true in the query method stops searching
                return false;
            });
        }
        if (stats) {
            stats.physics.pairs = this._collisionPairCache.length;
        }
        // Check dynamic tree for fast moving objects
        // Fast moving objects are those moving at least there smallest bound per frame
        if (_Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].checkForFastBodies) {
            for (const collider of potentialColliders) {
                // Skip non-active objects. Does not make sense on other collision types
                if (collider.type !== _CollisionType__WEBPACK_IMPORTED_MODULE_6__["CollisionType"].Active) {
                    continue;
                }
                // Maximum travel distance next frame
                const updateDistance = collider.body.vel.size * seconds + // velocity term
                    collider.body.acc.size * 0.5 * seconds * seconds; // acc term
                // Find the minimum dimension
                const minDimension = Math.min(collider.bounds.height, collider.bounds.width);
                if (_Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {
                    if (stats) {
                        stats.physics.fastBodies++;
                    }
                    // start with the oldPos because the integration for actors has already happened
                    // objects resting on a surface may be slightly penetrating in the current position
                    const updateVec = collider.body.pos.sub(collider.body.oldPos);
                    const centerPoint = collider.shape.center;
                    const furthestPoint = collider.shape.getFurthestPoint(collider.body.vel);
                    const origin = furthestPoint.sub(updateVec);
                    const ray = new _Algebra__WEBPACK_IMPORTED_MODULE_3__["Ray"](origin, collider.body.vel);
                    // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface
                    ray.pos = ray.pos.add(ray.dir.scale(-2 * _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].surfaceEpsilon));
                    let minBody;
                    let minTranslate = new _Algebra__WEBPACK_IMPORTED_MODULE_3__["Vector"](Infinity, Infinity);
                    this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].surfaceEpsilon * 2, (other) => {
                        if (collider.body !== other && other.collider.shape && _Pair__WEBPACK_IMPORTED_MODULE_2__["Pair"].canCollide(collider, other.collider)) {
                            const hitPoint = other.collider.shape.rayCast(ray, updateDistance + _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].surfaceEpsilon * 10);
                            if (hitPoint) {
                                const translate = hitPoint.sub(origin);
                                if (translate.size < minTranslate.size) {
                                    minTranslate = translate;
                                    minBody = other;
                                }
                            }
                        }
                        return false;
                    });
                    if (minBody && _Algebra__WEBPACK_IMPORTED_MODULE_3__["Vector"].isValid(minTranslate)) {
                        const pair = new _Pair__WEBPACK_IMPORTED_MODULE_2__["Pair"](collider, minBody.collider);
                        if (!this._collisionHash[pair.id]) {
                            this._collisionHash[pair.id] = true;
                            this._collisionPairCache.push(pair);
                        }
                        // move the fast moving object to the other body
                        // need to push into the surface by ex.Physics.surfaceEpsilon
                        const shift = centerPoint.sub(furthestPoint);
                        collider.body.pos = origin
                            .add(shift)
                            .add(minTranslate)
                            .add(ray.dir.scale(2 * _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].surfaceEpsilon));
                        collider.shape.recalc();
                        if (stats) {
                            stats.physics.fastBodyCollisions++;
                        }
                    }
                }
            }
        }
        // return cache
        return this._collisionPairCache;
    }
    /**
     * Applies narrow phase on collision pairs to find actual area intersections
     * Adds actual colliding pairs to stats' Frame data
     */
    narrowphase(pairs, stats) {
        for (let i = 0; i < pairs.length; i++) {
            pairs[i].collide();
            if (stats && pairs[i].collision) {
                stats.physics.collisions++;
                stats.physics.collidersHash[pairs[i].id] = pairs[i];
            }
        }
        return pairs.filter((p) => p.collision);
    }
    /**
     * Perform collision resolution given a strategy (rigid body or box) and move objects out of intersect.
     */
    resolve(pairs, delta, strategy) {
        for (const pair of pairs) {
            pair.resolve(strategy);
            if (pair.collision) {
                pair.colliderA.body.applyMtv();
                pair.colliderB.body.applyMtv();
                // todo still don't like this, this is a small integration step to resolve narrowphase collisions
                pair.colliderA.body.integrate(delta * _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].collisionShift);
                pair.colliderB.body.integrate(delta * _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].collisionShift);
            }
        }
        return pairs.filter((p) => p.canCollide);
    }
    runCollisionStartEnd(pairs) {
        const currentFrameHash = {};
        for (const p of pairs) {
            // load currentFrameHash
            currentFrameHash[p.id] = p;
            // find all new collisions
            if (!this._lastFramePairsHash[p.id]) {
                const actor1 = p.colliderA;
                const actor2 = p.colliderB;
                actor1.emit('collisionstart', new _Events__WEBPACK_IMPORTED_MODULE_5__["CollisionStartEvent"](actor1, actor2, p));
                actor2.emit('collisionstart', new _Events__WEBPACK_IMPORTED_MODULE_5__["CollisionStartEvent"](actor2, actor1, p));
            }
        }
        // find all old collisions
        for (const p of this._lastFramePairs) {
            if (!currentFrameHash[p.id]) {
                const actor1 = p.colliderA;
                const actor2 = p.colliderB;
                actor1.emit('collisionend', new _Events__WEBPACK_IMPORTED_MODULE_5__["CollisionEndEvent"](actor1, actor2));
                actor2.emit('collisionend', new _Events__WEBPACK_IMPORTED_MODULE_5__["CollisionEndEvent"](actor2, actor1));
            }
        }
        // reset the last frame cache
        this._lastFramePairs = pairs;
        this._lastFramePairsHash = currentFrameHash;
    }
    /**
     * Update the dynamic tree positions
     */
    update(targets) {
        let updated = 0;
        const len = targets.length;
        for (let i = 0; i < len; i++) {
            if (this._dynamicCollisionTree.updateBody(targets[i])) {
                updated++;
            }
        }
        return updated;
    }
    /* istanbul ignore next */
    debugDraw(ctx) {
        if (_Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].broadphaseDebug) {
            this._dynamicCollisionTree.debugDraw(ctx);
        }
        if (_Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].showContacts || _Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].showCollisionNormals) {
            for (const pair of this._collisionPairCache) {
                pair.debugDraw(ctx);
            }
        }
    }
}


/***/ }),

/***/ "./Collision/Edge.ts":
/*!***************************!*\
  !*** ./Collision/Edge.ts ***!
  \***************************/
/*! exports provided: Edge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Edge", function() { return Edge; });
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CollisionJumpTable */ "./Collision/CollisionJumpTable.ts");
/* harmony import */ var _Circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Circle */ "./Collision/Circle.ts");
/* harmony import */ var _ConvexPolygon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ConvexPolygon */ "./Collision/ConvexPolygon.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Physics */ "./Physics.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ClosestLineJumpTable */ "./Collision/ClosestLineJumpTable.ts");








/**
 * Edge is a single line collision shape to create collisions with a single line.
 */
class Edge {
    constructor(options) {
        this.begin = options.begin || _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero;
        this.end = options.end || _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero;
        this.collider = options.collider || null;
        this.offset = this.center;
    }
    /**
     * Returns a clone of this Edge, not associated with any collider
     */
    clone() {
        return new Edge({
            begin: this.begin.clone(),
            end: this.end.clone(),
            collider: null
        });
    }
    get worldPos() {
        if (this.collider && this.collider.body) {
            return this.collider.body.pos.add(this.offset);
        }
        return this.offset;
    }
    /**
     * Get the center of the collision area in world coordinates
     */
    get center() {
        const pos = this.begin.average(this.end).add(this._getBodyPos());
        return pos;
    }
    _getBodyPos() {
        let bodyPos = _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero;
        if (this.collider && this.collider.body) {
            bodyPos = this.collider.body.pos;
        }
        return bodyPos;
    }
    _getTransformedBegin() {
        const body = this.collider ? this.collider.body : null;
        const angle = body ? body.rotation : 0;
        return this.begin.rotate(angle).add(this._getBodyPos());
    }
    _getTransformedEnd() {
        const body = this.collider ? this.collider.body : null;
        const angle = body ? body.rotation : 0;
        return this.end.rotate(angle).add(this._getBodyPos());
    }
    /**
     * Returns the slope of the line in the form of a vector
     */
    getSlope() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Tests if a point is contained in this collision area
     */
    contains() {
        return false;
    }
    /**
     * @inheritdoc
     */
    rayCast(ray, max = Infinity) {
        const numerator = this._getTransformedBegin().sub(ray.pos);
        // Test is line and ray are parallel and non intersecting
        if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
            return null;
        }
        // Lines are parallel
        const divisor = ray.dir.cross(this.getSlope());
        if (divisor === 0) {
            return null;
        }
        const t = numerator.cross(this.getSlope()) / divisor;
        if (t >= 0 && t <= max) {
            const u = numerator.cross(ray.dir) / divisor / this.getLength();
            if (u >= 0 && u <= 1) {
                return ray.getPoint(t);
            }
        }
        return null;
    }
    /**
     * Returns the closes line between this and another shape, from this -> shape
     * @param shape
     */
    getClosestLineBetween(shape) {
        if (shape instanceof _Circle__WEBPACK_IMPORTED_MODULE_2__["Circle"]) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__["ClosestLineJumpTable"].CircleEdgeClosestLine(shape, this);
        }
        else if (shape instanceof _ConvexPolygon__WEBPACK_IMPORTED_MODULE_3__["ConvexPolygon"]) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__["ClosestLineJumpTable"].PolygonEdgeClosestLine(shape, this).flip();
        }
        else if (shape instanceof Edge) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_7__["ClosestLineJumpTable"].EdgeEdgeClosestLine(this, shape);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(shape) {
        if (shape instanceof _Circle__WEBPACK_IMPORTED_MODULE_2__["Circle"]) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_1__["CollisionJumpTable"].CollideCircleEdge(shape, this);
        }
        else if (shape instanceof _ConvexPolygon__WEBPACK_IMPORTED_MODULE_3__["ConvexPolygon"]) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_1__["CollisionJumpTable"].CollidePolygonEdge(shape, this);
        }
        else if (shape instanceof Edge) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_1__["CollisionJumpTable"].CollideEdgeEdge();
        }
        else {
            throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * Find the point on the shape furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        if (direction.dot(transformedBegin) > 0) {
            return transformedBegin;
        }
        else {
            return transformedEnd;
        }
    }
    _boundsFromBeginEnd(begin, end) {
        return new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__["BoundingBox"](Math.min(begin.x, end.x), Math.min(begin.y, end.y), Math.max(begin.x, end.x), Math.max(begin.y, end.y));
    }
    /**
     * Get the axis aligned bounding box for the edge shape in world space
     */
    get bounds() {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        return this._boundsFromBeginEnd(transformedBegin, transformedEnd);
    }
    /**
     * Get the axis aligned bounding box for the edge shape in local space
     */
    get localBounds() {
        return this._boundsFromBeginEnd(this.begin, this.end);
    }
    /**
     * Returns this edge represented as a line in world coordinates
     */
    asLine() {
        return new _Algebra__WEBPACK_IMPORTED_MODULE_4__["Line"](this._getTransformedBegin(), this._getTransformedEnd());
    }
    asLocalLine() {
        return new _Algebra__WEBPACK_IMPORTED_MODULE_4__["Line"](this.begin, this.end);
    }
    /**
     * Get the axis associated with the edge
     */
    get axes() {
        const e = this._getTransformedEnd().sub(this._getTransformedBegin());
        const edgeNormal = e.normal();
        const axes = [];
        axes.push(edgeNormal);
        axes.push(edgeNormal.negate());
        axes.push(edgeNormal.normal());
        axes.push(edgeNormal.normal().negate());
        return axes;
    }
    /**
     * Get the moment of inertia for an edge
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    get inertia() {
        const mass = this.collider ? this.collider.mass : _Physics__WEBPACK_IMPORTED_MODULE_5__["Physics"].defaultMass;
        const length = this.end.sub(this.begin).distance() / 2;
        return mass * length * length;
    }
    /**
     * @inheritdoc
     */
    recalc() {
        // edges don't have any cached data
    }
    /**
     * Project the edge along a specified axis
     */
    project(axis) {
        const scalars = [];
        const points = [this._getTransformedBegin(), this._getTransformedEnd()];
        const len = points.length;
        for (let i = 0; i < len; i++) {
            scalars.push(points[i].dot(axis));
        }
        return new _Algebra__WEBPACK_IMPORTED_MODULE_4__["Projection"](Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    draw(ctx, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_6__["Color"].Green, pos = _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero) {
        const begin = this.begin.add(pos);
        const end = this.end.add(pos);
        ctx.strokeStyle = color.toString();
        ctx.beginPath();
        ctx.moveTo(begin.x, begin.y);
        ctx.lineTo(end.x, end.y);
        ctx.closePath();
        ctx.stroke();
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_6__["Color"].Red) {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        ctx.strokeStyle = color.toString();
        ctx.beginPath();
        ctx.moveTo(begin.x, begin.y);
        ctx.lineTo(end.x, end.y);
        ctx.closePath();
        ctx.stroke();
    }
}


/***/ }),

/***/ "./Collision/Index.ts":
/*!****************************!*\
  !*** ./Collision/Index.ts ***!
  \****************************/
/*! exports provided: Body, isCollider, Collider, BoundingBox, Circle, CollisionContact, CollisionJumpTable, ClosestLine, ClosestLineJumpTable, CollisionGroup, CollisionGroupManager, TreeNode, DynamicTree, DynamicTreeCollisionBroadphase, Edge, Pair, ConvexPolygon, Side, Shape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Body */ "./Collision/Body.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Body", function() { return _Body__WEBPACK_IMPORTED_MODULE_0__["Body"]; });

/* harmony import */ var _Collider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Collider */ "./Collision/Collider.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isCollider", function() { return _Collider__WEBPACK_IMPORTED_MODULE_1__["isCollider"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Collider", function() { return _Collider__WEBPACK_IMPORTED_MODULE_1__["Collider"]; });

/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return _BoundingBox__WEBPACK_IMPORTED_MODULE_2__["BoundingBox"]; });

/* harmony import */ var _Circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Circle */ "./Collision/Circle.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return _Circle__WEBPACK_IMPORTED_MODULE_3__["Circle"]; });

/* harmony import */ var _CollisionContact__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CollisionContact */ "./Collision/CollisionContact.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionContact", function() { return _CollisionContact__WEBPACK_IMPORTED_MODULE_4__["CollisionContact"]; });

/* harmony import */ var _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CollisionJumpTable */ "./Collision/CollisionJumpTable.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionJumpTable", function() { return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_5__["CollisionJumpTable"]; });

/* harmony import */ var _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ClosestLineJumpTable */ "./Collision/ClosestLineJumpTable.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClosestLine", function() { return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_6__["ClosestLine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClosestLineJumpTable", function() { return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_6__["ClosestLineJumpTable"]; });

/* harmony import */ var _CollisionGroup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CollisionGroup */ "./Collision/CollisionGroup.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionGroup", function() { return _CollisionGroup__WEBPACK_IMPORTED_MODULE_7__["CollisionGroup"]; });

/* harmony import */ var _CollisionGroupManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CollisionGroupManager */ "./Collision/CollisionGroupManager.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionGroupManager", function() { return _CollisionGroupManager__WEBPACK_IMPORTED_MODULE_8__["CollisionGroupManager"]; });

/* harmony import */ var _DynamicTree__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DynamicTree */ "./Collision/DynamicTree.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TreeNode", function() { return _DynamicTree__WEBPACK_IMPORTED_MODULE_9__["TreeNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DynamicTree", function() { return _DynamicTree__WEBPACK_IMPORTED_MODULE_9__["DynamicTree"]; });

/* harmony import */ var _DynamicTreeCollisionBroadphase__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DynamicTreeCollisionBroadphase */ "./Collision/DynamicTreeCollisionBroadphase.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DynamicTreeCollisionBroadphase", function() { return _DynamicTreeCollisionBroadphase__WEBPACK_IMPORTED_MODULE_10__["DynamicTreeCollisionBroadphase"]; });

/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Edge */ "./Collision/Edge.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Edge", function() { return _Edge__WEBPACK_IMPORTED_MODULE_11__["Edge"]; });

/* harmony import */ var _CollisionShape__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./CollisionShape */ "./Collision/CollisionShape.ts");
/* empty/unused harmony star reexport *//* harmony import */ var _CollisionResolver__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./CollisionResolver */ "./Collision/CollisionResolver.ts");
/* empty/unused harmony star reexport *//* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Physics */ "./Collision/Physics.ts");
/* empty/unused harmony star reexport *//* harmony import */ var _Pair__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Pair */ "./Collision/Pair.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pair", function() { return _Pair__WEBPACK_IMPORTED_MODULE_15__["Pair"]; });

/* harmony import */ var _ConvexPolygon__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ConvexPolygon */ "./Collision/ConvexPolygon.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConvexPolygon", function() { return _ConvexPolygon__WEBPACK_IMPORTED_MODULE_16__["ConvexPolygon"]; });

/* harmony import */ var _Side__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Side */ "./Collision/Side.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Side", function() { return _Side__WEBPACK_IMPORTED_MODULE_17__["Side"]; });

/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Shape */ "./Collision/Shape.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return _Shape__WEBPACK_IMPORTED_MODULE_18__["Shape"]; });






















/***/ }),

/***/ "./Collision/Pair.ts":
/*!***************************!*\
  !*** ./Collision/Pair.ts ***!
  \***************************/
/*! exports provided: Pair */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pair", function() { return Pair; });
/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../Physics */ "./Physics.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util/DrawUtil */ "./Util/DrawUtil.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CollisionType */ "./Collision/CollisionType.ts");




/**
 * Models a potential collision between 2 bodies
 */
class Pair {
    constructor(colliderA, colliderB) {
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.id = null;
        this.collision = null;
        this.id = Pair.calculatePairHash(colliderA, colliderB);
    }
    static canCollide(colliderA, colliderB) {
        // If both are in the same collision group short circuit
        if (!colliderA.group.canCollide(colliderB.group)) {
            return false;
        }
        // if both are fixed short circuit
        if (colliderA.type === _CollisionType__WEBPACK_IMPORTED_MODULE_3__["CollisionType"].Fixed && colliderB.type === _CollisionType__WEBPACK_IMPORTED_MODULE_3__["CollisionType"].Fixed) {
            return false;
        }
        // if the either is prevent collision short circuit
        if (colliderB.type === _CollisionType__WEBPACK_IMPORTED_MODULE_3__["CollisionType"].PreventCollision || colliderA.type === _CollisionType__WEBPACK_IMPORTED_MODULE_3__["CollisionType"].PreventCollision) {
            return false;
        }
        // if either is dead short circuit
        if (!colliderA.active || !colliderB.active) {
            return false;
        }
        return true;
    }
    /**
     * Returns whether or not it is possible for the pairs to collide
     */
    get canCollide() {
        const actorA = this.colliderA;
        const actorB = this.colliderB;
        return Pair.canCollide(actorA, actorB);
    }
    /**
     * Runs the collision intersection logic on the members of this pair
     */
    collide() {
        this.collision = this.colliderA.collide(this.colliderB);
    }
    /**
     * Resolves the collision body position and velocity if a collision occurred
     */
    resolve(strategy) {
        if (this.collision) {
            this.collision.resolve(strategy);
        }
    }
    /**
     * Calculates the unique pair hash id for this collision pair
     */
    static calculatePairHash(colliderA, colliderB) {
        if (colliderA.id < colliderB.id) {
            return `#${colliderA.id}+${colliderB.id}`;
        }
        else {
            return `#${colliderB.id}+${colliderA.id}`;
        }
    }
    /* istanbul ignore next */
    debugDraw(ctx) {
        if (this.collision) {
            if (_Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].showContacts) {
                _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_2__["point"](ctx, _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Red, this.collision.point);
            }
            if (_Physics__WEBPACK_IMPORTED_MODULE_0__["Physics"].showCollisionNormals) {
                _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_2__["vector"](ctx, _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Cyan, this.collision.point, this.collision.normal, 30);
            }
        }
    }
}


/***/ }),

/***/ "./Collision/Physics.ts":
/*!******************************!*\
  !*** ./Collision/Physics.ts ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Collision/Shape.ts":
/*!****************************!*\
  !*** ./Collision/Shape.ts ***!
  \****************************/
/*! exports provided: Shape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony import */ var _ConvexPolygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConvexPolygon */ "./Collision/ConvexPolygon.ts");
/* harmony import */ var _Circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Circle */ "./Collision/Circle.ts");
/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Edge */ "./Collision/Edge.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");





/**
 * Excalibur shape helper for defining collision shapes quickly
 */
class Shape {
    /**
     * Creates a box collision shape, under the hood defines a [[ConvexPolygon]] collision shape
     * @param width Width of the box
     * @param height Height of the box
     * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Box(width, height, anchor = _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Half, offset = _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero) {
        return new _ConvexPolygon__WEBPACK_IMPORTED_MODULE_0__["ConvexPolygon"]({
            points: new _BoundingBox__WEBPACK_IMPORTED_MODULE_3__["BoundingBox"](-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),
            offset: offset
        });
    }
    /**
     * Creates a new [[ConvexPolygon|arbitrary polygon]] collision shape
     * @param points Points specified in counter clockwise
     * @param clockwiseWinding Optionally changed the winding of points, by default false meaning counter-clockwise winding.
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Polygon(points, clockwiseWinding = false, offset = _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero) {
        return new _ConvexPolygon__WEBPACK_IMPORTED_MODULE_0__["ConvexPolygon"]({
            points: points,
            offset: offset,
            clockwiseWinding: clockwiseWinding
        });
    }
    /**
     * Creates a new [[circle|Circle]] collision shape
     * @param radius Radius of the circle shape
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Circle(radius, offset = _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero) {
        return new _Circle__WEBPACK_IMPORTED_MODULE_1__["Circle"]({
            radius: radius,
            offset: offset
        });
    }
    /**
     * Creates a new [[Edge|edge]] collision shape
     * @param begin Beginning of the edge in local coordinates to the collider
     * @param end Ending of the edge in local coordinates to the collider
     */
    static Edge(begin, end) {
        return new _Edge__WEBPACK_IMPORTED_MODULE_2__["Edge"]({
            begin: begin,
            end: end
        });
    }
}


/***/ }),

/***/ "./Collision/Side.ts":
/*!***************************!*\
  !*** ./Collision/Side.ts ***!
  \***************************/
/*! exports provided: Side */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Side", function() { return Side; });
/**
 * An enum that describes the sides of an Actor for collision
 */
var Side;
(function (Side) {
    Side["None"] = "None";
    Side["Top"] = "Top";
    Side["Bottom"] = "Bottom";
    Side["Left"] = "Left";
    Side["Right"] = "Right";
})(Side || (Side = {}));


/***/ }),

/***/ "./Configurable.ts":
/*!*************************!*\
  !*** ./Configurable.ts ***!
  \*************************/
/*! exports provided: Configurable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Configurable", function() { return Configurable; });
/**
 * Configurable helper extends base type and makes all properties available as option bag arguments
 * @internal
 * @param base
 */
function Configurable(base) {
    return class extends base {
        assign(props) {
            //set the value of every property that was passed in,
            //if the constructor previously set this value, it will be overridden here
            for (const k in props) {
                // eslint-disable-next-line
                if (typeof this[k] !== 'function') {
                    // eslint-disable-next-line
                    this[k] = props[k];
                }
            }
        }
        constructor(...args) {
            super(...args);
            //get the number of arguments that aren't undefined. TS passes a value to all parameters
            //of whatever ctor is the implementation, so args.length doesn't work here.
            const size = args.filter(function (value) {
                return value !== undefined;
            }).length;
            if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {
                this.assign(args[0]);
            }
        }
    };
}


/***/ }),

/***/ "./Debug.ts":
/*!******************!*\
  !*** ./Debug.ts ***!
  \******************/
/*! exports provided: Debug, FrameStats, PhysicsStats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Debug", function() { return Debug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrameStats", function() { return FrameStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PhysicsStats", function() { return PhysicsStats; });
/* harmony import */ var _DebugFlags__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DebugFlags */ "./DebugFlags.ts");

/**
 * Debug statistics and flags for Excalibur. If polling these values, it would be
 * best to do so on the `postupdate` event for [[Engine]], after all values have been
 * updated during a frame.
 */
class Debug {
    constructor(engine) {
        /**
         * Performance statistics
         */
        this.stats = {
            /**
             * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[postframe]] event. See [[FrameStats]]
             */
            currFrame: new FrameStats(),
            /**
             * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]
             */
            prevFrame: new FrameStats()
        };
        this._engine = engine;
        this.colorBlindMode = new _DebugFlags__WEBPACK_IMPORTED_MODULE_0__["ColorBlindFlags"](this._engine);
    }
}
/**
 * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid
 * creating instances of this every frame.
 */
class FrameStats {
    constructor() {
        this._id = 0;
        this._delta = 0;
        this._fps = 0;
        this._actorStats = {
            alive: 0,
            killed: 0,
            ui: 0,
            get remaining() {
                return this.alive - this.killed;
            },
            get total() {
                return this.remaining + this.ui;
            }
        };
        this._durationStats = {
            update: 0,
            draw: 0,
            get total() {
                return this.update + this.draw;
            }
        };
        this._physicsStats = new PhysicsStats();
    }
    /**
     * Zero out values or clone other IFrameStat stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.id = otherStats.id;
            this.delta = otherStats.delta;
            this.fps = otherStats.fps;
            this.actors.alive = otherStats.actors.alive;
            this.actors.killed = otherStats.actors.killed;
            this.actors.ui = otherStats.actors.ui;
            this.duration.update = otherStats.duration.update;
            this.duration.draw = otherStats.duration.draw;
            this._physicsStats.reset(otherStats.physics);
        }
        else {
            this.id = this.delta = this.fps = 0;
            this.actors.alive = this.actors.killed = this.actors.ui = 0;
            this.duration.update = this.duration.draw = 0;
            this._physicsStats.reset();
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const fs = new FrameStats();
        fs.reset(this);
        return fs;
    }
    /**
     * Gets the frame's id
     */
    get id() {
        return this._id;
    }
    /**
     * Sets the frame's id
     */
    set id(value) {
        this._id = value;
    }
    /**
     * Gets the frame's delta (time since last frame)
     */
    get delta() {
        return this._delta;
    }
    /**
     * Sets the frame's delta (time since last frame). Internal use only.
     * @internal
     */
    set delta(value) {
        this._delta = value;
    }
    /**
     * Gets the frame's frames-per-second (FPS)
     */
    get fps() {
        return this._fps;
    }
    /**
     * Sets the frame's frames-per-second (FPS). Internal use only.
     * @internal
     */
    set fps(value) {
        this._fps = value;
    }
    /**
     * Gets the frame's actor statistics
     */
    get actors() {
        return this._actorStats;
    }
    /**
     * Gets the frame's duration statistics
     */
    get duration() {
        return this._durationStats;
    }
    /**
     * Gets the frame's physics statistics
     */
    get physics() {
        return this._physicsStats;
    }
}
class PhysicsStats {
    constructor() {
        this._pairs = 0;
        this._collisions = 0;
        this._collidersHash = {};
        this._fastBodies = 0;
        this._fastBodyCollisions = 0;
        this._broadphase = 0;
        this._narrowphase = 0;
    }
    /**
     * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.pairs = otherStats.pairs;
            this.collisions = otherStats.collisions;
            this.collidersHash = otherStats.collidersHash;
            this.fastBodies = otherStats.fastBodies;
            this.fastBodyCollisions = otherStats.fastBodyCollisions;
            this.broadphase = otherStats.broadphase;
            this.narrowphase = otherStats.narrowphase;
        }
        else {
            this.pairs = this.collisions = this.fastBodies = 0;
            this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
            this.collidersHash = {};
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const ps = new PhysicsStats();
        ps.reset(this);
        return ps;
    }
    get pairs() {
        return this._pairs;
    }
    set pairs(value) {
        this._pairs = value;
    }
    get collisions() {
        return this._collisions;
    }
    set collisions(value) {
        this._collisions = value;
    }
    get collidersHash() {
        return this._collidersHash;
    }
    set collidersHash(colliders) {
        this._collidersHash = colliders;
    }
    get fastBodies() {
        return this._fastBodies;
    }
    set fastBodies(value) {
        this._fastBodies = value;
    }
    get fastBodyCollisions() {
        return this._fastBodyCollisions;
    }
    set fastBodyCollisions(value) {
        this._fastBodyCollisions = value;
    }
    get broadphase() {
        return this._broadphase;
    }
    set broadphase(value) {
        this._broadphase = value;
    }
    get narrowphase() {
        return this._narrowphase;
    }
    set narrowphase(value) {
        this._narrowphase = value;
    }
}


/***/ }),

/***/ "./DebugFlags.ts":
/*!***********************!*\
  !*** ./DebugFlags.ts ***!
  \***********************/
/*! exports provided: ColorBlindFlags */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorBlindFlags", function() { return ColorBlindFlags; });
/* harmony import */ var _PostProcessing_Index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PostProcessing/Index */ "./PostProcessing/Index.ts");

class ColorBlindFlags {
    constructor(engine) {
        this._engine = engine;
    }
    correct(colorBlindness) {
        this._engine.postProcessors.push(new _PostProcessing_Index__WEBPACK_IMPORTED_MODULE_0__["ColorBlindCorrector"](this._engine, false, colorBlindness));
    }
    simulate(colorBlindness) {
        this._engine.postProcessors.push(new _PostProcessing_Index__WEBPACK_IMPORTED_MODULE_0__["ColorBlindCorrector"](this._engine, true, colorBlindness));
    }
}


/***/ }),

/***/ "./Drawing/Animation.ts":
/*!******************************!*\
  !*** ./Drawing/Animation.ts ***!
  \******************************/
/*! exports provided: AnimationImpl, Animation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationImpl", function() { return AnimationImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return Animation; });
/* harmony import */ var _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpriteEffects */ "./Drawing/SpriteEffects.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Engine */ "./Engine.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Configurable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Configurable */ "./Configurable.ts");





/**
 * @hidden
 */
class AnimationImpl {
    /**
     * Typically you will use a [[SpriteSheet]] to generate an [[Animation]].
     *
     * @param engineOrConfig  Reference to the current game engine
     * @param sprites  An array of sprites to create the frames for the animation
     * @param speed   The number in milliseconds to display each frame in the animation
     * @param loop    Indicates whether the animation should loop after it is completed
     */
    constructor(engineOrConfig, sprites, speed, loop) {
        /**
         * The sprite frames to play, in order. See [[SpriteSheet.getAnimationForAll]] to quickly
         * generate an [[Animation]].
         */
        this.sprites = [];
        /**
         * Current frame index being shown
         */
        this.currentFrame = 0;
        this._timeLeftInFrame = 0;
        this._idempotencyToken = -1;
        this.anchor = _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].Zero;
        this.rotation = 0.0;
        this.scale = _Algebra__WEBPACK_IMPORTED_MODULE_1__["Vector"].One;
        /**
         * Indicates whether the animation should loop after it is completed
         */
        this.loop = true;
        /**
         * Indicates the frame index the animation should freeze on for a non-looping
         * animation. By default it is the last frame.
         */
        this.freezeFrame = -1;
        /**
         * Flip each frame vertically. Sets [[Sprite.flipVertical]].
         */
        this.flipVertical = false;
        /**
         * Flip each frame horizontally. Sets [[Sprite.flipHorizontal]].
         */
        this.flipHorizontal = false;
        this.drawWidth = 0;
        this.drawHeight = 0;
        this.width = 0;
        this.height = 0;
        this._opacity = 1;
        let engine = engineOrConfig;
        if (engineOrConfig && !(engineOrConfig instanceof _Engine__WEBPACK_IMPORTED_MODULE_2__["Engine"])) {
            const config = engineOrConfig;
            engine = config.engine;
            sprites = config.sprites;
            speed = config.speed;
            loop = config.loop;
        }
        this.sprites = sprites;
        this.speed = speed;
        this._engine = engine;
        this._timeLeftInFrame = this.speed;
        if (loop != null) {
            this.loop = loop;
        }
        if (sprites && sprites[0]) {
            this.drawHeight = sprites[0] ? sprites[0].drawHeight : 0;
            this.drawWidth = sprites[0] ? sprites[0].drawWidth : 0;
            this.width = sprites[0] ? sprites[0].width : 0;
            this.height = sprites[0] ? sprites[0].height : 0;
            this.freezeFrame = sprites.length - 1;
        }
    }
    /**
     * Applies the opacity effect to a sprite, setting the alpha of all pixels to a given value
     */
    opacity(value) {
        this._opacity = value;
    }
    /**
     * Applies the grayscale effect to a sprite, removing color information.
     */
    grayscale() {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Grayscale"]());
    }
    /**
     * Applies the invert effect to a sprite, inverting the pixel colors.
     */
    invert() {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Invert"]());
    }
    /**
     * Applies the fill effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
     */
    fill(color) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Fill"](color));
    }
    /**
     * Applies the colorize effect to a sprite, changing the color channels of all pixels to be the average of the original color and the
     * provided color.
     */
    colorize(color) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Colorize"](color));
    }
    /**
     * Applies the lighten effect to a sprite, changes the lightness of the color according to hsl
     */
    lighten(factor = 0.1) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Lighten"](factor));
    }
    /**
     * Applies the darken effect to a sprite, changes the darkness of the color according to hsl
     */
    darken(factor = 0.1) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Darken"](factor));
    }
    /**
     * Applies the saturate effect to a sprite, saturates the color according to hsl
     */
    saturate(factor = 0.1) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Saturate"](factor));
    }
    /**
     * Applies the desaturate effect to a sprite, desaturates the color according to hsl
     */
    desaturate(factor = 0.1) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Desaturate"](factor));
    }
    /**
     * Add a [[SpriteEffect]] manually
     */
    addEffect(effect) {
        for (const i in this.sprites) {
            this.sprites[i].addEffect(effect);
        }
    }
    removeEffect(param) {
        for (const i in this.sprites) {
            this.sprites[i].removeEffect(param);
        }
    }
    /**
     * Clear all sprite effects
     */
    clearEffects() {
        for (const i in this.sprites) {
            this.sprites[i].clearEffects();
        }
    }
    _setAnchor(point) {
        //if (!this.anchor.equals(point)) {
        for (const i in this.sprites) {
            this.sprites[i].anchor.setTo(point.x, point.y);
        }
        //}
    }
    _setRotation(radians) {
        //if (this.rotation !== radians) {
        for (const i in this.sprites) {
            this.sprites[i].rotation = radians;
        }
        //}
    }
    _setScale(scale) {
        //if (!this.scale.equals(scale)) {
        for (const i in this.sprites) {
            this.sprites[i].scale = scale;
        }
        //}
    }
    /**
     * Resets the animation to first frame.
     */
    reset() {
        this.currentFrame = 0;
    }
    /**
     * Indicates whether the animation is complete, animations that loop are never complete.
     */
    isDone() {
        return !this.loop && this.currentFrame >= this.sprites.length;
    }
    /**
     * Not meant to be called by game developers. Ticks the animation forward internally and
     * calculates whether to change to the frame.
     * @internal
     */
    tick(elapsed, idempotencyToken) {
        if (this._idempotencyToken === idempotencyToken) {
            return;
        }
        this._idempotencyToken = idempotencyToken;
        this._timeLeftInFrame -= elapsed;
        if (this._timeLeftInFrame <= 0) {
            this.currentFrame = this.loop ? (this.currentFrame + 1) % this.sprites.length : this.currentFrame + 1;
            this._timeLeftInFrame = this.speed;
        }
        this._updateValues();
        const current = this.sprites[this.currentFrame];
        if (current) {
            this.width = current.width;
            this.height = current.height;
            this.drawWidth = current.drawWidth;
            this.drawHeight = current.drawHeight;
        }
    }
    _updateValues() {
        this._setAnchor(this.anchor);
        this._setRotation(this.rotation);
        this._setScale(this.scale);
    }
    /**
     * Skips ahead a specified number of frames in the animation
     * @param frames  Frames to skip ahead
     */
    skip(frames) {
        this.currentFrame = (this.currentFrame + frames) % this.sprites.length;
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        const animOptions = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.drawWidth, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.drawHeight, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, opacity: (_g = options.opacity) !== null && _g !== void 0 ? _g : this._opacity });
        this._updateValues();
        let currSprite;
        if (this.currentFrame < this.sprites.length) {
            currSprite = this.sprites[this.currentFrame];
            currSprite.draw(animOptions);
        }
        if (this.freezeFrame !== -1 && this.currentFrame >= this.sprites.length) {
            currSprite = this.sprites[_Util_Util__WEBPACK_IMPORTED_MODULE_3__["clamp"](this.freezeFrame, 0, this.sprites.length - 1)];
            currSprite.draw(animOptions);
        }
        // add the calculated width
        if (currSprite) {
            this.drawWidth = currSprite.drawWidth;
            this.drawHeight = currSprite.drawHeight;
        }
    }
    /**
     * Plays an animation at an arbitrary location in the game.
     * @param x  The x position in the game to play
     * @param y  The y position in the game to play
     */
    play(x, y) {
        this.reset();
        this._engine.playAnimation(this, x, y);
    }
}
/**
 * Animations allow you to display a series of images one after another,
 * creating the illusion of change. Generally these images will come from a [[SpriteSheet]] source.
 */
class Animation extends Object(_Configurable__WEBPACK_IMPORTED_MODULE_4__["Configurable"])(AnimationImpl) {
    constructor(engineOrConfig, images, speed, loop) {
        super(engineOrConfig, images, speed, loop);
    }
}


/***/ }),

/***/ "./Drawing/CanvasDrawComponent.ts":
/*!****************************************!*\
  !*** ./Drawing/CanvasDrawComponent.ts ***!
  \****************************************/
/*! exports provided: CanvasDrawComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasDrawComponent", function() { return CanvasDrawComponent; });
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/index.ts");

class CanvasDrawComponent extends _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    constructor(draw) {
        var _a;
        super();
        this.draw = draw;
        this.type = 'canvas';
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.draw = (_a = this.draw) !== null && _a !== void 0 ? _a : (() => { });
    }
}


/***/ }),

/***/ "./Drawing/CanvasDrawingSystem.ts":
/*!****************************************!*\
  !*** ./Drawing/CanvasDrawingSystem.ts ***!
  \****************************************/
/*! exports provided: CanvasDrawingSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasDrawingSystem", function() { return CanvasDrawingSystem; });
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/index.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");


/**
 * Draws anything with a transform and a "draw" method
 */
class CanvasDrawingSystem extends _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__["System"] {
    constructor() {
        super(...arguments);
        this.types = ['transform', 'canvas'];
        this.systemType = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__["SystemType"].Draw;
        this.priority = -1;
    }
    initialize(scene) {
        this._ctx = scene.engine.ctx;
        this._engine = scene.engine;
        this._camera = scene.camera;
    }
    sort(a, b) {
        return a.components.transform.z - b.components.transform.z;
    }
    update(entities, delta) {
        this._clearScreen();
        let transform;
        let canvasdraw;
        const length = entities.length;
        for (let i = 0; i < length; i++) {
            if (entities[i].visible && !entities[i].isOffScreen) {
                transform = entities[i].components.transform;
                canvasdraw = entities[i].components.canvas;
                this._ctx.save();
                this._pushCameraTransform(transform);
                this._ctx.save();
                this._applyTransform(entities[i]);
                canvasdraw.draw(this._ctx, delta);
                this._ctx.restore();
                this._popCameraTransform(transform);
                this._ctx.restore();
            }
            if (this._engine.isDebug) {
                this._ctx.save();
                this._pushCameraTransform(transform);
                this._ctx.strokeStyle = 'yellow';
                entities[i].debugDraw(this._ctx);
                this._popCameraTransform(transform);
                this._ctx.restore();
            }
        }
        if (this._engine.isDebug) {
            this._ctx.save();
            this._camera.draw(this._ctx);
            this._camera.debugDraw(this._ctx);
            this._ctx.restore();
        }
    }
    _applyTransform(actor) {
        let parent = actor.parent;
        while (parent) {
            this._ctx.translate(parent.pos.x, parent.pos.y);
            this._ctx.rotate(parent.rotation);
            this._ctx.scale(parent.scale.x, parent.scale.y);
            parent = parent.parent;
        }
        this._ctx.translate(actor.pos.x, actor.pos.y);
        this._ctx.rotate(actor.rotation);
        this._ctx.scale(actor.scale.x, actor.scale.y);
    }
    _clearScreen() {
        this._ctx.clearRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);
        this._ctx.fillStyle = this._engine.backgroundColor.toString();
        this._ctx.fillRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);
    }
    _pushCameraTransform(transform) {
        if (transform.coordPlane === _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["CoordPlane"].World) {
            // Apply camera transform to place entity in world space
            this._ctx.save();
            if (this._camera) {
                this._camera.draw(this._ctx);
            }
        }
    }
    _popCameraTransform(transform) {
        if (transform.coordPlane === _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["CoordPlane"].World) {
            // Restore back to screen space from world space if we were drawing an entity there
            this._ctx.restore();
        }
    }
}


/***/ }),

/***/ "./Drawing/Color.ts":
/*!**************************!*\
  !*** ./Drawing/Color.ts ***!
  \**************************/
/*! exports provided: Color */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/Decorators */ "./Util/Decorators.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Provides standard colors (e.g. [[Color.Black]])
 * but you can also create custom colors using RGB, HSL, or Hex. Also provides
 * useful color operations like [[Color.lighten]], [[Color.darken]], and more.
 */
class Color {
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    constructor(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a != null ? a : 1;
    }
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    static fromRGB(r, g, b, a) {
        return new Color(r, g, b, a);
    }
    /**
     * Creates a new instance of Color from a rgb string
     *
     * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
     */
    static fromRGBString(string) {
        const rgbaRegEx = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
        let match = null;
        if ((match = string.match(rgbaRegEx))) {
            const r = parseInt(match[1], 10);
            const g = parseInt(match[2], 10);
            const b = parseInt(match[3], 10);
            let a = 1;
            if (match[4]) {
                a = parseFloat(match[4]);
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid rgb/a string: ' + string);
        }
    }
    /**
     * Creates a new instance of Color from a hex string
     *
     * @param hex  CSS color string of the form #ffffff, the alpha component is optional
     */
    static fromHex(hex) {
        const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
        let match = null;
        if ((match = hex.match(hexRegEx))) {
            const r = parseInt(match[1], 16);
            const g = parseInt(match[2], 16);
            const b = parseInt(match[3], 16);
            let a = 1;
            if (match[4]) {
                a = parseInt(match[4], 16) / 255;
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid hex string: ' + hex);
        }
    }
    /**
     * Creates a new instance of Color from hsla values
     *
     * @param h  Hue is represented [0-1]
     * @param s  Saturation is represented [0-1]
     * @param l  Luminance is represented [0-1]
     * @param a  Alpha is represented [0-1]
     */
    static fromHSL(h, s, l, a = 1.0) {
        const temp = new HSLColor(h, s, l, a);
        return temp.toRGBA();
    }
    /**
     * Lightens the current color by a specified amount
     *
     * @param factor  The amount to lighten by [0-1]
     */
    lighten(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l += (1 - temp.l) * factor;
        return temp.toRGBA();
    }
    /**
     * Darkens the current color by a specified amount
     *
     * @param factor  The amount to darken by [0-1]
     */
    darken(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l -= temp.l * factor;
        return temp.toRGBA();
    }
    /**
     * Saturates the current color by a specified amount
     *
     * @param factor  The amount to saturate by [0-1]
     */
    saturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s += temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Desaturates the current color by a specified amount
     *
     * @param factor  The amount to desaturate by [0-1]
     */
    desaturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s -= temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Multiplies a color by another, results in a darker color
     *
     * @param color  The other color
     */
    multiply(color) {
        const newR = (((color.r / 255) * this.r) / 255) * 255;
        const newG = (((color.g / 255) * this.g) / 255) * 255;
        const newB = (((color.b / 255) * this.b) / 255) * 255;
        const newA = color.a * this.a;
        return new Color(newR, newG, newB, newA);
    }
    /**
     * Multiplies a color by another, results in a darker color
     * @param color
     * @obsolete Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0
     */
    mulitiply(color) {
        return this.multiply(color);
    }
    /**
     * Screens a color by another, results in a lighter color
     *
     * @param color  The other color
     */
    screen(color) {
        const color1 = color.invert();
        const color2 = color.invert();
        return color1.multiply(color2).invert();
    }
    /**
     * Inverts the current color
     */
    invert() {
        return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
    }
    /**
     * Averages the current color with another
     *
     * @param color  The other color
     */
    average(color) {
        const newR = (color.r + this.r) / 2;
        const newG = (color.g + this.g) / 2;
        const newB = (color.b + this.b) / 2;
        const newA = (color.a + this.a) / 2;
        return new Color(newR, newG, newB, newA);
    }
    /**
     * Returns a CSS string representation of a color.
     *
     * @param format Color representation, accepts: rgb, hsl, or hex
     */
    toString(format = 'rgb') {
        switch (format) {
            case 'rgb':
                return this.toRGBA();
            case 'hsl':
                return this.toHSLA();
            case 'hex':
                return this.toHex();
            default:
                throw new Error('Invalid Color format');
        }
    }
    /**
     * Returns Hex Value of a color component
     * @param c color component
     * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     */
    _componentToHex(c) {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
    /**
     * Return Hex representation of a color.
     */
    toHex() {
        return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
    }
    /**
     * Return RGBA representation of a color.
     */
    toRGBA() {
        const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
        if (this.a !== undefined || this.a !== null) {
            return 'rgba(' + result + ', ' + String(this.a) + ')';
        }
        return 'rgb(' + result + ')';
    }
    /**
     * Return HSLA representation of a color.
     */
    toHSLA() {
        return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
    }
    /**
     * Returns a CSS string representation of a color.
     */
    fillStyle() {
        return this.toString();
    }
    /**
     * Returns a clone of the current color.
     */
    clone() {
        return new Color(this.r, this.g, this.b, this.a);
    }
    /**
     * Black (#000000)
     */
    static get Black() {
        return Color.fromHex('#000000');
    }
    /**
     * White (#FFFFFF)
     */
    static get White() {
        return Color.fromHex('#FFFFFF');
    }
    /**
     * Gray (#808080)
     */
    static get Gray() {
        return Color.fromHex('#808080');
    }
    /**
     * Light gray (#D3D3D3)
     */
    static get LightGray() {
        return Color.fromHex('#D3D3D3');
    }
    /**
     * Dark gray (#A9A9A9)
     */
    static get DarkGray() {
        return Color.fromHex('#A9A9A9');
    }
    /**
     * Yellow (#FFFF00)
     */
    static get Yellow() {
        return Color.fromHex('#FFFF00');
    }
    /**
     * Orange (#FFA500)
     */
    static get Orange() {
        return Color.fromHex('#FFA500');
    }
    /**
     * Red (#FF0000)
     */
    static get Red() {
        return Color.fromHex('#FF0000');
    }
    /**
     * Vermilion (#FF5B31)
     */
    static get Vermilion() {
        return Color.fromHex('#FF5B31');
    }
    /**
     * Vermilion (#FF5B31)
     * @obsolete Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0
     */
    static get Vermillion() {
        return Color.Vermilion;
    }
    /**
     * Rose (#FF007F)
     */
    static get Rose() {
        return Color.fromHex('#FF007F');
    }
    /**
     * Magenta (#FF00FF)
     */
    static get Magenta() {
        return Color.fromHex('#FF00FF');
    }
    /**
     * Violet (#7F00FF)
     */
    static get Violet() {
        return Color.fromHex('#7F00FF');
    }
    /**
     * Blue (#0000FF)
     */
    static get Blue() {
        return Color.fromHex('#0000FF');
    }
    /**
     * Azure (#007FFF)
     */
    static get Azure() {
        return Color.fromHex('#007FFF');
    }
    /**
     * Cyan (#00FFFF)
     */
    static get Cyan() {
        return Color.fromHex('#00FFFF');
    }
    /**
     * Viridian (#59978F)
     */
    static get Viridian() {
        return Color.fromHex('#59978F');
    }
    /**
     * Green (#00FF00)
     */
    static get Green() {
        return Color.fromHex('#00FF00');
    }
    /**
     * Chartreuse (#7FFF00)
     */
    static get Chartreuse() {
        return Color.fromHex('#7FFF00');
    }
    /**
     * Transparent (#FFFFFF00)
     */
    static get Transparent() {
        return Color.fromHex('#FFFFFF00');
    }
}
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_0__["obsolete"])({ message: 'Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0' })
], Color.prototype, "mulitiply", null);
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_0__["obsolete"])({
        message: 'Alias for incorrect spelling used in older versions',
        alternateMethod: 'Vermilion'
    })
], Color, "Vermillion", null);
/**
 * Internal HSL Color representation
 *
 * http://en.wikipedia.org/wiki/HSL_and_HSV
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 */
class HSLColor {
    constructor(h, s, l, a) {
        this.h = h;
        this.s = s;
        this.l = l;
        this.a = a;
    }
    static hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
    }
    static fromRGBA(r, g, b, a) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s;
        const l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        }
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return new HSLColor(h, s, l, a);
    }
    toRGBA() {
        let r, g, b;
        if (this.s === 0) {
            r = g = b = this.l; // achromatic
        }
        else {
            const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
            const p = 2 * this.l - q;
            r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
            g = HSLColor.hue2rgb(p, q, this.h);
            b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
        }
        return new Color(r * 255, g * 255, b * 255, this.a);
    }
    toString() {
        const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
        return `hsla(${h}, ${s}, ${l}, ${a})`;
    }
}


/***/ }),

/***/ "./Drawing/Index.ts":
/*!**************************!*\
  !*** ./Drawing/Index.ts ***!
  \**************************/
/*! exports provided: Animation, Color, Polygon, Sprite, SpriteSheet, SpriteFont, CanvasDrawComponent, CanvasDrawingSystem, Effects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Animation */ "./Drawing/Animation.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return _Animation__WEBPACK_IMPORTED_MODULE_0__["Animation"]; });

/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Color */ "./Drawing/Color.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return _Color__WEBPACK_IMPORTED_MODULE_1__["Color"]; });

/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Polygon */ "./Drawing/Polygon.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return _Polygon__WEBPACK_IMPORTED_MODULE_2__["Polygon"]; });

/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Sprite */ "./Drawing/Sprite.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return _Sprite__WEBPACK_IMPORTED_MODULE_3__["Sprite"]; });

/* harmony import */ var _SpriteSheet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SpriteSheet */ "./Drawing/SpriteSheet.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpriteSheet", function() { return _SpriteSheet__WEBPACK_IMPORTED_MODULE_4__["SpriteSheet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpriteFont", function() { return _SpriteSheet__WEBPACK_IMPORTED_MODULE_4__["SpriteFont"]; });

/* harmony import */ var _CanvasDrawComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CanvasDrawComponent */ "./Drawing/CanvasDrawComponent.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasDrawComponent", function() { return _CanvasDrawComponent__WEBPACK_IMPORTED_MODULE_5__["CanvasDrawComponent"]; });

/* harmony import */ var _CanvasDrawingSystem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CanvasDrawingSystem */ "./Drawing/CanvasDrawingSystem.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasDrawingSystem", function() { return _CanvasDrawingSystem__WEBPACK_IMPORTED_MODULE_6__["CanvasDrawingSystem"]; });

/* harmony import */ var _SpriteEffects__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SpriteEffects */ "./Drawing/SpriteEffects.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Effects", function() { return _SpriteEffects__WEBPACK_IMPORTED_MODULE_7__; });











/***/ }),

/***/ "./Drawing/Polygon.ts":
/*!****************************!*\
  !*** ./Drawing/Polygon.ts ***!
  \****************************/
/*! exports provided: Polygon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");

/**
 * Creates a closed polygon drawing given a list of [[Vector]]s.
 *
 * @warning Use sparingly as Polygons are performance intensive
 */
class Polygon {
    /**
     * @param points  The vectors to use to build the polygon in order
     */
    constructor(points) {
        /**
         * The width of the lines of the polygon
         */
        this.lineWidth = 5;
        /**
         * Indicates whether the polygon is filled or not.
         */
        this.filled = false;
        this._points = [];
        this.anchor = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Zero;
        this.offset = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Zero;
        this.rotation = 0;
        this.scale = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].One;
        this.opacity = 1;
        this._points = points;
        const minX = this._points.reduce((prev, curr) => {
            return Math.min(prev, curr.x);
        }, 0);
        const maxX = this._points.reduce((prev, curr) => {
            return Math.max(prev, curr.x);
        }, 0);
        this.drawWidth = maxX - minX;
        const minY = this._points.reduce((prev, curr) => {
            return Math.min(prev, curr.y);
        }, 0);
        const maxY = this._points.reduce((prev, curr) => {
            return Math.max(prev, curr.y);
        }, 0);
        this.drawHeight = maxY - minY;
        this.height = this.drawHeight;
        this.width = this.drawWidth;
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    addEffect() {
        // not supported on polygons
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    removeEffect() {
        // not supported on polygons
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    clearEffects() {
        // not supported on polygons
    }
    reset() {
        //pass
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const { ctx, x, y, rotation, drawWidth, drawHeight, anchor, offset, opacity, flipHorizontal, flipVertical } = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.drawWidth, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.drawHeight, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, offset: (_g = options.offset) !== null && _g !== void 0 ? _g : this.offset, opacity: (_h = options.opacity) !== null && _h !== void 0 ? _h : this.opacity });
        const xpoint = drawWidth * anchor.x + offset.x + x;
        const ypoint = drawHeight * anchor.y + offset.y + y;
        ctx.save();
        ctx.translate(xpoint, ypoint);
        ctx.scale(this.scale.x, this.scale.y);
        ctx.rotate(rotation);
        ctx.beginPath();
        ctx.lineWidth = this.lineWidth;
        // Iterate through the supplied points and construct a 'polygon'
        const firstPoint = this._points[0];
        ctx.moveTo(firstPoint.x, firstPoint.y);
        let i = 0;
        const len = this._points.length;
        for (i; i < len; i++) {
            ctx.lineTo(this._points[i].x, this._points[i].y);
        }
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        if (this.filled) {
            ctx.fillStyle = this.fillColor.toString();
            ctx.fill();
        }
        ctx.strokeStyle = this.lineColor.toString();
        if (flipHorizontal) {
            ctx.translate(drawWidth, 0);
            ctx.scale(-1, 1);
        }
        if (flipVertical) {
            ctx.translate(0, drawHeight);
            ctx.scale(1, -1);
        }
        const oldAlpha = ctx.globalAlpha;
        ctx.globalAlpha = opacity !== null && opacity !== void 0 ? opacity : 1;
        ctx.stroke();
        ctx.globalAlpha = oldAlpha;
        ctx.restore();
    }
}


/***/ }),

/***/ "./Drawing/Sprite.ts":
/*!***************************!*\
  !*** ./Drawing/Sprite.ts ***!
  \***************************/
/*! exports provided: SpriteImpl, Sprite */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteImpl", function() { return SpriteImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony import */ var _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpriteEffects */ "./Drawing/SpriteEffects.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Color */ "./Drawing/Color.ts");
/* harmony import */ var _Resources_Texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Resources/Texture */ "./Resources/Texture.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Configurable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Configurable */ "./Configurable.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







/**
 * @hidden
 */
class SpriteImpl {
    /**
     * @param imageOrConfig  The backing image texture to build the Sprite, or Sprite option bag
     * @param x      The x position of the sprite
     * @param y      The y position of the sprite
     * @param width  The width of the sprite in pixels
     * @param height The height of the sprite in pixels
     */
    constructor(imageOrConfig, x, y, width, height) {
        this.x = 0;
        this.y = 0;
        this.rotation = 0.0;
        this.anchor = new _Algebra__WEBPACK_IMPORTED_MODULE_3__["Vector"](0.0, 0.0);
        this.offset = _Algebra__WEBPACK_IMPORTED_MODULE_3__["Vector"].Zero;
        this.scale = _Algebra__WEBPACK_IMPORTED_MODULE_3__["Vector"].One;
        this.logger = _Util_Log__WEBPACK_IMPORTED_MODULE_4__["Logger"].getInstance();
        /**
         * Draws the sprite flipped vertically
         */
        this.flipVertical = false;
        /**
         * Draws the sprite flipped horizontally
         */
        this.flipHorizontal = false;
        this.effects = [];
        this.width = 0;
        this.height = 0;
        this._spriteCanvas = null;
        this._spriteCtx = null;
        this._pixelData = null;
        this._pixelsLoaded = false;
        this._dirtyEffect = true;
        this._opacity = 1;
        let image = imageOrConfig;
        if (imageOrConfig && !(imageOrConfig instanceof _Resources_Texture__WEBPACK_IMPORTED_MODULE_2__["Texture"])) {
            x = imageOrConfig.x | 0;
            y = imageOrConfig.y | 0;
            width = imageOrConfig.width | 0;
            height = imageOrConfig.height | 0;
            image = imageOrConfig.image;
            if (!image) {
                const message = 'An image texture is required to construct a sprite';
                throw new Error(message);
            }
        }
        this.x = x || 0;
        this.y = y || 0;
        this._texture = image;
        this._spriteCanvas = document.createElement('canvas');
        this._spriteCanvas.width = width;
        this._spriteCanvas.height = height;
        this._spriteCtx = this._spriteCanvas.getContext('2d');
        this._initPixelsFromTexture();
        this.width = width;
        this.height = height;
    }
    get drawWidth() {
        return this.width * this.scale.x;
    }
    get drawHeight() {
        return this.height * this.scale.y;
    }
    _initPixelsFromTexture() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const image = yield this._texture.loaded;
                this.width = this.width || image.naturalWidth;
                this.height = this.height || image.naturalHeight;
                this._spriteCanvas.width = this._spriteCanvas.width || image.naturalWidth;
                this._spriteCanvas.height = this._spriteCanvas.height || image.naturalHeight;
                this._loadPixels();
                this._dirtyEffect = true;
            }
            catch (e) {
                this.logger.error('Error loading texture ', this._texture.path, e);
            }
        });
    }
    _loadPixels() {
        if (this._texture.isLoaded() && !this._pixelsLoaded) {
            const naturalWidth = this._texture.image.naturalWidth || 0;
            const naturalHeight = this._texture.image.naturalHeight || 0;
            if (this.width > naturalWidth) {
                this.logger.warn(`The sprite width ${this.width} exceeds the width 
                              ${naturalWidth} of the backing texture ${this._texture.path}`);
            }
            if (this.width <= 0 || naturalWidth <= 0) {
                throw new Error(`The width of a sprite cannot be 0 or negative, sprite width: ${this.width}, original width: ${naturalWidth}`);
            }
            if (this.height > naturalHeight) {
                this.logger.warn(`The sprite height ${this.height} exceeds the height 
                              ${naturalHeight} of the backing texture ${this._texture.path}`);
            }
            if (this.height <= 0 || naturalHeight <= 0) {
                throw new Error(`The height of a sprite cannot be 0 or negative, sprite height: ${this.height}, original height: ${naturalHeight}`);
            }
            this._flushTexture();
            this._pixelsLoaded = true;
        }
    }
    _flushTexture() {
        const naturalWidth = this._texture.image.naturalWidth || 0;
        const naturalHeight = this._texture.image.naturalHeight || 0;
        this._spriteCtx.clearRect(0, 0, this.width, this.height);
        this._spriteCtx.drawImage(this._texture.image, Object(_Util_Util__WEBPACK_IMPORTED_MODULE_5__["clamp"])(this.x, 0, naturalWidth), Object(_Util_Util__WEBPACK_IMPORTED_MODULE_5__["clamp"])(this.y, 0, naturalHeight), Object(_Util_Util__WEBPACK_IMPORTED_MODULE_5__["clamp"])(this.width, 0, naturalWidth), Object(_Util_Util__WEBPACK_IMPORTED_MODULE_5__["clamp"])(this.height, 0, naturalHeight), 0, 0, this.width, this.height);
    }
    /**
     * Applies the [[Opacity]] effect to a sprite, setting the alpha of all pixels to a given value
     */
    opacity(value) {
        this._opacity = value;
    }
    /**
     * Applies the [[Grayscale]] effect to a sprite, removing color information.
     */
    grayscale() {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Grayscale"]());
    }
    /**
     * Applies the [[Invert]] effect to a sprite, inverting the pixel colors.
     */
    invert() {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Invert"]());
    }
    /**
     * Applies the [[Fill]] effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
     */
    fill(color) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Fill"](color));
    }
    /**
     * Applies the [[Colorize]] effect to a sprite, changing the color channels of all pixels to be the average of the original color
     * and the provided color.
     */
    colorize(color) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Colorize"](color));
    }
    /**
     * Applies the [[Lighten]] effect to a sprite, changes the lightness of the color according to HSL
     */
    lighten(factor = 0.1) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Lighten"](factor));
    }
    /**
     * Applies the [[Darken]] effect to a sprite, changes the darkness of the color according to HSL
     */
    darken(factor = 0.1) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Darken"](factor));
    }
    /**
     * Applies the [[Saturate]] effect to a sprite, saturates the color according to HSL
     */
    saturate(factor = 0.1) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Saturate"](factor));
    }
    /**
     * Applies the [[Desaturate]] effect to a sprite, desaturates the color according to HSL
     */
    desaturate(factor = 0.1) {
        this.addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_0__["Desaturate"](factor));
    }
    /**
     * Adds a new [[SpriteEffect]] to this drawing.
     * @param effect  Effect to add to the this drawing
     */
    addEffect(effect) {
        this.effects.push(effect);
        // We must check if the texture and the backing sprite pixels are loaded as well before
        // an effect can be applied
        if (!this._texture.isLoaded() || !this._pixelsLoaded) {
            this._dirtyEffect = true;
        }
        else {
            this._applyEffects();
        }
    }
    removeEffect(param) {
        let indexToRemove = -1;
        if (typeof param === 'number') {
            indexToRemove = param;
        }
        else {
            indexToRemove = this.effects.indexOf(param);
        }
        // bounds check
        if (indexToRemove < 0 || indexToRemove >= this.effects.length) {
            return;
        }
        this.effects.splice(indexToRemove, 1);
        // We must check if the texture and the backing sprite pixels are loaded as well before
        // an effect can be applied
        if (!this._texture.isLoaded() || !this._pixelsLoaded) {
            this._dirtyEffect = true;
        }
        else {
            this._applyEffects();
        }
    }
    _applyEffects() {
        this._flushTexture();
        if (this.effects.length > 0) {
            this._pixelData = this._spriteCtx.getImageData(0, 0, this.width, this.height);
            const len = this.effects.length;
            for (let i = 0; i < len; i++) {
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.effects[i].updatePixel(x, y, this._pixelData);
                    }
                }
            }
            this._spriteCtx.clearRect(0, 0, this.width, this.height);
            this._spriteCtx.putImageData(this._pixelData, 0, 0);
        }
        this._dirtyEffect = false;
    }
    /**
     * Clears all effects from the drawing and return it to its original state.
     */
    clearEffects() {
        this.effects.length = 0;
        this._applyEffects();
    }
    /**
     * Resets the internal state of the drawing (if any)
     */
    reset() {
        // do nothing
    }
    debugDraw(ctx, x, y) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.rotation);
        const xpoint = this.drawWidth * this.anchor.x;
        const ypoint = this.drawHeight * this.anchor.y;
        ctx.strokeStyle = _Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Black.toString();
        ctx.strokeRect(-xpoint, -ypoint, this.drawWidth, this.drawHeight);
        ctx.restore();
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const { ctx, x, y, rotation, drawWidth, drawHeight, anchor, offset, opacity, flipHorizontal, flipVertical } = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.drawWidth, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.drawHeight, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, offset: (_g = options.offset) !== null && _g !== void 0 ? _g : this.offset, opacity: (_h = options.opacity) !== null && _h !== void 0 ? _h : this._opacity });
        if (this._dirtyEffect) {
            this._applyEffects();
        }
        // calculating current dimensions
        ctx.save();
        const xpoint = drawWidth * anchor.x + offset.x;
        const ypoint = drawHeight * anchor.y + offset.y;
        ctx.translate(x, y);
        ctx.rotate(rotation);
        if (flipHorizontal) {
            ctx.translate(drawWidth, 0);
            ctx.scale(-1, 1);
        }
        if (flipVertical) {
            ctx.translate(0, drawHeight);
            ctx.scale(1, -1);
        }
        const oldAlpha = ctx.globalAlpha;
        ctx.globalAlpha = opacity !== null && opacity !== void 0 ? opacity : 1;
        ctx.drawImage(this._spriteCanvas, 0, 0, this.width, this.height, -xpoint, -ypoint, drawWidth, drawHeight);
        ctx.globalAlpha = oldAlpha;
        ctx.restore();
    }
    /**
     * Produces a copy of the current sprite
     */
    clone() {
        const result = new Sprite(this._texture, this.x, this.y, this.width, this.height);
        result.scale = this.scale.clone();
        result.rotation = this.rotation;
        result.flipHorizontal = this.flipHorizontal;
        result.flipVertical = this.flipVertical;
        const len = this.effects.length;
        for (let i = 0; i < len; i++) {
            result.addEffect(this.effects[i]);
        }
        return result;
    }
}
/**
 * A [[Sprite]] is one of the main drawing primitives. It is responsible for drawing
 * images or parts of images from a [[Texture]] resource to the screen.
 */
class Sprite extends Object(_Configurable__WEBPACK_IMPORTED_MODULE_6__["Configurable"])(SpriteImpl) {
    constructor(imageOrConfig, x, y, width, height) {
        super(imageOrConfig, x, y, width, height);
    }
}


/***/ }),

/***/ "./Drawing/SpriteEffects.ts":
/*!**********************************!*\
  !*** ./Drawing/SpriteEffects.ts ***!
  \**********************************/
/*! exports provided: Grayscale, Invert, Opacity, Colorize, Lighten, Darken, Saturate, Desaturate, Fill */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Grayscale", function() { return Grayscale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Invert", function() { return Invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Opacity", function() { return Opacity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Colorize", function() { return Colorize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lighten", function() { return Lighten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Darken", function() { return Darken; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Saturate", function() { return Saturate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Desaturate", function() { return Desaturate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fill", function() { return Fill; });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color */ "./Drawing/Color.ts");
/**
 * These effects can be applied to any bitmap image but are mainly used
 * for [[Sprite]] effects or [[Animation]] effects.
 */
/**
 * @typedoc
 */

/**
 * Applies the "Grayscale" effect to a sprite, removing color information.
 */
class Grayscale {
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
        pixel[firstPixel + 0] = avg;
        pixel[firstPixel + 1] = avg;
        pixel[firstPixel + 2] = avg;
    }
}
/**
 * Applies the "Invert" effect to a sprite, inverting the pixel colors.
 */
class Invert {
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
        pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
        pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
    }
}
/**
 * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
 */
class Opacity {
    /**
     * @param opacity  The new opacity of the sprite from 0-1.0
     */
    constructor(opacity) {
        this.opacity = opacity;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 3] = Math.round(this.opacity * pixel[firstPixel + 3]);
        }
    }
}
/**
 * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
 * average of the original color and the provided color
 */
class Colorize {
    /**
     * @param color  The color to apply to the sprite
     */
    constructor(color) {
        this.color = color;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
            pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
            pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
        }
    }
}
/**
 * Applies the "Lighten" effect to a sprite, changes the lightness of the color according to HSL
 */
class Lighten {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = _Color__WEBPACK_IMPORTED_MODULE_0__["Color"].fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).lighten(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
}
/**
 * Applies the "Darken" effect to a sprite, changes the darkness of the color according to HSL
 */
class Darken {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = _Color__WEBPACK_IMPORTED_MODULE_0__["Color"].fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).darken(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
}
/**
 * Applies the "Saturate" effect to a sprite, saturates the color according to HSL
 */
class Saturate {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = _Color__WEBPACK_IMPORTED_MODULE_0__["Color"].fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).saturate(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
}
/**
 * Applies the "Desaturate" effect to a sprite, desaturates the color according to HSL
 */
class Desaturate {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = _Color__WEBPACK_IMPORTED_MODULE_0__["Color"].fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).desaturate(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
}
/**
 * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
 * a given color
 */
class Fill {
    /**
     * @param color  The color to apply to the sprite
     */
    constructor(color) {
        this.color = color;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 0] = this.color.r;
            pixel[firstPixel + 1] = this.color.g;
            pixel[firstPixel + 2] = this.color.b;
        }
    }
}


/***/ }),

/***/ "./Drawing/SpriteSheet.ts":
/*!********************************!*\
  !*** ./Drawing/SpriteSheet.ts ***!
  \********************************/
/*! exports provided: SpriteSheetImpl, SpriteSheet, SpriteFontImpl, SpriteFont */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteSheetImpl", function() { return SpriteSheetImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteSheet", function() { return SpriteSheet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteFontImpl", function() { return SpriteFontImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteFont", function() { return SpriteFont; });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./Drawing/Sprite.ts");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation */ "./Drawing/Animation.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Color */ "./Drawing/Color.ts");
/* harmony import */ var _SpriteEffects__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SpriteEffects */ "./Drawing/SpriteEffects.ts");
/* harmony import */ var _Resources_Texture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Resources/Texture */ "./Resources/Texture.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Label__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Label */ "./Label.ts");
/* harmony import */ var _Configurable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Configurable */ "./Configurable.ts");








/**
 * @hidden
 */
class SpriteSheetImpl {
    /**
     * @param imageOrConfigOrSprites The backing image texture to build the SpriteSheet, option bag, or sprite list
     * @param columns   The number of columns in the image texture
     * @param rows      The number of rows in the image texture
     * @param spWidth   The width of each individual sprite in pixels
     * @param spHeight  The height of each individual sprite in pixels
     * @param spacing   The spacing between every sprite in a spritesheet
     */
    constructor(imageOrConfigOrSprites, columns, rows, spWidth, spHeight, spacing) {
        this.sprites = [];
        this.image = null;
        this.columns = 0;
        this.rows = 0;
        this.spWidth = 0;
        this.spHeight = 0;
        this.spacing = 0;
        let loadFromImage = false;
        if (imageOrConfigOrSprites instanceof Array) {
            this.sprites = imageOrConfigOrSprites;
        }
        else {
            if (imageOrConfigOrSprites && !(imageOrConfigOrSprites instanceof _Resources_Texture__WEBPACK_IMPORTED_MODULE_4__["Texture"])) {
                this.columns = imageOrConfigOrSprites.columns;
                this.rows = imageOrConfigOrSprites.rows;
                this.spWidth = imageOrConfigOrSprites.spWidth;
                this.spHeight = imageOrConfigOrSprites.spHeight;
                this.image = imageOrConfigOrSprites.image;
                this.spacing = imageOrConfigOrSprites.spacing || 0;
            }
            else {
                this.image = imageOrConfigOrSprites;
                this.columns = columns;
                this.rows = rows;
                this.spWidth = spWidth;
                this.spHeight = spHeight;
                this.spacing = spacing || 0;
            }
            this.sprites = new Array(this.columns * this.rows);
            loadFromImage = true;
        }
        // Inspect actual image dimensions with preloading
        if (this.image instanceof _Resources_Texture__WEBPACK_IMPORTED_MODULE_4__["Texture"]) {
            let isWidthError = false;
            let isHeightError = false;
            if (this.image.isLoaded()) {
                isWidthError = this.spWidth * this.columns > this.image.image.naturalWidth;
                isHeightError = this.spHeight * this.rows > this.image.image.naturalHeight;
                if (isWidthError) {
                    throw new RangeError(`SpriteSheet specified is wider, ` +
                        `${this.columns} cols x ${this.spWidth} pixels > ${this.image.image.naturalWidth} ` +
                        `pixels than image width`);
                }
                if (isHeightError) {
                    throw new RangeError(`SpriteSheet specified is taller, ` +
                        `${this.rows} rows x ${this.spHeight} pixels > ${this.image.image.naturalHeight} ` +
                        `pixels than image height`);
                }
            }
        }
        if (loadFromImage) {
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.columns; j++) {
                    this.sprites[j + i * this.columns] = new _Sprite__WEBPACK_IMPORTED_MODULE_0__["Sprite"](this.image, j * this.spWidth + this.spacing * j + this.spacing, i * this.spHeight + this.spacing * i + this.spacing, this.spWidth, this.spHeight);
                }
            }
        }
    }
    /**
     * Create an animation from the this SpriteSheet by listing out the
     * sprite indices. Sprites are organized in row major order in the SpriteSheet.
     * @param engine   Reference to the current game [[Engine]]
     * @param indices  An array of sprite indices to use in the animation
     * @param speed    The number in milliseconds to display each frame in the animation
     */
    getAnimationByIndices(engine, indices, speed) {
        let images = indices.map((index) => {
            return this.sprites[index];
        });
        images = images.map(function (i) {
            return i.clone();
        });
        return new _Animation__WEBPACK_IMPORTED_MODULE_1__["Animation"](engine, images, speed);
    }
    /**
     * Create an animation from the this SpriteSheet by specifying the range of
     * images with the beginning (inclusive) and ending (exclusive) index
     * For example `getAnimationBetween(engine, 0, 5, 200)` returns an animation with 5 frames.
     * @param engine      Reference to the current game Engine
     * @param beginIndex  The index to start taking frames (inclusive)
     * @param endIndex    The index to stop taking frames (exclusive)
     * @param speed       The number in milliseconds to display each frame in the animation
     */
    getAnimationBetween(engine, beginIndex, endIndex, speed) {
        let images = this.sprites.slice(beginIndex, endIndex);
        images = images.map(function (i) {
            return i.clone();
        });
        return new _Animation__WEBPACK_IMPORTED_MODULE_1__["Animation"](engine, images, speed);
    }
    /**
     * Treat the entire SpriteSheet as one animation, organizing the frames in
     * row major order.
     * @param engine  Reference to the current game [[Engine]]
     * @param speed   The number in milliseconds to display each frame the animation
     */
    getAnimationForAll(engine, speed) {
        const sprites = this.sprites.map(function (i) {
            return i.clone();
        });
        return new _Animation__WEBPACK_IMPORTED_MODULE_1__["Animation"](engine, sprites, speed);
    }
    /**
     * Retrieve a specific sprite from the SpriteSheet by its index. Sprites are organized
     * in row major order in the SpriteSheet.
     * @param index  The index of the sprite
     */
    getSprite(index) {
        if (index >= 0 && index < this.sprites.length) {
            return this.sprites[index];
        }
        else {
            throw new Error('Invalid index: ' + index);
        }
    }
    /**
     * Get an animation with bespoke sprite coordinates. This is useful if the SpriteSheet is
     * packed and not a uniform width or height. The resulting [[Animation]] will have the height and width of the
     * largest dimension (width, height) from among the sprite coordinates
     * @param engine
     * @param spriteCoordinates
     * @param speed
     */
    getAnimationByCoords(engine, spriteCoordinates, speed) {
        let maxWidth = 0;
        let maxHeight = 0;
        const sprites = new Array(spriteCoordinates.length);
        for (let i = 0; i < spriteCoordinates.length; i++) {
            const coord = spriteCoordinates[i];
            // no need to pass image again if using a spritesheet
            coord.image = coord.image || this.image;
            maxWidth = Math.max(maxWidth, coord.drawWidth);
            maxHeight = Math.max(maxHeight, coord.drawHeight);
            sprites[i] = new _Sprite__WEBPACK_IMPORTED_MODULE_0__["Sprite"](coord);
        }
        const anim = new _Animation__WEBPACK_IMPORTED_MODULE_1__["Animation"](engine, sprites, speed);
        anim.drawWidth = maxWidth;
        anim.drawHeight = maxHeight;
        return anim;
    }
}
/**
 * Sprite sheets are a useful mechanism for slicing up image resources into
 * separate sprites or for generating in game animations. [[Sprite|Sprites]] are organized
 * in row major order in the [[SpriteSheet]].
 */
class SpriteSheet extends Object(_Configurable__WEBPACK_IMPORTED_MODULE_7__["Configurable"])(SpriteSheetImpl) {
    constructor(imageOrConfigOrSprites, columns, rows, spWidth, spHeight, spacing) {
        super(imageOrConfigOrSprites, columns, rows, spWidth, spHeight, spacing);
    }
}
class SpriteFontImpl extends SpriteSheet {
    /**
     * @param imageOrConfig   The backing image texture to build the SpriteFont or the sprite font option bag
     * @param alphabet        A string representing all the characters in the image, in row major order.
     * @param caseInsensitive  Indicate whether this font takes case into account
     * @param columns         The number of columns of characters in the image
     * @param rows            The number of rows of characters in the image
     * @param spWidth         The width of each character in pixels
     * @param spHeight        The height of each character in pixels
     */
    constructor(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight, spacing) {
        super(imageOrConfig instanceof _Resources_Texture__WEBPACK_IMPORTED_MODULE_4__["Texture"] ?
            {
                image: imageOrConfig,
                spWidth: spWidth,
                spHeight: spHeight,
                rows: rows,
                columns: columns,
                spacing: spacing || 0
            }
            : imageOrConfig);
        this._currentColor = _Color__WEBPACK_IMPORTED_MODULE_2__["Color"].Black;
        this._currentOpacity = 1.0;
        this._sprites = {};
        // text shadow
        this._textShadowOn = false;
        this._textShadowDirty = true;
        this._textShadowColor = _Color__WEBPACK_IMPORTED_MODULE_2__["Color"].Black;
        this._textShadowSprites = {};
        this._shadowOffsetX = 5;
        this._shadowOffsetY = 5;
        if (imageOrConfig && !(imageOrConfig instanceof _Resources_Texture__WEBPACK_IMPORTED_MODULE_4__["Texture"])) {
            alphabet = imageOrConfig.alphabet;
            caseInsensitive = imageOrConfig.caseInsensitive;
        }
        this._alphabet = alphabet;
        this._caseInsensitive = caseInsensitive;
        this._sprites = this.getTextSprites();
    }
    /**
     * Returns a dictionary that maps each character in the alphabet to the appropriate [[Sprite]].
     */
    getTextSprites() {
        const lookup = {};
        for (let i = 0; i < this._alphabet.length; i++) {
            let char = this._alphabet[i];
            if (this._caseInsensitive) {
                char = char.toLowerCase();
            }
            lookup[char] = this.sprites[i].clone();
        }
        return lookup;
    }
    /**
     * Sets the text shadow for sprite fonts
     * @param offsetX      The x offset in pixels to place the shadow
     * @param offsetY      The y offset in pixels to place the shadow
     * @param shadowColor  The color of the text shadow
     */
    setTextShadow(offsetX, offsetY, shadowColor) {
        this._textShadowOn = true;
        this._shadowOffsetX = offsetX;
        this._shadowOffsetY = offsetY;
        this._textShadowColor = shadowColor.clone();
        this._textShadowDirty = true;
        for (const character in this._sprites) {
            this._textShadowSprites[character] = this._sprites[character].clone();
        }
    }
    /**
     * Toggles text shadows on or off
     */
    useTextShadow(on) {
        this._textShadowOn = on;
        if (on) {
            this.setTextShadow(5, 5, this._textShadowColor);
        }
    }
    /**
     * Draws the current sprite font
     */
    draw(ctx, text, x, y, options) {
        options = this._parseOptions(options);
        if (this._currentColor.toString() !== options.color.toString() || this._currentOpacity !== options.opacity) {
            this._currentOpacity = options.opacity;
            this._currentColor = options.color;
            for (const char in this._sprites) {
                this._sprites[char].clearEffects();
                this._sprites[char].fill(options.color);
                this._sprites[char].opacity(options.opacity);
            }
        }
        if (this._textShadowOn && this._textShadowDirty && this._textShadowColor) {
            for (const characterShadow in this._textShadowSprites) {
                this._textShadowSprites[characterShadow].clearEffects();
                this._textShadowSprites[characterShadow].addEffect(new _SpriteEffects__WEBPACK_IMPORTED_MODULE_3__["Fill"](this._textShadowColor.clone()));
            }
            this._textShadowDirty = false;
        }
        // find the current length of text in pixels
        const sprite = this.sprites[0];
        // find the current height fo the text in pixels
        const height = sprite.drawHeight;
        // calculate appropriate scale for font size
        const scale = options.fontSize / height;
        const length = text.length * sprite.drawWidth * scale + text.length * options.letterSpacing;
        let currX = x;
        if (options.textAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["TextAlign"].Left || options.textAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["TextAlign"].Start) {
            currX = x;
        }
        else if (options.textAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["TextAlign"].Right || options.textAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["TextAlign"].End) {
            currX = x - length;
        }
        else if (options.textAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["TextAlign"].Center) {
            currX = x - length / 2;
        }
        let currY = y - height * scale;
        if (options.baseAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["BaseAlign"].Top || options.baseAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["BaseAlign"].Hanging) {
            currY = y;
        }
        else if (options.baseAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["BaseAlign"].Ideographic ||
            options.baseAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["BaseAlign"].Bottom ||
            options.baseAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["BaseAlign"].Alphabetic) {
            currY = y - height * scale;
        }
        else if (options.baseAlign === _Label__WEBPACK_IMPORTED_MODULE_6__["BaseAlign"].Middle) {
            currY = y - (height * scale) / 2;
        }
        for (let i = 0; i < text.length; i++) {
            let character = text[i];
            if (this._caseInsensitive) {
                character = character.toLowerCase();
            }
            try {
                // if text shadow
                if (this._textShadowOn) {
                    this._textShadowSprites[character].scale.x = scale;
                    this._textShadowSprites[character].scale.y = scale;
                    this._textShadowSprites[character].draw(ctx, currX + this._shadowOffsetX, currY + this._shadowOffsetY);
                }
                const charSprite = this._sprites[character];
                charSprite.scale.x = scale;
                charSprite.scale.y = scale;
                charSprite.draw(ctx, currX, currY);
                currX += charSprite.drawWidth + options.letterSpacing;
            }
            catch (e) {
                _Util_Log__WEBPACK_IMPORTED_MODULE_5__["Logger"].getInstance().error(`SpriteFont Error drawing char ${character}`);
            }
        }
    }
    _parseOptions(options) {
        return {
            fontSize: options.fontSize || 10,
            letterSpacing: options.letterSpacing || 0,
            color: options.color || _Color__WEBPACK_IMPORTED_MODULE_2__["Color"].Black,
            textAlign: typeof options.textAlign === undefined ? _Label__WEBPACK_IMPORTED_MODULE_6__["TextAlign"].Left : options.textAlign,
            baseAlign: typeof options.baseAlign === undefined ? _Label__WEBPACK_IMPORTED_MODULE_6__["BaseAlign"].Bottom : options.baseAlign,
            maxWidth: options.maxWidth || -1,
            opacity: options.opacity || 0
        };
    }
}
/**
 * Sprite fonts are a used in conjunction with a [[Label]] to specify
 * a particular bitmap as a font. Note that some font features are not
 * supported by Sprite fonts.
 */
class SpriteFont extends Object(_Configurable__WEBPACK_IMPORTED_MODULE_7__["Configurable"])(SpriteFontImpl) {
    constructor(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight, spacing) {
        super(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight, spacing);
    }
}


/***/ }),

/***/ "./Engine.ts":
/*!*******************!*\
  !*** ./Engine.ts ***!
  \*******************/
/*! exports provided: ScrollPreventionMode, Engine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollPreventionMode", function() { return ScrollPreventionMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Engine", function() { return Engine; });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ */ "./index.ts");
/* harmony import */ var _Flags__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Flags */ "./Flags.ts");
/* harmony import */ var _Polyfill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Polyfill */ "./Polyfill.ts");
/* harmony import */ var _Screen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Screen */ "./Screen.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Actor */ "./Actor.ts");
/* harmony import */ var _Loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Loader */ "./Loader.ts");
/* harmony import */ var _Util_Detector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Util/Detector */ "./Util/Detector.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Scene */ "./Scene.ts");
/* harmony import */ var _Debug__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Debug */ "./Debug.ts");
/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Class */ "./Class.ts");
/* harmony import */ var _Input_Index__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Input/Index */ "./Input/Index.ts");
/* harmony import */ var _Util_Browser__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Util/Browser */ "./Util/Browser.ts");
/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Util/Decorators */ "./Util/Decorators.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



Object(_Polyfill__WEBPACK_IMPORTED_MODULE_2__["polyfill"])();













/**
 * Enum representing the different mousewheel event bubble prevention
 */
var ScrollPreventionMode;
(function (ScrollPreventionMode) {
    /**
     * Do not prevent any page scrolling
     */
    ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
    /**
     * Prevent page scroll if mouse is over the game canvas
     */
    ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
    /**
     * Prevent all page scrolling via mouse wheel
     */
    ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
})(ScrollPreventionMode || (ScrollPreventionMode = {}));
/**
 * The Excalibur Engine
 *
 * The [[Engine]] is the main driver for a game. It is responsible for
 * starting/stopping the game, maintaining state, transmitting events,
 * loading resources, and managing the scene.
 */
class Engine extends _Class__WEBPACK_IMPORTED_MODULE_12__["Class"] {
    /**
     * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,
     * the game will be rendered full screen (taking up all available browser window space).
     * You can customize the game rendering through [[EngineOptions]].
     *
     * Example:
     *
     * ```js
     * var game = new ex.Engine({
     *   width: 0, // the width of the canvas
     *   height: 0, // the height of the canvas
     *   enableCanvasTransparency: true, // the transparencySection of the canvas
     *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
     *   displayMode: ex.DisplayMode.FullScreen, // the display mode
     *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
     *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
     * });
     *
     * // call game.start, which is a Promise
     * game.start().then(function () {
     *   // ready, set, go!
     * });
     * ```
     */
    constructor(options) {
        var _a, _b, _c;
        super();
        this._hasStarted = false;
        /**
         * Gets or sets the list of post processors to apply at the end of drawing a frame (such as [[ColorBlindCorrector]])
         */
        this.postProcessors = [];
        /**
         * Contains all the scenes currently registered with Excalibur
         */
        this.scenes = {};
        this._animations = [];
        this._suppressPlayButton = false;
        /**
         * Indicates whether audio should be paused when the game is no longer visible.
         */
        this.pauseAudioWhenHidden = true;
        /**
         * Indicates whether the engine should draw with debug information
         */
        this._isDebug = false;
        this.debugColor = new _Drawing_Color__WEBPACK_IMPORTED_MODULE_9__["Color"](255, 255, 255);
        /**
         * Sets the Transparency for the engine.
         */
        this.enableCanvasTransparency = true;
        /**
         * The action to take when a fatal exception is thrown
         */
        this.onFatalException = (e) => {
            _Util_Log__WEBPACK_IMPORTED_MODULE_8__["Logger"].getInstance().fatal(e);
        };
        this._timescale = 1.0;
        this._isLoading = false;
        this._isInitialized = false;
        options = Object.assign(Object.assign({}, Engine._DEFAULT_ENGINE_OPTIONS), options);
        _Flags__WEBPACK_IMPORTED_MODULE_1__["Flags"].freeze();
        // Initialize browser events facade
        this.browser = new _Util_Browser__WEBPACK_IMPORTED_MODULE_14__["BrowserEvents"](window, document);
        // Check compatibility
        const detector = new _Util_Detector__WEBPACK_IMPORTED_MODULE_6__["Detector"]();
        if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {
            const message = document.createElement('div');
            message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
            document.body.appendChild(message);
            detector.failedTests.forEach(function (test) {
                const testMessage = document.createElement('div');
                testMessage.innerText = 'Browser feature missing ' + test;
                document.body.appendChild(testMessage);
            });
            if (options.canvasElementId) {
                const canvas = document.getElementById(options.canvasElementId);
                if (canvas) {
                    canvas.parentElement.removeChild(canvas);
                }
            }
            return;
        }
        else {
            this._compatible = true;
        }
        // Use native console API for color fun
        // eslint-disable-next-line no-console
        if (console.log && !options.suppressConsoleBootMessage) {
            // eslint-disable-next-line no-console
            console.log(`%cPowered by Excalibur.js (v${___WEBPACK_IMPORTED_MODULE_0__["EX_VERSION"]})`, 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
            // eslint-disable-next-line no-console
            console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
            // eslint-disable-next-line no-console
            console.log('Visit', 'http://excaliburjs.com', 'for more information');
        }
        // Suppress play button
        if (options.suppressPlayButton) {
            this._suppressPlayButton = true;
        }
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_8__["Logger"].getInstance();
        // If debug is enabled, let's log browser features to the console.
        if (this._logger.defaultLevel === _Util_Log__WEBPACK_IMPORTED_MODULE_8__["LogLevel"].Debug) {
            detector.logBrowserFeatures();
        }
        this._logger.debug('Building engine...');
        this.canvasElementId = options.canvasElementId;
        if (options.canvasElementId) {
            this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
            this.canvas = document.getElementById(options.canvasElementId);
        }
        else if (options.canvasElement) {
            this._logger.debug('Using Canvas element specified:', options.canvasElement);
            this.canvas = options.canvasElement;
        }
        else {
            this._logger.debug('Using generated canvas element');
            this.canvas = document.createElement('canvas');
        }
        let displayMode = (_a = options.displayMode) !== null && _a !== void 0 ? _a : _Screen__WEBPACK_IMPORTED_MODULE_3__["DisplayMode"].Fixed;
        if ((options.width && options.height) || options.viewport) {
            if (options.displayMode === undefined) {
                displayMode = _Screen__WEBPACK_IMPORTED_MODULE_3__["DisplayMode"].Fixed;
            }
            this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
        }
        else if (!options.displayMode) {
            this._logger.debug('Engine viewport is fullscreen');
            displayMode = _Screen__WEBPACK_IMPORTED_MODULE_3__["DisplayMode"].FullScreen;
        }
        // eslint-disable-next-line
        this.ctx = this.canvas.getContext('2d', { alpha: this.enableCanvasTransparency });
        this.screen = new _Screen__WEBPACK_IMPORTED_MODULE_3__["Screen"]({
            canvas: this.canvas,
            context: this.ctx,
            antialiasing: (_b = options.antialiasing) !== null && _b !== void 0 ? _b : true,
            browser: this.browser,
            viewport: (_c = options.viewport) !== null && _c !== void 0 ? _c : { width: options.width, height: options.height },
            resolution: options.resolution,
            displayMode,
            position: options.position,
            pixelRatio: options.suppressHiDPIScaling ? 1 : null
        });
        this.screen.applyResolutionAndViewport();
        if (options.backgroundColor) {
            this.backgroundColor = options.backgroundColor.clone();
        }
        this.enableCanvasTransparency = options.enableCanvasTransparency;
        this._loader = new _Loader__WEBPACK_IMPORTED_MODULE_5__["Loader"]();
        this.debug = new _Debug__WEBPACK_IMPORTED_MODULE_11__["Debug"](this);
        this._initialize(options);
        this.rootScene = this.currentScene = new _Scene__WEBPACK_IMPORTED_MODULE_10__["Scene"](this);
        this.addScene('root', this.rootScene);
        this.goToScene('root');
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.screen.canvasWidth;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.screen.halfCanvasWidth;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.screen.canvasHeight;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.screen.halfCanvasHeight;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        return this.screen.drawWidth;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.screen.halfDrawWidth;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        return this.screen.drawHeight;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.screen.halfDrawHeight;
    }
    /**
     * Returns whether excalibur detects the current screen to be HiDPI
     */
    get isHiDpi() {
        return this.screen.isHiDpi;
    }
    /**
     * Access [[stats]] that holds frame statistics.
     */
    get stats() {
        return this.debug.stats;
    }
    /**
     * Indicates whether the engine is set to fullscreen or not
     */
    get isFullscreen() {
        return this.screen.isFullScreen;
    }
    /**
     * Indicates the current [[DisplayMode]] of the engine.
     */
    get displayMode() {
        return this.screen.displayMode;
    }
    /**
     * Returns the calculated pixel ration for use in rendering
     */
    get pixelRatio() {
        return this.screen.pixelRatio;
    }
    get isDebug() {
        return this._isDebug;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     */
    getWorldBounds() {
        return this.screen.getWorldBounds();
    }
    /**
     * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
     */
    get timescale() {
        return this._timescale;
    }
    /**
     * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
     * when using time-based movement.
     */
    set timescale(value) {
        if (value <= 0) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_8__["Logger"].getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');
            return;
        }
        this._timescale = value;
    }
    /**
     * Plays a sprite animation on the screen at the specified `x` and `y`
     * (in game coordinates, not screen pixels). These animations play
     * independent of actors, and will be cleaned up internally as soon
     * as they are complete. Note animations that loop will never be
     * cleaned up.
     *
     * @param animation  Animation to play
     * @param x          x game coordinate to play the animation
     * @param y          y game coordinate to play the animation
     * @deprecated
     */
    playAnimation(animation, x, y) {
        this._animations.push(new AnimationNode(animation, x, y));
    }
    /**
     * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap
     * will be drawn and updated.
     */
    addTileMap(tileMap) {
        this.currentScene.addTileMap(tileMap);
    }
    /**
     * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.
     */
    removeTileMap(tileMap) {
        this.currentScene.removeTileMap(tileMap);
    }
    /**
     * Adds a [[Timer]] to the [[currentScene]].
     * @param timer  The timer to add to the [[currentScene]].
     */
    addTimer(timer) {
        return this.currentScene.addTimer(timer);
    }
    /**
     * Removes a [[Timer]] from the [[currentScene]].
     * @param timer  The timer to remove to the [[currentScene]].
     */
    removeTimer(timer) {
        return this.currentScene.removeTimer(timer);
    }
    /**
     * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
     * would levels or menus.
     *
     * @param key  The name of the scene, must be unique
     * @param scene The scene to add to the engine
     */
    addScene(key, scene) {
        if (this.scenes[key]) {
            this._logger.warn('Scene', key, 'already exists overwriting');
        }
        this.scenes[key] = scene;
    }
    /**
     * @internal
     */
    removeScene(entity) {
        if (entity instanceof _Scene__WEBPACK_IMPORTED_MODULE_10__["Scene"]) {
            // remove scene
            for (const key in this.scenes) {
                if (this.scenes.hasOwnProperty(key)) {
                    if (this.scenes[key] === entity) {
                        delete this.scenes[key];
                    }
                }
            }
        }
        if (typeof entity === 'string') {
            // remove scene
            delete this.scenes[entity];
        }
    }
    add(entity) {
        if (arguments.length === 2) {
            this.addScene(arguments[0], arguments[1]);
        }
        this.currentScene.add(entity);
    }
    remove(entity) {
        if (entity instanceof _Actor__WEBPACK_IMPORTED_MODULE_4__["Actor"]) {
            this.currentScene.remove(entity);
        }
        if (entity instanceof _Scene__WEBPACK_IMPORTED_MODULE_10__["Scene"]) {
            this.removeScene(entity);
        }
        if (typeof entity === 'string') {
            this.removeScene(entity);
        }
    }
    /**
     * Changes the currently updating and drawing scene to a different,
     * named scene. Calls the [[Scene]] lifecycle events.
     * @param key  The key of the scene to transition to.
     */
    goToScene(key) {
        if (this.scenes[key]) {
            const oldScene = this.currentScene;
            const newScene = this.scenes[key];
            this._logger.debug('Going to scene:', key);
            // only deactivate when initialized
            if (this.currentScene.isInitialized) {
                this.currentScene._deactivate.call(this.currentScene, [oldScene, newScene]);
                this.currentScene.eventDispatcher.emit('deactivate', new _Events__WEBPACK_IMPORTED_MODULE_7__["DeactivateEvent"](newScene, this.currentScene));
            }
            // set current scene to new one
            this.currentScene = newScene;
            this.screen.setCurrentCamera(newScene.camera);
            // initialize the current scene if has not been already
            this.currentScene._initialize(this);
            this.currentScene._activate.call(this.currentScene, [oldScene, newScene]);
            this.currentScene.eventDispatcher.emit('activate', new _Events__WEBPACK_IMPORTED_MODULE_7__["ActivateEvent"](oldScene, this.currentScene));
        }
        else {
            this._logger.error('Scene', key, 'does not exist!');
        }
    }
    /**
     * Transforms the current x, y from screen coordinates to world coordinates
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        return this.screen.screenToWorldCoordinates(point);
    }
    /**
     * Transforms a world coordinate, to a screen coordinate
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        return this.screen.worldToScreenCoordinates(point);
    }
    /**
     * Initializes the internal canvas, rendering context, display mode, and native event listeners
     */
    _initialize(options) {
        this.pageScrollPreventionMode = options.scrollPreventionMode;
        // initialize inputs
        this.input = {
            keyboard: new _Input_Index__WEBPACK_IMPORTED_MODULE_13__["Keyboard"](),
            pointers: new _Input_Index__WEBPACK_IMPORTED_MODULE_13__["Pointers"](this),
            gamepads: new _Input_Index__WEBPACK_IMPORTED_MODULE_13__["Gamepads"]()
        };
        this.input.keyboard.init();
        this.input.pointers.init(options && options.pointerScope === _Input_Index__WEBPACK_IMPORTED_MODULE_13__["PointerScope"].Document ? document : this.canvas);
        this.input.gamepads.init();
        // Issue #385 make use of the visibility api
        // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
        let hidden, visibilityChange;
        if (typeof document.hidden !== 'undefined') {
            // Opera 12.10 and Firefox 18 and later support
            hidden = 'hidden';
            visibilityChange = 'visibilitychange';
        }
        else if ('msHidden' in document) {
            hidden = 'msHidden';
            visibilityChange = 'msvisibilitychange';
        }
        else if ('webkitHidden' in document) {
            hidden = 'webkitHidden';
            visibilityChange = 'webkitvisibilitychange';
        }
        this.browser.document.on(visibilityChange, () => {
            if (document[hidden]) {
                this.eventDispatcher.emit('hidden', new _Events__WEBPACK_IMPORTED_MODULE_7__["HiddenEvent"](this));
                this._logger.debug('Window hidden');
            }
            else {
                this.eventDispatcher.emit('visible', new _Events__WEBPACK_IMPORTED_MODULE_7__["VisibleEvent"](this));
                this._logger.debug('Window visible');
            }
        });
        if (!this.canvasElementId && !options.canvasElement) {
            document.body.appendChild(this.canvas);
        }
    }
    onInitialize(_engine) {
        // Override me
    }
    /**
     * If supported by the browser, this will set the antialiasing flag on the
     * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
     * image resources.
     * @param isSmooth  Set smoothing to true or false
     */
    setAntialiasing(isSmooth) {
        this.screen.antialiasing = isSmooth;
    }
    /**
     * Return the current smoothing status of the canvas
     */
    getAntialiasing() {
        return this.screen.antialiasing;
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    _overrideInitialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new _Events__WEBPACK_IMPORTED_MODULE_7__["InitializeEvent"](engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * Updates the entire state of the game
     * @param delta  Number of milliseconds elapsed since the last update.
     */
    _update(delta) {
        if (this._isLoading) {
            // suspend updates until loading is finished
            this._loader.update(this, delta);
            // Update input listeners
            this.input.keyboard.update();
            this.input.pointers.update();
            this.input.gamepads.update();
            return;
        }
        this._overrideInitialize(this);
        // Publish preupdate events
        this._preupdate(delta);
        // process engine level events
        this.currentScene.update(this, delta);
        // update animations
        // TODO remove
        this._animations = this._animations.filter(function (a) {
            return !a.animation.isDone();
        });
        // Update input listeners
        this.input.keyboard.update();
        this.input.pointers.update();
        this.input.gamepads.update();
        // Publish update event
        this._postupdate(delta);
    }
    /**
     * @internal
     */
    _preupdate(delta) {
        this.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_7__["PreUpdateEvent"](this, delta, this));
        this.onPreUpdate(this, delta);
    }
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postupdate(delta) {
        this.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_7__["PostUpdateEvent"](this, delta, this));
        this.onPostUpdate(this, delta);
    }
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Draws the entire game
     * @param delta  Number of milliseconds elapsed since the last draw.
     */
    _draw(delta) {
        const ctx = this.ctx;
        this._predraw(ctx, delta);
        if (this._isLoading) {
            this._loader.draw(ctx, delta);
            // Drawing nothing else while loading
            return;
        }
        ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
        ctx.fillStyle = this.backgroundColor.toString();
        ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
        this.currentScene.draw(this.ctx, delta);
        // todo needs to be a better way of doing this
        let a = 0;
        const len = this._animations.length;
        for (a; a < len; a++) {
            this._animations[a].animation.draw(ctx, this._animations[a].x, this._animations[a].y);
        }
        // Draw debug information
        if (this.isDebug) {
            this.ctx.font = 'Consolas';
            this.ctx.fillStyle = this.debugColor.toString();
            const keys = this.input.keyboard.getKeys();
            for (let j = 0; j < keys.length; j++) {
                this.ctx.fillText(keys[j].toString() + ' : ' + (_Input_Index__WEBPACK_IMPORTED_MODULE_13__["Keys"][keys[j]] ? _Input_Index__WEBPACK_IMPORTED_MODULE_13__["Keys"][keys[j]] : 'Not Mapped'), 100, 10 * j + 10);
            }
            this.ctx.fillText('FPS:' + this.stats.currFrame.fps.toFixed(2).toString(), 10, 10);
        }
        // Post processing
        for (let i = 0; i < this.postProcessors.length; i++) {
            this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight), this.ctx);
        }
        this._postdraw(ctx, delta);
    }
    /**
     * @internal
     */
    _predraw(_ctx, delta) {
        this.emit('predraw', new _Events__WEBPACK_IMPORTED_MODULE_7__["PreDrawEvent"](_ctx, delta, this));
        this.onPreDraw(_ctx, delta);
    }
    onPreDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postdraw(_ctx, delta) {
        this.emit('postdraw', new _Events__WEBPACK_IMPORTED_MODULE_7__["PostDrawEvent"](_ctx, delta, this));
        this.onPostDraw(_ctx, delta);
    }
    onPostDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * Enable or disable Excalibur debugging functionality.
     * @param toggle a value that debug drawing will be changed to
     */
    showDebug(toggle) {
        this._isDebug = toggle;
    }
    /**
     * Toggle Excalibur debugging functionality.
     */
    toggleDebug() {
        this._isDebug = !this._isDebug;
        return this._isDebug;
    }
    /**
     * Starts the internal game loop for Excalibur after loading
     * any provided assets.
     * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own
     * custom loader.
     */
    start(loader) {
        if (!this._compatible) {
            return Promise.reject('Excalibur is incompatible with your browser');
        }
        // Changing resolution invalidates context state, so we need to capture it before applying
        this.screen.pushResolutionAndViewport();
        this.screen.resolution = this.screen.viewport;
        this.screen.applyResolutionAndViewport();
        let loadingComplete;
        if (loader) {
            this._loader = loader;
            this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;
            this._loader.wireEngine(this);
            loadingComplete = this.load(this._loader);
        }
        else {
            loadingComplete = Promise.resolve();
        }
        loadingComplete.then(() => {
            this.screen.popResolutionAndViewport();
            this.screen.applyResolutionAndViewport();
            this.emit('start', new _Events__WEBPACK_IMPORTED_MODULE_7__["GameStartEvent"](this));
        });
        if (!this._hasStarted) {
            this._hasStarted = true;
            this._logger.debug('Starting game...');
            this.browser.resume();
            Engine.createMainLoop(this, window.requestAnimationFrame, Date.now)();
            this._logger.debug('Game started');
        }
        else {
            // Game already started;
        }
        return loadingComplete;
    }
    static createMainLoop(game, raf, nowFn) {
        let lastTime = nowFn();
        return function mainloop() {
            if (!game._hasStarted) {
                return;
            }
            try {
                game._requestId = raf(mainloop);
                game.emit('preframe', new _Events__WEBPACK_IMPORTED_MODULE_7__["PreFrameEvent"](game, game.stats.prevFrame));
                // Get the time to calculate time-elapsed
                const now = nowFn();
                let elapsed = Math.floor(now - lastTime) || 1;
                // Resolves issue #138 if the game has been paused, or blurred for
                // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability
                // and provides more expected behavior when the engine comes back
                // into focus
                if (elapsed > 200) {
                    elapsed = 1;
                }
                const delta = elapsed * game.timescale;
                // reset frame stats (reuse existing instances)
                const frameId = game.stats.prevFrame.id + 1;
                game.stats.currFrame.reset();
                game.stats.currFrame.id = frameId;
                game.stats.currFrame.delta = delta;
                game.stats.currFrame.fps = 1.0 / (delta / 1000);
                const beforeUpdate = nowFn();
                game._update(delta);
                const afterUpdate = nowFn();
                game._draw(delta);
                const afterDraw = nowFn();
                game.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
                game.stats.currFrame.duration.draw = afterDraw - afterUpdate;
                lastTime = now;
                game.emit('postframe', new _Events__WEBPACK_IMPORTED_MODULE_7__["PostFrameEvent"](game, game.stats.currFrame));
                game.stats.prevFrame.reset(game.stats.currFrame);
            }
            catch (e) {
                window.cancelAnimationFrame(game._requestId);
                game.stop();
                game.onFatalException(e);
            }
        };
    }
    /**
     * Stops Excalibur's main loop, useful for pausing the game.
     */
    stop() {
        if (this._hasStarted) {
            this.emit('stop', new _Events__WEBPACK_IMPORTED_MODULE_7__["GameStopEvent"](this));
            this.browser.pause();
            this._hasStarted = false;
            this._logger.debug('Game stopped');
        }
    }
    /**
     * Returns the Engine's Running status, Useful for checking whether engine is running or paused.
     */
    isPaused() {
        return !this._hasStarted;
    }
    /**
     * Takes a screen shot of the current viewport and returns it as an
     * HTML Image Element.
     */
    screenshot() {
        const result = new Image();
        const raw = this.canvas.toDataURL('image/png');
        result.src = raw;
        return result;
    }
    /**
     * Another option available to you to load resources into the game.
     * Immediately after calling this the game will pause and the loading screen
     * will appear.
     * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
     */
    load(loader) {
        const complete = new Promise((resolve) => {
            this._isLoading = true;
            loader.load().then(() => {
                if (this._suppressPlayButton) {
                    setTimeout(() => {
                        this._isLoading = false;
                        resolve();
                        // Delay is to give the logo a chance to show, otherwise don't delay
                    }, 500);
                }
                else {
                    this._isLoading = false;
                    resolve();
                }
            });
        });
        return complete;
    }
}
/**
 * Default [[EngineOptions]]
 */
Engine._DEFAULT_ENGINE_OPTIONS = {
    width: 0,
    height: 0,
    enableCanvasTransparency: true,
    canvasElementId: '',
    canvasElement: undefined,
    pointerScope: _Input_Index__WEBPACK_IMPORTED_MODULE_13__["PointerScope"].Document,
    suppressConsoleBootMessage: null,
    suppressMinimumBrowserFeatureDetection: null,
    suppressHiDPIScaling: null,
    suppressPlayButton: null,
    scrollPreventionMode: ScrollPreventionMode.Canvas,
    backgroundColor: _Drawing_Color__WEBPACK_IMPORTED_MODULE_9__["Color"].fromHex('#2185d0') // Excalibur blue
};
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_15__["obsolete"])({ message: 'Will be removed in excalibur v0.26.0' })
], Engine.prototype, "playAnimation", null);
/**
 * @internal
 * @deprecated
 */
let AnimationNode = class AnimationNode {
    constructor(animation, x, y) {
        this.animation = animation;
        this.x = x;
        this.y = y;
    }
};
AnimationNode = __decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_15__["obsolete"])({ message: 'Will be removed in excalibur v0.26.0' })
], AnimationNode);


/***/ }),

/***/ "./EntityComponentSystem/Component.ts":
/*!********************************************!*\
  !*** ./EntityComponentSystem/Component.ts ***!
  \********************************************/
/*! exports provided: Component, TagComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagComponent", function() { return TagComponent; });
/**
 * Type guard to check if a component implements clone
 * @param x
 */
function hasClone(x) {
    return !!(x === null || x === void 0 ? void 0 : x.clone);
}
/**
 * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity posesses
 *
 * Implementations of Component must have a zero-arg constructor to support dependecies
 *
 * ```typescript
 * class MyComponent extends ex.Component<'my'> {
 *   public readonly type = 'my';
 *   // zero arg support required if you want to use component dependencies
 *   constructor(public optionalPos?: ex.Vector) {}
 * }
 * ```
 */
class Component {
    constructor() {
        /**
         * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]
         */
        this.owner = null;
    }
    /**
     * Clones any properties on this component, if that property value has a `clone()` method it will be called
     */
    clone() {
        const newComponent = new this.constructor();
        for (const prop in this) {
            if (this.hasOwnProperty(prop)) {
                const val = this[prop];
                if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {
                    newComponent[prop] = val.clone();
                }
                else {
                    newComponent[prop] = val;
                }
            }
        }
        return newComponent;
    }
}
/**
 * Tag components are a way of tagging a component with label and a simple value
 *
 * For example:
 *
 * ```typescript
 * const isOffscreen = new TagComponent('offscreen');
 * entity.addComponent(isOffscreen);
 * entity.tags.includes
 * ```
 */
class TagComponent extends Component {
    constructor(type, value) {
        super();
        this.type = type;
        this.value = value;
    }
}


/***/ }),

/***/ "./EntityComponentSystem/Components/TransformComponent.ts":
/*!****************************************************************!*\
  !*** ./EntityComponentSystem/Components/TransformComponent.ts ***!
  \****************************************************************/
/*! exports provided: CoordPlane, TransformComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoordPlane", function() { return CoordPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransformComponent", function() { return TransformComponent; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Algebra */ "./Algebra.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Component */ "./EntityComponentSystem/Component.ts");


/**
 * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]
 */
var CoordPlane;
(function (CoordPlane) {
    /**
     * The world coordinate plane (default) represents world space, any entities drawn with world
     * space move when the camera moves.
     */
    CoordPlane["World"] = "world";
    /**
     * The screen coordinate plane represents screen space, entities drawn in screen space are pinned
     * to screen coordinates ignoring the camera.
     */
    CoordPlane["Screen"] = "screen";
})(CoordPlane || (CoordPlane = {}));
class TransformComponent extends _Component__WEBPACK_IMPORTED_MODULE_1__["Component"] {
    constructor() {
        super(...arguments);
        this.type = 'transform';
        /**
         * The [[coordinate plane|CoordPlane]] for this transform for the entity.
         */
        this.coordPlane = CoordPlane.World;
        /**
         * The current position of the entity in world space or in screen space depending on the the [[coordinate plan|CoordPlane]]
         */
        this.pos = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Zero;
        /**
         * The z-index ordering of the entity, a higher values are drawn on top of lower values.
         * For example z=99 would be drawn on top of z=0.
         */
        this.z = 0;
        /**
         * The rotation of the entity in radians. For example `Math.PI` radians is the same as 180 degrees.
         */
        this.rotation = 0;
        /**
         * The scale of the entity.
         */
        this.scale = _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].One;
    }
}


/***/ }),

/***/ "./EntityComponentSystem/Entity.ts":
/*!*****************************************!*\
  !*** ./EntityComponentSystem/Entity.ts ***!
  \*****************************************/
/*! exports provided: AddedComponent, isAddedComponent, RemovedComponent, isRemovedComponent, Entity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddedComponent", function() { return AddedComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAddedComponent", function() { return isAddedComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RemovedComponent", function() { return RemovedComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRemovedComponent", function() { return isRemovedComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Entity", function() { return Entity; });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "./EntityComponentSystem/Component.ts");
/* harmony import */ var _Util_Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util/Observable */ "./Util/Observable.ts");
/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Class */ "./Class.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Events */ "./Events.ts");




/**
 * AddedComponent message
 */
class AddedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Added';
    }
}
/**
 * Type guard to know if message is f an Added Component
 */
function isAddedComponent(x) {
    return !!x && x.type === 'Component Added';
}
/**
 * RemovedComponent message
 */
class RemovedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Removed';
    }
}
/**
 * Type guard to know if message is for a Removed Component
 */
function isRemovedComponent(x) {
    return !!x && x.type === 'Component Removed';
}
/**
 * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system
 *
 * Entities can be strongly typed with the components they contain
 *
 * ```typescript
 * const entity = new Entity<ComponentA | ComponentB>();
 * entity.components.a; // Type ComponentA
 * entity.components.b; // Type ComponentB
 * ```
 */
class Entity extends _Class__WEBPACK_IMPORTED_MODULE_2__["Class"] {
    constructor() {
        super(...arguments);
        /**
         * The unique identifier for the entity
         */
        this.id = Entity._ID++;
        /**
         * Whether this entity is active, if set to false it will be reclaimed
         */
        this.active = true;
        this._tagsMemo = [];
        this._typesMemo = [];
        /**
         * Bucket to hold on to deferred removals
         */
        this._componentsToRemove = [];
        /**
         * Proxy handler for component changes, responsible for notifying observers
         */
        this._handleChanges = {
            defineProperty: (obj, prop, descriptor) => {
                obj[prop] = descriptor.value;
                this._rebuildMemos();
                this.changes.notifyAll(new AddedComponent({
                    component: descriptor.value,
                    entity: this
                }));
                return true;
            },
            deleteProperty: (obj, prop) => {
                if (prop in obj) {
                    this.changes.notifyAll(new RemovedComponent({
                        component: obj[prop],
                        entity: this
                    }));
                    delete obj[prop];
                    this._rebuildMemos();
                    return true;
                }
                return false;
            }
        };
        /**
         * Dictionary that holds entity components
         */
        this.components = new Proxy({}, this._handleChanges);
        /**
         * Observable that keeps track of component add or remove changes on the entity
         */
        this.changes = new _Util_Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]();
        this._isInitialized = false;
    }
    /**
     * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.
     */
    kill() {
        this.active = false;
    }
    isKilled() {
        return !this.active;
    }
    /**
     * Specifically get the tags on the entity from [[TagComponent]]
     */
    get tags() {
        return this._tagsMemo;
    }
    /**
     * Check if a tag exists on the entity
     * @param tag name to check for
     */
    hasTag(tag) {
        return this.tags.includes(tag);
    }
    /**
     * The types of the components on the Entity
     */
    get types() {
        return this._typesMemo;
    }
    _rebuildMemos() {
        this._tagsMemo = Object.values(this.components)
            .filter((c) => c instanceof _Component__WEBPACK_IMPORTED_MODULE_0__["TagComponent"])
            .map((c) => c.type);
        this._typesMemo = Object.keys(this.components);
    }
    /**
     * Creates a deep copy of the entity and a copy of all its components
     */
    clone() {
        const newEntity = new Entity();
        for (const c of this.types) {
            newEntity.addComponent(this.components[c].clone());
        }
        return newEntity;
    }
    /**
     * Adds a component to the entity, or adds a copy of all the components from another entity as a "prefab"
     * @param componentOrEntity Component or Entity to add copy of components from
     * @param force Optionally overwrite any existing components of the same type
     */
    addComponent(componentOrEntity, force = false) {
        // If you use an entity as a "prefab" or template
        if (componentOrEntity instanceof Entity) {
            for (const c in componentOrEntity.components) {
                this.addComponent(componentOrEntity.components[c].clone(), force);
            }
            // Normal component case
        }
        else {
            // if component already exists, skip if not forced
            if (this.components[componentOrEntity.type] && !force) {
                return this;
            }
            // Remove existing component type if exists when forced
            if (this.components[componentOrEntity.type] && force) {
                this.removeComponent(componentOrEntity);
            }
            // todo circular dependencies will be a problem
            if (componentOrEntity.dependencies && componentOrEntity.dependencies.length) {
                for (const ctor of componentOrEntity.dependencies) {
                    this.addComponent(new ctor());
                }
            }
            componentOrEntity.owner = this;
            this.components[componentOrEntity.type] = componentOrEntity;
            if (componentOrEntity.onAdd) {
                componentOrEntity.onAdd(this);
            }
        }
        return this;
    }
    /**
     * Removes a component from the entity, by default removals are deferred to the end of entity processing to avoid consistency issues
     *
     * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately
     * @param componentOrType
     * @param force
     */
    removeComponent(componentOrType, force = false) {
        if (force) {
            if (typeof componentOrType === 'string') {
                this._removeComponentByType(componentOrType);
            }
            else if (componentOrType instanceof _Component__WEBPACK_IMPORTED_MODULE_0__["Component"]) {
                this._removeComponentByType(componentOrType.type);
            }
        }
        else {
            this._componentsToRemove.push(componentOrType);
        }
        return this;
    }
    _removeComponentByType(type) {
        if (this.components[type]) {
            this.components[type].owner = null;
            if (this.components[type].onRemove) {
                this.components[type].onRemove(this);
            }
            delete this.components[type];
        }
    }
    /**
     * @hidden
     * @internal
     */
    processComponentRemoval() {
        for (const componentOrType of this._componentsToRemove) {
            const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;
            this._removeComponentByType(type);
        }
        this._componentsToRemove.length = 0;
    }
    /**
     * Check if a component type exists
     * @param type
     */
    has(type) {
        return !!this.components[type];
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new _Events__WEBPACK_IMPORTED_MODULE_3__["InitializeEvent"](engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_3__["PreUpdateEvent"](engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_3__["PostUpdateEvent"](engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * `onInitialize` is called before the first update of the entity. This method is meant to be
     * overridden.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an entity is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an entity is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
}
Entity._ID = 0;


/***/ }),

/***/ "./EntityComponentSystem/EntityManager.ts":
/*!************************************************!*\
  !*** ./EntityComponentSystem/EntityManager.ts ***!
  \************************************************/
/*! exports provided: EntityManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityManager", function() { return EntityManager; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! .. */ "./index.ts");


// Add/Remove entitys and components
class EntityManager {
    constructor(_world) {
        this._world = _world;
        this.entities = [];
        this._entityIndex = {};
    }
    /**
     * EntityManager observes changes on entities
     * @param message
     */
    notify(message) {
        if (Object(_Entity__WEBPACK_IMPORTED_MODULE_0__["isAddedComponent"])(message)) {
            // we don't need the component, it's already on the entity
            this._world.queryManager.addEntity(message.data.entity);
        }
        if (Object(_Entity__WEBPACK_IMPORTED_MODULE_0__["isRemovedComponent"])(message)) {
            this._world.queryManager.removeComponent(message.data.entity, message.data.component);
        }
    }
    /**
     * Adds an entity to be tracked by the EntityManager
     * @param entity
     */
    addEntity(entity) {
        if (entity) {
            this._entityIndex[entity.id] = entity;
            this.entities.push(entity);
            this._world.queryManager.addEntity(entity);
            entity.changes.register(this);
        }
    }
    removeEntity(idOrEntity) {
        let id = 0;
        if (idOrEntity instanceof _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"]) {
            id = idOrEntity.id;
        }
        else {
            id = idOrEntity;
        }
        const entity = this._entityIndex[id];
        delete this._entityIndex[id];
        if (entity) {
            ___WEBPACK_IMPORTED_MODULE_1__["Util"].removeItemFromArray(entity, this.entities);
            this._world.queryManager.removeEntity(entity);
            entity.changes.unregister(this);
        }
    }
    processComponentRemovals() {
        for (const entity of this.entities) {
            entity.processComponentRemoval();
        }
    }
    getById(id) {
        return this._entityIndex[id];
    }
    clear() {
        for (const entity of this.entities) {
            this.removeEntity(entity);
        }
    }
}


/***/ }),

/***/ "./EntityComponentSystem/Query.ts":
/*!****************************************!*\
  !*** ./EntityComponentSystem/Query.ts ***!
  \****************************************/
/*! exports provided: Query */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Query", function() { return Query; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Util */ "./EntityComponentSystem/Util.ts");
/* harmony import */ var _Util_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util/Observable */ "./Util/Observable.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! .. */ "./index.ts");
/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./System */ "./EntityComponentSystem/System.ts");





/**
 * Represents query for entities that match a list of types that is cached and observable
 *
 * Queries can be strongly typed by supplying a type union in the optional type parameter
 * ```typescript
 * const queryAB = new ex.Query<ComponentTypeA, ComponentTypeB>(['A', 'B']);
 * ```
 */
class Query extends _Util_Observable__WEBPACK_IMPORTED_MODULE_2__["Observable"] {
    constructor(types) {
        super();
        this.types = types;
        this._entities = [];
    }
    get key() {
        if (this._key) {
            return this._key;
        }
        return (this._key = Object(_Util__WEBPACK_IMPORTED_MODULE_1__["buildTypeKey"])(this.types));
    }
    /**
     * Returns a list of entities that match the query
     *
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort) {
        if (sort) {
            this._entities.sort(sort);
        }
        return this._entities;
    }
    /**
     * Add an entity to the query, will only be added if the entity matches the query types
     * @param entity
     */
    addEntity(entity) {
        if (!___WEBPACK_IMPORTED_MODULE_3__["Util"].contains(this._entities, entity) && this.matches(entity)) {
            this._entities.push(entity);
            this.notifyAll(new _System__WEBPACK_IMPORTED_MODULE_4__["AddedEntity"](entity));
        }
    }
    /**
     * If the entity is part of the query it will be removed regardless of types
     * @param entity
     */
    removeEntity(entity) {
        if (___WEBPACK_IMPORTED_MODULE_3__["Util"].removeItemFromArray(entity, this._entities)) {
            this.notifyAll(new _System__WEBPACK_IMPORTED_MODULE_4__["RemovedEntity"](entity));
        }
    }
    /**
     * Removes all entities and observers from the query
     */
    clear() {
        this._entities.length = 0;
        for (const observer of this.observers) {
            this.unregister(observer);
        }
    }
    matches(typesOrEntity) {
        let types = [];
        if (typesOrEntity instanceof _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"]) {
            types = typesOrEntity.types;
        }
        else {
            types = typesOrEntity;
        }
        let matches = true;
        for (const type of this.types) {
            matches = matches && types.indexOf(type) > -1;
            if (!matches) {
                return false;
            }
        }
        return matches;
    }
}


/***/ }),

/***/ "./EntityComponentSystem/QueryManager.ts":
/*!***********************************************!*\
  !*** ./EntityComponentSystem/QueryManager.ts ***!
  \***********************************************/
/*! exports provided: QueryManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryManager", function() { return QueryManager; });
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util */ "./EntityComponentSystem/Util.ts");
/* harmony import */ var _Query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Query */ "./EntityComponentSystem/Query.ts");


/**
 * The query manager is responsible for updating all queries when entities/components change
 */
class QueryManager {
    constructor(_world) {
        this._world = _world;
        this._queries = {};
    }
    /**
     * Adds a query to the manager and populates with any entities that match
     * @param query
     */
    _addQuery(query) {
        this._queries[Object(_Util__WEBPACK_IMPORTED_MODULE_0__["buildTypeKey"])(query.types)] = query;
        for (const entity of this._world.entityManager.entities) {
            query.addEntity(entity);
        }
    }
    /**
     * Removes the query if there are no observers left
     * @param query
     */
    maybeRemoveQuery(query) {
        if (query.observers.length === 0) {
            query.clear();
            delete this._queries[Object(_Util__WEBPACK_IMPORTED_MODULE_0__["buildTypeKey"])(query.types)];
        }
    }
    /**
     * Adds the entity to any matching query in the query manage
     * @param entity
     */
    addEntity(entity) {
        for (const queryType in this._queries) {
            if (this._queries[queryType]) {
                this._queries[queryType].addEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from queries if the removed component disqualifies it
     * @param entity
     * @param component
     */
    removeComponent(entity, component) {
        for (const queryType in this._queries) {
            if (this._queries[queryType].matches(entity.types.concat([component.type]))) {
                this._queries[queryType].removeEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from all queries it is currently a part of
     * @param entity
     */
    removeEntity(entity) {
        for (const queryType in this._queries) {
            this._queries[queryType].removeEntity(entity);
        }
    }
    /**
     * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance
     * @param types
     */
    createQuery(types) {
        const maybeExistingQuery = this.getQuery(types);
        if (maybeExistingQuery) {
            return maybeExistingQuery;
        }
        const query = new _Query__WEBPACK_IMPORTED_MODULE_1__["Query"](types);
        this._addQuery(query);
        return query;
    }
    /**
     * Retrieves an existing query by types if it exists otherwise returns null
     * @param types
     */
    getQuery(types) {
        const key = Object(_Util__WEBPACK_IMPORTED_MODULE_0__["buildTypeKey"])(types);
        if (this._queries[key]) {
            return this._queries[key];
        }
        return null;
    }
}


/***/ }),

/***/ "./EntityComponentSystem/System.ts":
/*!*****************************************!*\
  !*** ./EntityComponentSystem/System.ts ***!
  \*****************************************/
/*! exports provided: SystemType, System, AddedEntity, isAddedSystemEntity, RemovedEntity, isRemoveSystemEntity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SystemType", function() { return SystemType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "System", function() { return System; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddedEntity", function() { return AddedEntity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAddedSystemEntity", function() { return isAddedSystemEntity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RemovedEntity", function() { return RemovedEntity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRemoveSystemEntity", function() { return isRemoveSystemEntity; });
/**
 * Enum that determines whether to run the system in the update or draw phase
 */
var SystemType;
(function (SystemType) {
    SystemType["Update"] = "update";
    SystemType["Draw"] = "draw";
})(SystemType || (SystemType = {}));
/**
 * An Excalibur [[System]] that updates entities of certain types.
 * Systems are scene specific
 *
 * Excalibur Systems currently require at least 1 Component type to operated
 *
 * Multiple types are declared as a type union
 * For example:
 *
 * ```typescript
 * class MySystem extends System<ComponentA | ComponentB> {
 *   public readonly types = ['a', 'b'] as const;
 *   public readonly systemType = SystemType.Update;
 *   public update(entities: Entity<ComponentA | ComponentB>) {
 *      ...
 *   }
 * }
 * ```
 */
class System {
    constructor() {
        /**
         * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.
         * For a system to execute before all other a lower priority value (-1 for example) must be set.
         * For a system to exectue after all other a higher priority value (10 for example) must be set.
         */
        this.priority = 0;
    }
    /**
     * Systems observe when entities match their types or no longer match their types, override
     * @param _entityAddedOrRemoved
     */
    notify(_entityAddedOrRemoved) {
        // Override me
    }
}
/**
 * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.
 */
class AddedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Added';
    }
}
/**
 * Type guard to check for AddedEntity messages
 * @param x
 */
function isAddedSystemEntity(x) {
    return !!x && x.type === 'Entity Added';
}
/**
 * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.
 */
class RemovedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Removed';
    }
}
/**
 * type guard to check for the RemovedEntity message
 */
function isRemoveSystemEntity(x) {
    return !!x && x.type === 'Entity Removed';
}


/***/ }),

/***/ "./EntityComponentSystem/SystemManager.ts":
/*!************************************************!*\
  !*** ./EntityComponentSystem/SystemManager.ts ***!
  \************************************************/
/*! exports provided: SystemManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SystemManager", function() { return SystemManager; });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ "./index.ts");

/**
 * The SystemManager is responsible for keeping track of all systems in a scene.
 * Systems are scene specific
 */
class SystemManager {
    constructor(_world) {
        this._world = _world;
        /**
         * List of systems, to add a new system call [[SystemManager.addSystem]]
         */
        this.systems = [];
    }
    /**
     * Adds a system to the manager, it will now be updated every frame
     * @param system
     */
    addSystem(system) {
        // validate system has types
        if (!system.types || system.types.length === 0) {
            throw new Error(`Attempted to add a System without any types`);
        }
        const query = this._world.queryManager.createQuery(system.types);
        this.systems.push(system);
        this.systems.sort((a, b) => a.priority - b.priority);
        query.register(system);
        if (system.initialize) {
            system.initialize(this._world.context);
        }
    }
    /**
     * Removes a system from the manager, it will no longer be updated
     * @param system
     */
    removeSystem(system) {
        ___WEBPACK_IMPORTED_MODULE_0__["Util"].removeItemFromArray(system, this.systems);
        const query = this._world.queryManager.getQuery(system.types);
        if (query) {
            query.unregister(system);
            this._world.queryManager.maybeRemoveQuery(query);
        }
    }
    /**
     * Updates all systems
     * @param type whether this is an update or draw system
     * @param engine engine reference
     * @param delta time in milliseconds
     */
    updateSystems(type, engine, delta) {
        const systems = this.systems.filter((s) => s.systemType === type);
        for (const s of systems) {
            if (s.preupdate) {
                s.preupdate(engine, delta);
            }
        }
        for (const s of systems) {
            const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);
            s.update(entities, delta);
        }
        for (const s of systems) {
            if (s.postupdate) {
                s.postupdate(engine, delta);
            }
        }
    }
    clear() {
        for (const system of this.systems) {
            this.removeSystem(system);
        }
    }
}


/***/ }),

/***/ "./EntityComponentSystem/Util.ts":
/*!***************************************!*\
  !*** ./EntityComponentSystem/Util.ts ***!
  \***************************************/
/*! exports provided: buildTypeKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildTypeKey", function() { return buildTypeKey; });
const buildTypeKey = (types) => {
    const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');
    return key;
};


/***/ }),

/***/ "./EntityComponentSystem/World.ts":
/*!****************************************!*\
  !*** ./EntityComponentSystem/World.ts ***!
  \****************************************/
/*! exports provided: World */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "World", function() { return World; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _EntityManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EntityManager */ "./EntityComponentSystem/EntityManager.ts");
/* harmony import */ var _QueryManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./QueryManager */ "./EntityComponentSystem/QueryManager.ts");
/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _SystemManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SystemManager */ "./EntityComponentSystem/SystemManager.ts");





/**
 * The World is a self-contained entity component system for a particular context.
 */
class World {
    /**
     * The context type is passed to the system updates
     * @param context
     */
    constructor(context) {
        this.context = context;
        this.queryManager = new _QueryManager__WEBPACK_IMPORTED_MODULE_2__["QueryManager"](this);
        this.entityManager = new _EntityManager__WEBPACK_IMPORTED_MODULE_1__["EntityManager"](this);
        this.systemManager = new _SystemManager__WEBPACK_IMPORTED_MODULE_4__["SystemManager"](this);
    }
    /**
     * Update systems by type and time elapsed in milliseconds
     */
    update(type, delta) {
        this.systemManager.updateSystems(type, this.context, delta);
        this.entityManager.processComponentRemovals();
    }
    add(entityOrSystem) {
        if (entityOrSystem instanceof _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"]) {
            this.entityManager.addEntity(entityOrSystem);
        }
        if (entityOrSystem instanceof _System__WEBPACK_IMPORTED_MODULE_3__["System"]) {
            this.systemManager.addSystem(entityOrSystem);
        }
    }
    remove(entityOrSystem) {
        if (entityOrSystem instanceof _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"]) {
            this.entityManager.removeEntity(entityOrSystem);
        }
        if (entityOrSystem instanceof _System__WEBPACK_IMPORTED_MODULE_3__["System"]) {
            this.systemManager.removeSystem(entityOrSystem);
        }
    }
    clearEntities() {
        this.entityManager.clear();
    }
    clearSystems() {
        this.systemManager.clear();
    }
}


/***/ }),

/***/ "./EntityComponentSystem/index.ts":
/*!****************************************!*\
  !*** ./EntityComponentSystem/index.ts ***!
  \****************************************/
/*! exports provided: Component, TagComponent, AddedComponent, isAddedComponent, RemovedComponent, isRemovedComponent, Entity, EntityManager, Query, QueryManager, SystemType, System, AddedEntity, isAddedSystemEntity, RemovedEntity, isRemoveSystemEntity, SystemManager, World, CoordPlane, TransformComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "./EntityComponentSystem/Component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return _Component__WEBPACK_IMPORTED_MODULE_0__["Component"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TagComponent", function() { return _Component__WEBPACK_IMPORTED_MODULE_0__["TagComponent"]; });

/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AddedComponent", function() { return _Entity__WEBPACK_IMPORTED_MODULE_1__["AddedComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isAddedComponent", function() { return _Entity__WEBPACK_IMPORTED_MODULE_1__["isAddedComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RemovedComponent", function() { return _Entity__WEBPACK_IMPORTED_MODULE_1__["RemovedComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRemovedComponent", function() { return _Entity__WEBPACK_IMPORTED_MODULE_1__["isRemovedComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Entity", function() { return _Entity__WEBPACK_IMPORTED_MODULE_1__["Entity"]; });

/* harmony import */ var _EntityManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EntityManager */ "./EntityComponentSystem/EntityManager.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EntityManager", function() { return _EntityManager__WEBPACK_IMPORTED_MODULE_2__["EntityManager"]; });

/* harmony import */ var _Query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Query */ "./EntityComponentSystem/Query.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Query", function() { return _Query__WEBPACK_IMPORTED_MODULE_3__["Query"]; });

/* harmony import */ var _QueryManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./QueryManager */ "./EntityComponentSystem/QueryManager.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QueryManager", function() { return _QueryManager__WEBPACK_IMPORTED_MODULE_4__["QueryManager"]; });

/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./System */ "./EntityComponentSystem/System.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SystemType", function() { return _System__WEBPACK_IMPORTED_MODULE_5__["SystemType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "System", function() { return _System__WEBPACK_IMPORTED_MODULE_5__["System"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AddedEntity", function() { return _System__WEBPACK_IMPORTED_MODULE_5__["AddedEntity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isAddedSystemEntity", function() { return _System__WEBPACK_IMPORTED_MODULE_5__["isAddedSystemEntity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RemovedEntity", function() { return _System__WEBPACK_IMPORTED_MODULE_5__["RemovedEntity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRemoveSystemEntity", function() { return _System__WEBPACK_IMPORTED_MODULE_5__["isRemoveSystemEntity"]; });

/* harmony import */ var _SystemManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SystemManager */ "./EntityComponentSystem/SystemManager.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SystemManager", function() { return _SystemManager__WEBPACK_IMPORTED_MODULE_6__["SystemManager"]; });

/* harmony import */ var _World__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./World */ "./EntityComponentSystem/World.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "World", function() { return _World__WEBPACK_IMPORTED_MODULE_7__["World"]; });

/* harmony import */ var _Components_TransformComponent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CoordPlane", function() { return _Components_TransformComponent__WEBPACK_IMPORTED_MODULE_8__["CoordPlane"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformComponent", function() { return _Components_TransformComponent__WEBPACK_IMPORTED_MODULE_8__["TransformComponent"]; });












/***/ }),

/***/ "./EventDispatcher.ts":
/*!****************************!*\
  !*** ./EventDispatcher.ts ***!
  \****************************/
/*! exports provided: EventDispatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Events */ "./Events.ts");

class EventDispatcher {
    /**
     * @param target  The object that will be the recipient of events from this event dispatcher
     */
    constructor(target) {
        this._handlers = {};
        this._wiredEventDispatchers = [];
        this._target = target;
    }
    /**
     * Clears any existing handlers or wired event dispatchers on this event dispatcher
     */
    clear() {
        this._handlers = {};
        this._wiredEventDispatchers = [];
    }
    /**
     * Emits an event for target
     * @param eventName  The name of the event to publish
     * @param event      Optionally pass an event data object to the handler
     */
    emit(eventName, event) {
        if (!eventName) {
            // key not mapped
            return;
        }
        eventName = eventName.toLowerCase();
        const target = this._target;
        if (!event) {
            event = new _Events__WEBPACK_IMPORTED_MODULE_0__["GameEvent"]();
        }
        event.target = target;
        let i, len;
        if (this._handlers[eventName]) {
            i = 0;
            len = this._handlers[eventName].length;
            for (i; i < len; i++) {
                this._handlers[eventName][i].call(target, event);
            }
        }
        i = 0;
        len = this._wiredEventDispatchers.length;
        for (i; i < len; i++) {
            this._wiredEventDispatchers[i].emit(eventName, event);
        }
    }
    /**
     * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
     * @param eventName  The name of the event to subscribe to
     * @param handler    The handler callback to fire on this event
     */
    on(eventName, handler) {
        eventName = eventName.toLowerCase();
        if (!this._handlers[eventName]) {
            this._handlers[eventName] = [];
        }
        this._handlers[eventName].push(handler);
        // meta event handlers
        if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
            this.emit('subscribe', new _Events__WEBPACK_IMPORTED_MODULE_0__["SubscribeEvent"](eventName, handler));
        }
    }
    /**
     * Unsubscribe an event handler(s) from an event. If a specific handler
     * is specified for an event, only that handler will be unsubscribed.
     * Otherwise all handlers will be unsubscribed for that event.
     *
     * @param eventName  The name of the event to unsubscribe
     * @param handler    Optionally the specific handler to unsubscribe
     *
     */
    off(eventName, handler) {
        eventName = eventName.toLowerCase();
        const eventHandlers = this._handlers[eventName];
        if (eventHandlers) {
            // if no explicit handler is give with the event name clear all handlers
            if (!handler) {
                this._handlers[eventName].length = 0;
            }
            else {
                const index = eventHandlers.indexOf(handler);
                this._handlers[eventName].splice(index, 1);
            }
        }
        // meta event handlers
        if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
            this.emit('unsubscribe', new _Events__WEBPACK_IMPORTED_MODULE_0__["UnsubscribeEvent"](eventName, handler));
        }
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        const metaHandler = (event) => {
            const ev = event || new _Events__WEBPACK_IMPORTED_MODULE_0__["GameEvent"]();
            ev.target = ev.target || this._target;
            this.off(eventName, handler);
            handler.call(ev.target, ev);
        };
        this.on(eventName, metaHandler);
    }
    /**
     * Wires this event dispatcher to also receive events from another
     */
    wire(eventDispatcher) {
        eventDispatcher._wiredEventDispatchers.push(this);
    }
    /**
     * Unwires this event dispatcher from another
     */
    unwire(eventDispatcher) {
        const index = eventDispatcher._wiredEventDispatchers.indexOf(this);
        if (index > -1) {
            eventDispatcher._wiredEventDispatchers.splice(index, 1);
        }
    }
}


/***/ }),

/***/ "./Events.ts":
/*!*******************!*\
  !*** ./Events.ts ***!
  \*******************/
/*! exports provided: EventTypes, GameEvent, KillEvent, PreKillEvent, PostKillEvent, GameStartEvent, GameStopEvent, PreDrawEvent, PostDrawEvent, PreDebugDrawEvent, PostDebugDrawEvent, PreUpdateEvent, PostUpdateEvent, PreFrameEvent, PostFrameEvent, GamepadConnectEvent, GamepadDisconnectEvent, GamepadButtonEvent, GamepadAxisEvent, SubscribeEvent, UnsubscribeEvent, VisibleEvent, HiddenEvent, PreCollisionEvent, PostCollisionEvent, CollisionStartEvent, CollisionEndEvent, InitializeEvent, ActivateEvent, DeactivateEvent, ExitViewPortEvent, EnterViewPortEvent, EnterTriggerEvent, ExitTriggerEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventTypes", function() { return EventTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameEvent", function() { return GameEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KillEvent", function() { return KillEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreKillEvent", function() { return PreKillEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PostKillEvent", function() { return PostKillEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameStartEvent", function() { return GameStartEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameStopEvent", function() { return GameStopEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreDrawEvent", function() { return PreDrawEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PostDrawEvent", function() { return PostDrawEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreDebugDrawEvent", function() { return PreDebugDrawEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PostDebugDrawEvent", function() { return PostDebugDrawEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreUpdateEvent", function() { return PreUpdateEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PostUpdateEvent", function() { return PostUpdateEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreFrameEvent", function() { return PreFrameEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PostFrameEvent", function() { return PostFrameEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GamepadConnectEvent", function() { return GamepadConnectEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GamepadDisconnectEvent", function() { return GamepadDisconnectEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GamepadButtonEvent", function() { return GamepadButtonEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GamepadAxisEvent", function() { return GamepadAxisEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubscribeEvent", function() { return SubscribeEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsubscribeEvent", function() { return UnsubscribeEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VisibleEvent", function() { return VisibleEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HiddenEvent", function() { return HiddenEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreCollisionEvent", function() { return PreCollisionEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PostCollisionEvent", function() { return PostCollisionEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollisionStartEvent", function() { return CollisionStartEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollisionEndEvent", function() { return CollisionEndEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitializeEvent", function() { return InitializeEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActivateEvent", function() { return ActivateEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeactivateEvent", function() { return DeactivateEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExitViewPortEvent", function() { return ExitViewPortEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterViewPortEvent", function() { return EnterViewPortEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterTriggerEvent", function() { return EnterTriggerEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExitTriggerEvent", function() { return ExitTriggerEvent; });
var EventTypes;
(function (EventTypes) {
    EventTypes["Kill"] = "kill";
    EventTypes["PreKill"] = "prekill";
    EventTypes["PostKill"] = "postkill";
    EventTypes["PreDraw"] = "predraw";
    EventTypes["PostDraw"] = "postdraw";
    EventTypes["PreDebugDraw"] = "predebugdraw";
    EventTypes["PostDebugDraw"] = "postdebugdraw";
    EventTypes["PreUpdate"] = "preupdate";
    EventTypes["PostUpdate"] = "postupdate";
    EventTypes["PreFrame"] = "preframe";
    EventTypes["PostFrame"] = "postframe";
    EventTypes["PreCollision"] = "precollision";
    EventTypes["CollisionStart"] = "collisionstart";
    EventTypes["CollisionEnd"] = "collisionend";
    EventTypes["PostCollision"] = "postcollision";
    EventTypes["Initialize"] = "initialize";
    EventTypes["Activate"] = "activate";
    EventTypes["Deactivate"] = "deactivate";
    EventTypes["ExitViewport"] = "exitviewport";
    EventTypes["EnterViewport"] = "enterviewport";
    EventTypes["ExitTrigger"] = "exit";
    EventTypes["EnterTrigger"] = "enter";
    EventTypes["Connect"] = "connect";
    EventTypes["Disconnect"] = "disconnect";
    EventTypes["Button"] = "button";
    EventTypes["Axis"] = "axis";
    EventTypes["Subscribe"] = "subscribe";
    EventTypes["Unsubscribe"] = "unsubscribe";
    EventTypes["Visible"] = "visible";
    EventTypes["Hidden"] = "hidden";
    EventTypes["Start"] = "start";
    EventTypes["Stop"] = "stop";
    EventTypes["PointerUp"] = "pointerup";
    EventTypes["PointerDown"] = "pointerdown";
    EventTypes["PointerMove"] = "pointermove";
    EventTypes["PointerEnter"] = "pointerenter";
    EventTypes["PointerLeave"] = "pointerleave";
    EventTypes["PointerCancel"] = "pointercancel";
    EventTypes["PointerWheel"] = "pointerwheel";
    EventTypes["Up"] = "up";
    EventTypes["Down"] = "down";
    EventTypes["Move"] = "move";
    EventTypes["Enter"] = "enter";
    EventTypes["Leave"] = "leave";
    EventTypes["Cancel"] = "cancel";
    EventTypes["Wheel"] = "wheel";
    EventTypes["Press"] = "press";
    EventTypes["Release"] = "release";
    EventTypes["Hold"] = "hold";
    EventTypes["PointerDragStart"] = "pointerdragstart";
    EventTypes["PointerDragEnd"] = "pointerdragend";
    EventTypes["PointerDragEnter"] = "pointerdragenter";
    EventTypes["PointerDragLeave"] = "pointerdragleave";
    EventTypes["PointerDragMove"] = "pointerdragmove";
})(EventTypes || (EventTypes = {}));
/**
 * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
 * some events are unique to a type, others are not.
 *
 */
class GameEvent {
    constructor() {
        this._bubbles = true;
    }
    /**
     * If set to false, prevents event from propagating to other actors. If true it will be propagated
     * to all actors that apply.
     */
    get bubbles() {
        return this._bubbles;
    }
    set bubbles(value) {
        this._bubbles = value;
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        this.bubbles = false;
    }
}
/**
 * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
 */
class KillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'prekill' event is emitted directly before an actor is killed.
 */
class PreKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'postkill' event is emitted directly after the actor is killed.
 */
class PostKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'start' event is emitted on engine when has started and is ready for interaction.
 */
class GameStartEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
 */
class GameStopEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PreDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PostDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
 */
class PreDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
 */
class PostDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.
 */
class PreUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.
 */
class PostUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'preframe' event is emitted on the engine, before the frame begins.
 */
class PreFrameEvent extends GameEvent {
    constructor(engine, prevStats) {
        super();
        this.engine = engine;
        this.prevStats = prevStats;
        this.target = engine;
    }
}
/**
 * The 'postframe' event is emitted on the engine, after a frame ends.
 */
class PostFrameEvent extends GameEvent {
    constructor(engine, stats) {
        super();
        this.engine = engine;
        this.stats = stats;
        this.target = engine;
    }
}
/**
 * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.
 */
class GamepadConnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.
 */
class GamepadDisconnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadButtonEvent extends GameEvent {
    /**
     * @param button  The Gamepad button
     * @param value   A numeric value between 0 and 1
     */
    constructor(button, value, target) {
        super();
        this.button = button;
        this.value = value;
        this.target = target;
    }
}
/**
 * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadAxisEvent extends GameEvent {
    /**
     * @param axis  The Gamepad axis
     * @param value A numeric value between -1 and 1
     */
    constructor(axis, value, target) {
        super();
        this.axis = axis;
        this.value = value;
        this.target = target;
    }
}
/**
 * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by
 * [[EventDispatcher|event dispatchers]].
 */
class SubscribeEvent extends GameEvent {
    constructor(topic, handler) {
        super();
        this.topic = topic;
        this.handler = handler;
    }
}
/**
 * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by
 * [[EventDispatcher|event dispatchers]].
 */
class UnsubscribeEvent extends GameEvent {
    constructor(topic, handler) {
        super();
        this.topic = topic;
        this.handler = handler;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is visible on a screen.
 */
class VisibleEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is hidden from all screens.
 */
class HiddenEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves
 */
class PreCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that will collided with the current actor
     * @param side          The side that will be collided with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame
 */
class PostCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that did collide with the current actor
     * @param side          The side that did collide with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.
 */
class CollisionStartEvent extends GameEvent {
    /**
     *
     * @param actor
     * @param other
     * @param pair
     */
    constructor(actor, other, pair) {
        super();
        this.other = other;
        this.pair = pair;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown when the [[Actor|actor]] is no longer colliding with another
 */
class CollisionEndEvent extends GameEvent {
    /**
     *
     */
    constructor(actor, other) {
        super();
        this.other = other;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call
 */
class InitializeEvent extends GameEvent {
    /**
     * @param engine  The reference to the current engine
     */
    constructor(engine, target) {
        super();
        this.engine = engine;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on activation
 */
class ActivateEvent extends GameEvent {
    /**
     * @param oldScene  The reference to the old scene
     */
    constructor(oldScene, target) {
        super();
        this.oldScene = oldScene;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on deactivation
 */
class DeactivateEvent extends GameEvent {
    /**
     * @param newScene  The reference to the new scene
     */
    constructor(newScene, target) {
        super();
        this.newScene = newScene;
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class ExitViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class EnterViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
class EnterTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}
class ExitTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}


/***/ }),

/***/ "./Events/MediaEvents.ts":
/*!*******************************!*\
  !*** ./Events/MediaEvents.ts ***!
  \*******************************/
/*! exports provided: MediaEvent, NativeSoundEvent, NativeSoundProcessedEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MediaEvent", function() { return MediaEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NativeSoundEvent", function() { return NativeSoundEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NativeSoundProcessedEvent", function() { return NativeSoundProcessedEvent; });
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Events */ "./Events.ts");

class MediaEvent extends _Events__WEBPACK_IMPORTED_MODULE_0__["GameEvent"] {
    constructor(target, _name = 'MediaEvent') {
        super();
        this.target = target;
        this._name = _name;
    }
    /**
     * Media event cannot bubble
     */
    set bubbles(_value) {
        // stubbed
    }
    /**
     * Media event cannot bubble
     */
    get bubbles() {
        return false;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    get _path() {
        return null;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    set _path(_val) {
        // stubbed
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        /**
         * Stub
         */
    }
    /**
     * Action, that calls when event happens
     */
    action() {
        /**
         * Stub
         */
    }
    /**
     * Propagate event further through event path
     */
    propagate() {
        /**
         * Stub
         */
    }
    layPath(_actor) {
        /**
         * Stub
         */
    }
}
class NativeSoundEvent extends MediaEvent {
    constructor(target, track) {
        super(target, 'NativeSoundEvent');
        this.track = track;
    }
}
class NativeSoundProcessedEvent extends MediaEvent {
    constructor(target, _processedData) {
        super(target, 'NativeSoundProcessedEvent');
        this._processedData = _processedData;
        this.data = this._processedData;
    }
}


/***/ }),

/***/ "./Flags.ts":
/*!******************!*\
  !*** ./Flags.ts ***!
  \******************/
/*! exports provided: Flags */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Flags", function() { return Flags; });
/**
 * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**
 * after which they are frozen and are read-only.
 *
 * Flags are used to enable experimental or preview features in Excalibur.
 */
class Flags {
    /**
     * Freeze all flag modifications making them readonly
     */
    static freeze() {
        Flags._FROZEN = true;
    }
    /**
     * Resets internal flag state, not meant to be called by users. Only used for testing.
     *
     * Calling this in your game is UNSUPPORTED
     * @internal
     */
    static _reset() {
        Flags._FROZEN = false;
        Flags._FLAGS = {};
    }
    /**
     * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static enable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be enabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = true;
    }
    /**
     * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static disable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be disabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = false;
    }
    /**
     * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned
     * @param flagName
     */
    static isEnabled(flagName) {
        return !!Flags._FLAGS[flagName];
    }
    /**
     * Show a list of currently known flags
     */
    static show() {
        return Object.keys(Flags._FLAGS);
    }
}
Flags._FROZEN = false;
Flags._FLAGS = {};


/***/ }),

/***/ "./Input/EngineInput.ts":
/*!******************************!*\
  !*** ./Input/EngineInput.ts ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Input/Gamepad.ts":
/*!**************************!*\
  !*** ./Input/Gamepad.ts ***!
  \**************************/
/*! exports provided: Gamepads, Gamepad, Buttons, Axes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gamepads", function() { return Gamepads; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gamepad", function() { return Gamepad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Buttons", function() { return Buttons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Axes", function() { return Axes; });
/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../Class */ "./Class.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Events */ "./Events.ts");


/**
 * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
 * to provide controller support for your games.
 */
class Gamepads extends _Class__WEBPACK_IMPORTED_MODULE_0__["Class"] {
    constructor() {
        super();
        /**
         * Whether or not to poll for Gamepad input (default: `false`)
         */
        this.enabled = false;
        /**
         * Whether or not Gamepad API is supported
         */
        this.supported = !!navigator.getGamepads;
        this._gamePadTimeStamps = [0, 0, 0, 0];
        this._oldPads = [];
        this._pads = [];
        this._initSuccess = false;
        this._navigator = navigator;
        this._minimumConfiguration = null;
    }
    init() {
        if (!this.supported) {
            return;
        }
        if (this._initSuccess) {
            return;
        }
        // In Chrome, this will return 4 undefined items until a button is pressed
        // In FF, this will not return any items until a button is pressed
        this._oldPads = this._clonePads(this._navigator.getGamepads());
        if (this._oldPads.length && this._oldPads[0]) {
            this._initSuccess = true;
        }
    }
    /**
     * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
     * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
     * all other controllers with more axis or buttons are valid as well. If no minimum
     * configuration is set all pads are valid.
     */
    setMinimumGamepadConfiguration(config) {
        this._enableAndUpdate(); // if config is used, implicitly enable
        this._minimumConfiguration = config;
    }
    /**
     * When implicitly enabled, set the enabled flag and run an update so information is updated
     */
    _enableAndUpdate() {
        if (!this.enabled) {
            this.enabled = true;
            this.update();
        }
    }
    /**
     * Checks a navigator gamepad against the minimum configuration if present.
     */
    _isGamepadValid(pad) {
        if (!this._minimumConfiguration) {
            return true;
        }
        if (!pad) {
            return false;
        }
        const axesLength = pad.axes.filter((value) => {
            return typeof value !== undefined;
        }).length;
        const buttonLength = pad.buttons.filter((value) => {
            return typeof value !== undefined;
        }).length;
        return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;
    }
    on(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.off(eventName, handler);
    }
    /**
     * Updates Gamepad state and publishes Gamepad events
     */
    update() {
        if (!this.enabled || !this.supported) {
            return;
        }
        this.init();
        const gamepads = this._navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (!gamepads[i]) {
                const gamepad = this.at(i);
                // If was connected, but now isn't emit the disconnect event
                if (gamepad.connected) {
                    this.eventDispatcher.emit('disconnect', new _Events__WEBPACK_IMPORTED_MODULE_1__["GamepadDisconnectEvent"](i, gamepad));
                }
                // Reset connection status
                gamepad.connected = false;
                continue;
            }
            else {
                if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                    this.eventDispatcher.emit('connect', new _Events__WEBPACK_IMPORTED_MODULE_1__["GamepadConnectEvent"](i, this.at(i)));
                }
                // Set connection status
                this.at(i).connected = true;
            }
            // Only supported in Chrome
            if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                continue;
            }
            this._gamePadTimeStamps[i] = gamepads[i].timestamp;
            // Add reference to navigator gamepad
            this.at(i).navigatorGamepad = gamepads[i];
            // Buttons
            let b, bi, a, ai, value;
            for (b in Buttons) {
                bi = Buttons[b];
                if (typeof bi === 'number') {
                    if (gamepads[i].buttons[bi]) {
                        value = gamepads[i].buttons[bi].value;
                        if (value !== this._oldPads[i].getButton(bi)) {
                            if (gamepads[i].buttons[bi].pressed) {
                                this.at(i).updateButton(bi, value);
                                this.at(i).eventDispatcher.emit('button', new _Events__WEBPACK_IMPORTED_MODULE_1__["GamepadButtonEvent"](bi, value, this.at(i)));
                            }
                            else {
                                this.at(i).updateButton(bi, 0);
                            }
                        }
                    }
                }
            }
            // Axes
            for (a in Axes) {
                ai = Axes[a];
                if (typeof ai === 'number') {
                    value = gamepads[i].axes[ai];
                    if (value !== this._oldPads[i].getAxes(ai)) {
                        this.at(i).updateAxes(ai, value);
                        this.at(i).eventDispatcher.emit('axis', new _Events__WEBPACK_IMPORTED_MODULE_1__["GamepadAxisEvent"](ai, value, this.at(i)));
                    }
                }
            }
            this._oldPads[i] = this._clonePad(gamepads[i]);
        }
    }
    /**
     * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
     */
    at(index) {
        this._enableAndUpdate(); // implicitly enable gamepads when at() is called
        if (index >= this._pads.length) {
            // Ensure there is a pad to retrieve
            for (let i = this._pads.length - 1, max = index; i < max; i++) {
                this._pads.push(new Gamepad());
                this._oldPads.push(new Gamepad());
            }
        }
        return this._pads[index];
    }
    /**
     * Returns a list of all valid gamepads that meet the minimum configuration requirement.
     */
    getValidGamepads() {
        this._enableAndUpdate();
        const result = [];
        for (let i = 0; i < this._pads.length; i++) {
            if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                result.push(this.at(i));
            }
        }
        return result;
    }
    /**
     * Gets the number of connected gamepads
     */
    count() {
        return this._pads.filter((p) => p.connected).length;
    }
    _clonePads(pads) {
        const arr = [];
        for (let i = 0, len = pads.length; i < len; i++) {
            arr.push(this._clonePad(pads[i]));
        }
        return arr;
    }
    /**
     * Fastest way to clone a known object is to do it yourself
     */
    _clonePad(pad) {
        let i, len;
        const clonedPad = new Gamepad();
        if (!pad) {
            return clonedPad;
        }
        for (i = 0, len = pad.buttons.length; i < len; i++) {
            if (pad.buttons[i]) {
                clonedPad.updateButton(i, pad.buttons[i].value);
            }
        }
        for (i = 0, len = pad.axes.length; i < len; i++) {
            clonedPad.updateAxes(i, pad.axes[i]);
        }
        return clonedPad;
    }
}
/**
 * The minimum value an axis has to move before considering it a change
 */
Gamepads.MinAxisMoveThreshold = 0.05;
/**
 * Gamepad holds state information for a connected controller. See [[Gamepads]]
 * for more information on handling controller input.
 */
class Gamepad extends _Class__WEBPACK_IMPORTED_MODULE_0__["Class"] {
    constructor() {
        super();
        this.connected = false;
        this._buttons = new Array(16);
        this._axes = new Array(4);
        for (let i = 0; i < this._buttons.length; i++) {
            this._buttons[i] = 0;
        }
        for (let i = 0; i < this._axes.length; i++) {
            this._axes[i] = 0;
        }
    }
    /**
     * Whether or not the given button is pressed
     * @param button     The button to query
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    isButtonPressed(button, threshold = 1) {
        return this._buttons[button] >= threshold;
    }
    /**
     * Gets the given button value between 0 and 1
     */
    getButton(button) {
        return this._buttons[button];
    }
    /**
     * Gets the given axis value between -1 and 1. Values below
     * [[MinAxisMoveThreshold]] are considered 0.
     */
    getAxes(axes) {
        const value = this._axes[axes];
        if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
            return 0;
        }
        else {
            return value;
        }
    }
    updateButton(buttonIndex, value) {
        this._buttons[buttonIndex] = value;
    }
    updateAxes(axesIndex, value) {
        this._axes[axesIndex] = value;
    }
}
/**
 * Gamepad Buttons enumeration
 */
var Buttons;
(function (Buttons) {
    /**
     * Face 1 button (e.g. A)
     */
    Buttons[Buttons["Face1"] = 0] = "Face1";
    /**
     * Face 2 button (e.g. B)
     */
    Buttons[Buttons["Face2"] = 1] = "Face2";
    /**
     * Face 3 button (e.g. X)
     */
    Buttons[Buttons["Face3"] = 2] = "Face3";
    /**
     * Face 4 button (e.g. Y)
     */
    Buttons[Buttons["Face4"] = 3] = "Face4";
    /**
     * Left bumper button
     */
    Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
    /**
     * Right bumper button
     */
    Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
    /**
     * Left trigger button
     */
    Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
    /**
     * Right trigger button
     */
    Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
    /**
     * Select button
     */
    Buttons[Buttons["Select"] = 8] = "Select";
    /**
     * Start button
     */
    Buttons[Buttons["Start"] = 9] = "Start";
    /**
     * Left analog stick press (e.g. L3)
     */
    Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
    /**
     * Right analog stick press (e.g. R3)
     */
    Buttons[Buttons["RightStick"] = 11] = "RightStick";
    /**
     * D-pad up
     */
    Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
    /**
     * D-pad down
     */
    Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
    /**
     * D-pad left
     */
    Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
    /**
     * D-pad right
     */
    Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
})(Buttons || (Buttons = {}));
/**
 * Gamepad Axes enumeration
 */
var Axes;
(function (Axes) {
    /**
     * Left analogue stick X direction
     */
    Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
    /**
     * Left analogue stick Y direction
     */
    Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
    /**
     * Right analogue stick X direction
     */
    Axes[Axes["RightStickX"] = 2] = "RightStickX";
    /**
     * Right analogue stick Y direction
     */
    Axes[Axes["RightStickY"] = 3] = "RightStickY";
})(Axes || (Axes = {}));


/***/ }),

/***/ "./Input/Index.ts":
/*!************************!*\
  !*** ./Input/Index.ts ***!
  \************************/
/*! exports provided: Gamepads, Gamepad, Buttons, Axes, PointerType, PointerScope, Pointer, Pointers, NativePointerButton, PointerButton, WheelDeltaMode, PointerEvent, PointerEventFactory, PointerDragEvent, PointerUpEvent, PointerDownEvent, PointerMoveEvent, PointerEnterEvent, PointerLeaveEvent, PointerCancelEvent, WheelEvent, createPointerEventByName, Keys, KeyEvent, Keyboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Gamepad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Gamepad */ "./Input/Gamepad.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Gamepads", function() { return _Gamepad__WEBPACK_IMPORTED_MODULE_0__["Gamepads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Gamepad", function() { return _Gamepad__WEBPACK_IMPORTED_MODULE_0__["Gamepad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Buttons", function() { return _Gamepad__WEBPACK_IMPORTED_MODULE_0__["Buttons"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Axes", function() { return _Gamepad__WEBPACK_IMPORTED_MODULE_0__["Axes"]; });

/* harmony import */ var _Pointer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pointer */ "./Input/Pointer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerType", function() { return _Pointer__WEBPACK_IMPORTED_MODULE_1__["PointerType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerScope", function() { return _Pointer__WEBPACK_IMPORTED_MODULE_1__["PointerScope"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pointer", function() { return _Pointer__WEBPACK_IMPORTED_MODULE_1__["Pointer"]; });

/* harmony import */ var _Pointers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pointers */ "./Input/Pointers.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pointers", function() { return _Pointers__WEBPACK_IMPORTED_MODULE_2__["Pointers"]; });

/* harmony import */ var _PointerEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PointerEvents */ "./Input/PointerEvents.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NativePointerButton", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["NativePointerButton"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerButton", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerButton"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WheelDeltaMode", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["WheelDeltaMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerEvent", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerEventFactory", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerEventFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerDragEvent", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerDragEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerUpEvent", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerUpEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerDownEvent", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerDownEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerMoveEvent", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerMoveEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerEnterEvent", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerEnterEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerLeaveEvent", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerLeaveEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerCancelEvent", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerCancelEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WheelEvent", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["WheelEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPointerEventByName", function() { return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["createPointerEventByName"]; });

/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Keyboard */ "./Input/Keyboard.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Keys", function() { return _Keyboard__WEBPACK_IMPORTED_MODULE_4__["Keys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyEvent", function() { return _Keyboard__WEBPACK_IMPORTED_MODULE_4__["KeyEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Keyboard", function() { return _Keyboard__WEBPACK_IMPORTED_MODULE_4__["Keyboard"]; });

/* harmony import */ var _EngineInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EngineInput */ "./Input/EngineInput.ts");
/* empty/unused harmony star reexport *//**
 * Provides support for mice, keyboards, and controllers.
 */
/**
 * @typedoc
 */








/***/ }),

/***/ "./Input/Keyboard.ts":
/*!***************************!*\
  !*** ./Input/Keyboard.ts ***!
  \***************************/
/*! exports provided: Keys, KeyEvent, Keyboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Keys", function() { return Keys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyEvent", function() { return KeyEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Keyboard", function() { return Keyboard; });
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Class */ "./Class.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Events */ "./Events.ts");



/**
 * Enum representing input key codes
 */
var Keys;
(function (Keys) {
    // NUMPAD
    Keys["Num0"] = "Numpad0";
    Keys["Num1"] = "Numpad1";
    Keys["Num2"] = "Numpad2";
    Keys["Num3"] = "Numpad3";
    Keys["Num4"] = "Numpad4";
    Keys["Num5"] = "Numpad5";
    Keys["Num6"] = "Numpad6";
    Keys["Num7"] = "Numpad7";
    Keys["Num8"] = "Numpad8";
    Keys["Num9"] = "Numpad9";
    Keys["NumAdd"] = "NumpadAdd";
    Keys["NumSubtract"] = "NumpadSubtract";
    Keys["NumMultiply"] = "NumpadMultiply";
    Keys["NumDivide"] = "NumpadDivide";
    // NumComma = 'NumpadComma', // not x-browser
    Keys["NumDecimal"] = "NumpadDecimal";
    Keys["Numpad0"] = "Numpad0";
    Keys["Numpad1"] = "Numpad1";
    Keys["Numpad2"] = "Numpad2";
    Keys["Numpad3"] = "Numpad3";
    Keys["Numpad4"] = "Numpad4";
    Keys["Numpad5"] = "Numpad5";
    Keys["Numpad6"] = "Numpad6";
    Keys["Numpad7"] = "Numpad7";
    Keys["Numpad8"] = "Numpad8";
    Keys["Numpad9"] = "Numpad9";
    Keys["NumpadAdd"] = "NumpadAdd";
    Keys["NumpadSubtract"] = "NumpadSubtract";
    Keys["NumpadMultiply"] = "NumpadMultiply";
    Keys["NumpadDivide"] = "NumpadDivide";
    // NumpadComma = 'NumpadComma', // not x-browser
    Keys["NumpadDecimal"] = "NumpadDecimal";
    // MODIFIERS
    Keys["NumLock"] = "NumLock";
    Keys["ShiftLeft"] = "ShiftLeft";
    Keys["ShiftRight"] = "ShiftRight";
    Keys["AltLeft"] = "AltLeft";
    Keys["AltRight"] = "AltRight";
    // NUMBERS
    Keys["Key0"] = "Digit0";
    Keys["Key1"] = "Digit1";
    Keys["Key2"] = "Digit2";
    Keys["Key3"] = "Digit3";
    Keys["Key4"] = "Digit4";
    Keys["Key5"] = "Digit5";
    Keys["Key6"] = "Digit6";
    Keys["Key7"] = "Digit7";
    Keys["Key8"] = "Digit8";
    Keys["Key9"] = "Digit9";
    Keys["Digit0"] = "Digit0";
    Keys["Digit1"] = "Digit1";
    Keys["Digit2"] = "Digit2";
    Keys["Digit3"] = "Digit3";
    Keys["Digit4"] = "Digit4";
    Keys["Digit5"] = "Digit5";
    Keys["Digit6"] = "Digit6";
    Keys["Digit7"] = "Digit7";
    Keys["Digit8"] = "Digit8";
    Keys["Digit9"] = "Digit9";
    // LETTERS
    Keys["A"] = "KeyA";
    Keys["B"] = "KeyB";
    Keys["C"] = "KeyC";
    Keys["D"] = "KeyD";
    Keys["E"] = "KeyE";
    Keys["F"] = "KeyF";
    Keys["G"] = "KeyG";
    Keys["H"] = "KeyH";
    Keys["I"] = "KeyI";
    Keys["J"] = "KeyJ";
    Keys["K"] = "KeyK";
    Keys["L"] = "KeyL";
    Keys["M"] = "KeyM";
    Keys["N"] = "KeyN";
    Keys["O"] = "KeyO";
    Keys["P"] = "KeyP";
    Keys["Q"] = "KeyQ";
    Keys["R"] = "KeyR";
    Keys["S"] = "KeyS";
    Keys["T"] = "KeyT";
    Keys["U"] = "KeyU";
    Keys["V"] = "KeyV";
    Keys["W"] = "KeyW";
    Keys["X"] = "KeyX";
    Keys["Y"] = "KeyY";
    Keys["Z"] = "KeyZ";
    Keys["KeyA"] = "KeyA";
    Keys["KeyB"] = "KeyB";
    Keys["KeyC"] = "KeyC";
    Keys["KeyD"] = "KeyD";
    Keys["KeyE"] = "KeyE";
    Keys["KeyF"] = "KeyF";
    Keys["KeyG"] = "KeyG";
    Keys["KeyH"] = "KeyH";
    Keys["KeyI"] = "KeyI";
    Keys["KeyJ"] = "KeyJ";
    Keys["KeyK"] = "KeyK";
    Keys["KeyL"] = "KeyL";
    Keys["KeyM"] = "KeyM";
    Keys["KeyN"] = "KeyN";
    Keys["KeyO"] = "KeyO";
    Keys["KeyP"] = "KeyP";
    Keys["KeyQ"] = "KeyQ";
    Keys["KeyR"] = "KeyR";
    Keys["KeyS"] = "KeyS";
    Keys["KeyT"] = "KeyT";
    Keys["KeyU"] = "KeyU";
    Keys["KeyV"] = "KeyV";
    Keys["KeyW"] = "KeyW";
    Keys["KeyX"] = "KeyX";
    Keys["KeyY"] = "KeyY";
    Keys["KeyZ"] = "KeyZ";
    // SYMBOLS
    Keys["Semicolon"] = "Semicolon";
    Keys["Quote"] = "Quote";
    Keys["Comma"] = "Comma";
    Keys["Minus"] = "Minus";
    Keys["Period"] = "Period";
    Keys["Slash"] = "Slash";
    Keys["Equal"] = "Equal";
    Keys["BracketLeft"] = "BracketLeft";
    Keys["Backslash"] = "Backslash";
    Keys["BracketRight"] = "BracketRight";
    Keys["Backquote"] = "Backquote";
    // DIRECTIONS
    Keys["Up"] = "ArrowUp";
    Keys["Down"] = "ArrowDown";
    Keys["Left"] = "ArrowLeft";
    Keys["Right"] = "ArrowRight";
    Keys["ArrowUp"] = "ArrowUp";
    Keys["ArrowDown"] = "ArrowDown";
    Keys["ArrowLeft"] = "ArrowLeft";
    Keys["ArrowRight"] = "ArrowRight";
    // OTHER
    Keys["Space"] = "Space";
    Keys["Esc"] = "Escape";
    Keys["Escape"] = "Escape";
})(Keys || (Keys = {}));
/**
 * Event thrown on a game object for a key event
 */
class KeyEvent extends _Events__WEBPACK_IMPORTED_MODULE_2__["GameEvent"] {
    /**
     * @param key  The key responsible for throwing the event
     */
    constructor(key) {
        super();
        this.key = key;
    }
}
/**
 * Provides keyboard support for Excalibur.
 */
class Keyboard extends _Class__WEBPACK_IMPORTED_MODULE_1__["Class"] {
    constructor() {
        super();
        this._keys = [];
        this._keysUp = [];
        this._keysDown = [];
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    /**
     * Initialize Keyboard event listeners
     */
    init(global) {
        if (!global) {
            try {
                // Try and listen to events on top window frame if within an iframe.
                //
                // See https://github.com/excaliburjs/Excalibur/issues/1294
                //
                // Attempt to add an event listener, which triggers a DOMException on
                // cross-origin iframes
                const noop = () => {
                    return;
                };
                window.top.addEventListener('blur', noop);
                window.top.removeEventListener('blur', noop);
                // this will be the same as window if not embedded within an iframe
                global = window.top;
            }
            catch (_a) {
                // fallback to current frame
                global = window;
                _Util_Log__WEBPACK_IMPORTED_MODULE_0__["Logger"].getInstance().warn('Failed to bind to keyboard events to top frame. ' +
                    'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.');
            }
        }
        global.addEventListener('blur', () => {
            this._keys.length = 0; // empties array efficiently
        });
        // key up is on window because canvas cannot have focus
        global.addEventListener('keyup', (ev) => {
            const code = ev.code;
            const key = this._keys.indexOf(code);
            this._keys.splice(key, 1);
            this._keysUp.push(code);
            const keyEvent = new KeyEvent(code);
            // alias the old api, we may want to deprecate this in the future
            this.eventDispatcher.emit('up', keyEvent);
            this.eventDispatcher.emit('release', keyEvent);
        });
        // key down is on window because canvas cannot have focus
        global.addEventListener('keydown', (ev) => {
            const code = ev.code;
            if (this._keys.indexOf(code) === -1) {
                this._keys.push(code);
                this._keysDown.push(code);
                const keyEvent = new KeyEvent(code);
                this.eventDispatcher.emit('down', keyEvent);
                this.eventDispatcher.emit('press', keyEvent);
            }
        });
    }
    update() {
        // Reset keysDown and keysUp after update is complete
        this._keysDown.length = 0;
        this._keysUp.length = 0;
        // Emit synthetic "hold" event
        for (let i = 0; i < this._keys.length; i++) {
            this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));
        }
    }
    /**
     * Gets list of keys being pressed down
     */
    getKeys() {
        return this._keys;
    }
    /**
     * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
     * @param key Test whether a key was just pressed
     */
    wasPressed(key) {
        return this._keysDown.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key is held down. This is persisted between frames.
     * @param key  Test whether a key is held down
     */
    isHeld(key) {
        return this._keys.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
     * @param key  Test whether a key was just released
     */
    wasReleased(key) {
        return this._keysUp.indexOf(key) > -1;
    }
}


/***/ }),

/***/ "./Input/Pointer.ts":
/*!**************************!*\
  !*** ./Input/Pointer.ts ***!
  \**************************/
/*! exports provided: PointerType, PointerScope, Pointer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerType", function() { return PointerType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerScope", function() { return PointerScope; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pointer", function() { return Pointer; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Class */ "./Class.ts");
/* harmony import */ var _Util_Actors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util/Actors */ "./Util/Actors.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Util/Util */ "./Util/Util.ts");




/**
 * The type of pointer for a [[PointerEvent]].
 */
var PointerType;
(function (PointerType) {
    PointerType["Touch"] = "Touch";
    PointerType["Mouse"] = "Mouse";
    PointerType["Pen"] = "Pen";
    PointerType["Unknown"] = "Unknown";
})(PointerType || (PointerType = {}));
/**
 * Determines the scope of handling mouse/touch events. See [[Pointers]] for more information.
 */
var PointerScope;
(function (PointerScope) {
    /**
     * Handle events on the `canvas` element only. Events originating outside the
     * `canvas` will not be handled.
     */
    PointerScope["Canvas"] = "Canvas";
    /**
     * Handles events on the entire document. All events will be handled by Excalibur.
     */
    PointerScope["Document"] = "Document";
})(PointerScope || (PointerScope = {}));
/**
 * Captures and dispatches PointerEvents
 */
class Pointer extends _Class__WEBPACK_IMPORTED_MODULE_1__["Class"] {
    constructor() {
        super();
        this.id = Pointer._MAX_ID++;
        this._isDown = false;
        this._wasDown = false;
        this._actorsUnderPointer = { length: 0 };
        this._actors = [];
        this._actorsLastFrame = [];
        this._actorsNoLongerUnderPointer = [];
        /**
         * The last position on the document this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastPagePos = null;
        /**
         * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastScreenPos = null;
        /**
         * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastWorldPos = null;
        /**
         * Returns the currently dragging target or null if it isn't exist
         */
        this.dragTarget = null;
        this.on('move', this._onPointerMove);
        this.on('down', this._onPointerDown);
        this.on('up', this._onPointerUp);
    }
    /**
     * Whether the Pointer is currently dragging.
     */
    get isDragging() {
        return this._isDown;
    }
    /**
     * Whether the Pointer just started dragging.
     */
    get isDragStart() {
        return !this._wasDown && this._isDown;
    }
    /**
     * Whether the Pointer just ended dragging.
     */
    get isDragEnd() {
        return this._wasDown && !this._isDown;
    }
    /**
     * Returns true if pointer has any actors under
     */
    get hasActorsUnderPointer() {
        return !!this._actorsUnderPointer.length;
    }
    on(event, handler) {
        super.on(event, handler);
    }
    once(event, handler) {
        super.once(event, handler);
    }
    off(event, handler) {
        super.off(event, handler);
    }
    /**
     * Update the state of current pointer, meant to be called a the end of frame
     */
    update() {
        if (this._wasDown && !this._isDown) {
            this._wasDown = false;
        }
        else if (!this._wasDown && this._isDown) {
            this._wasDown = true;
        }
        this._actorsLastFrame = [...this._actors];
        this._actorsNoLongerUnderPointer = [];
    }
    /**
     * Adds an Actor to actorsUnderPointer object.
     * @param actor An Actor to be added;
     */
    addActorUnderPointer(actor) {
        if (!this.isActorAliveUnderPointer(actor)) {
            this._actorsUnderPointer[actor.id] = actor;
            this._actorsUnderPointer.length += 1;
            this._actors.push(actor);
        }
        // Actors under the pointer are sorted by z, ties are broken by id
        this._actors.sort((a, b) => {
            if (a.z === b.z) {
                return a.id - b.id;
            }
            return a.z - b.z;
        });
    }
    /**
     * Removes an Actor from actorsUnderPointer object.
     * @param actor An Actor to be removed;
     */
    removeActorUnderPointer(actor) {
        if (this.isActorAliveUnderPointer(actor)) {
            delete this._actorsUnderPointer[actor.id];
            this._actorsUnderPointer.length -= 1;
            Object(_Util_Util__WEBPACK_IMPORTED_MODULE_3__["removeItemFromArray"])(actor, this._actors);
            this._actorsNoLongerUnderPointer.push(actor);
        }
    }
    /**
     * Returns all actors under this pointer this frame
     */
    getActorsUnderPointer() {
        return this._actors;
    }
    /**
     * Returns all actors that are no longer under the pointer this frame
     */
    getActorsUnderPointerLastFrame() {
        return this._actorsLastFrame;
    }
    /**
     * Returns all actors relevant for events to pointer this frame
     */
    getActorsForEvents() {
        return this._actors.concat(this._actorsLastFrame).filter((actor, i, self) => {
            return self.indexOf(actor) === i;
        });
    }
    /**
     * Checks if Pointer location has a specific Actor bounds contained underneath.
     * @param actor An Actor for check;
     */
    checkActorUnderPointer(actor) {
        if (this.lastWorldPos) {
            return actor.contains(this.lastWorldPos.x, this.lastWorldPos.y, !_Util_Actors__WEBPACK_IMPORTED_MODULE_2__["isScreenElement"](actor));
        }
        return false;
    }
    /**
     * Checks if an actor was under the pointer last frame
     * @param actor
     */
    wasActorUnderPointer(actor) {
        return this._actorsLastFrame.indexOf(actor) > -1; // || !!this._actorsUnderPointerLastFrame.hasOwnProperty(actor.id.toString());
    }
    /**
     * Checks if Pointer has a specific Actor in ActorsUnderPointer list.
     * @param actor An Actor for check;
     */
    isActorAliveUnderPointer(actor) {
        return !!(!actor.isKilled() && actor.scene && this._actorsUnderPointer.hasOwnProperty(actor.id.toString()));
    }
    _onPointerMove(ev) {
        this.lastPagePos = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](ev.pagePos.x, ev.pagePos.y);
        this.lastScreenPos = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](ev.screenPos.x, ev.screenPos.y);
        this.lastWorldPos = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](ev.worldPos.x, ev.worldPos.y);
    }
    _onPointerDown(ev) {
        this.lastPagePos = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](ev.pagePos.x, ev.pagePos.y);
        this.lastScreenPos = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](ev.screenPos.x, ev.screenPos.y);
        this.lastWorldPos = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](ev.worldPos.x, ev.worldPos.y);
        this._isDown = true;
    }
    _onPointerUp(_ev) {
        this._isDown = false;
        this.dragTarget = null;
    }
}
Pointer._MAX_ID = 0;


/***/ }),

/***/ "./Input/PointerEvents.ts":
/*!********************************!*\
  !*** ./Input/PointerEvents.ts ***!
  \********************************/
/*! exports provided: NativePointerButton, PointerButton, WheelDeltaMode, PointerEvent, PointerEventFactory, PointerDragEvent, PointerUpEvent, PointerDownEvent, PointerMoveEvent, PointerEnterEvent, PointerLeaveEvent, PointerCancelEvent, WheelEvent, createPointerEventByName */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NativePointerButton", function() { return NativePointerButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerButton", function() { return PointerButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WheelDeltaMode", function() { return WheelDeltaMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerEvent", function() { return PointerEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerEventFactory", function() { return PointerEventFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerDragEvent", function() { return PointerDragEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerUpEvent", function() { return PointerUpEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerDownEvent", function() { return PointerDownEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerMoveEvent", function() { return PointerMoveEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerEnterEvent", function() { return PointerEnterEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerLeaveEvent", function() { return PointerLeaveEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerCancelEvent", function() { return PointerCancelEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WheelEvent", function() { return WheelEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPointerEventByName", function() { return createPointerEventByName; });
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Events */ "./Events.ts");

/**
 * Native browser button enumeration
 */
var NativePointerButton;
(function (NativePointerButton) {
    NativePointerButton[NativePointerButton["NoButton"] = -1] = "NoButton";
    NativePointerButton[NativePointerButton["Left"] = 0] = "Left";
    NativePointerButton[NativePointerButton["Middle"] = 1] = "Middle";
    NativePointerButton[NativePointerButton["Right"] = 2] = "Right";
    NativePointerButton[NativePointerButton["Unknown"] = 3] = "Unknown";
})(NativePointerButton || (NativePointerButton = {}));
/**
 * The mouse button being pressed.
 */
var PointerButton;
(function (PointerButton) {
    PointerButton["Left"] = "Left";
    PointerButton["Middle"] = "Middle";
    PointerButton["Right"] = "Right";
    PointerButton["Unknown"] = "Unknown";
    PointerButton["NoButton"] = "NoButton";
})(PointerButton || (PointerButton = {}));
var WheelDeltaMode;
(function (WheelDeltaMode) {
    WheelDeltaMode["Pixel"] = "Pixel";
    WheelDeltaMode["Line"] = "Line";
    WheelDeltaMode["Page"] = "Page";
})(WheelDeltaMode || (WheelDeltaMode = {}));
/**
 * Pointer events
 *
 * Represents a mouse, touch, or stylus event. See [[Pointers]] for more information on
 * handling pointer input.
 *
 * For mouse-based events, you can inspect [[PointerEvent.button]] to see what button was pressed.
 */
class PointerEvent extends _Events__WEBPACK_IMPORTED_MODULE_0__["GameEvent"] {
    /**
     * @param coordinates         The [[GlobalCoordinates]] of the event
     * @param pointer             The [[Pointer]] of the event
     * @param index               The index of the pointer (zero-based)
     * @param pointerType         The type of pointer
     * @param button              The button pressed (if [[PointerType.Mouse]])
     * @param ev                  The raw DOM event being handled
     */
    constructor(coordinates, pointer, index, pointerType, button, ev) {
        super();
        this.coordinates = coordinates;
        this.pointer = pointer;
        this.index = index;
        this.pointerType = pointerType;
        this.button = button;
        this.ev = ev;
    }
    get name() {
        return this._name;
    }
    /** The world coordinates of the event. */
    get worldPos() {
        return this.coordinates.worldPos.clone();
    }
    /** The page coordinates of the event. */
    get pagePos() {
        return this.coordinates.pagePos.clone();
    }
    /** The screen coordinates of the event. */
    get screenPos() {
        return this.coordinates.screenPos.clone();
    }
    get pos() {
        return this.coordinates.worldPos.clone();
    }
    propagate(actor) {
        this.doAction(actor);
        if (this.bubbles && actor.parent) {
            this.propagate(actor.parent);
        }
    }
    /**
     * Action, that calls when event happens
     */
    doAction(actor) {
        if (actor) {
            this._onActionStart(actor);
            actor.emit(this._name, this);
            this._onActionEnd(actor);
        }
    }
    _onActionStart(_actor) {
        // to be rewritten
    }
    _onActionEnd(_actor) {
        // to be rewritten
    }
}
class PointerEventFactory {
    constructor(_pointerEventType) {
        this._pointerEventType = _pointerEventType;
    }
    /**
     * Create specific PointerEvent
     */
    create(coordinates, pointer, index, pointerType, button, ev) {
        return new this._pointerEventType(coordinates, pointer, index, pointerType, button, ev);
    }
}
class PointerDragEvent extends PointerEvent {
}
class PointerUpEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerup';
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragEnd && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragend', this);
        }
    }
}
class PointerDownEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerdown';
    }
    _onActionEnd(actor) {
        if (this.pointer.isDragStart && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragstart', this);
        }
    }
}
class PointerMoveEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointermove';
        // private _onActorEnter(actor: Actor) {
        //   const pe = createPointerEventByName('enter', this.coordinates, this.pointer, this.index, this.pointerType, this.button, this.ev);
        //   pe.propagate(actor);
        //   this.pointer.addActorUnderPointer(actor);
        //   if (this.pointer.isDragging) {
        //     this.pointer.dragTarget = actor;
        //   }
        // }
        // private _onActorLeave(actor: Actor) {
        //   const pe = createPointerEventByName('leave', this.coordinates, this.pointer, this.index, this.pointerType, this.button, this.ev);
        //   pe.propagate(actor);
        //   this.pointer.removeActorUnderPointer(actor);
        // }
    }
    propagate(actor) {
        // If the actor was under the pointer last frame, but not this one it left
        // if (this.pointer.wasActorUnderPointer(actor) && !this.pointer.isActorUnderPointer(actor)) {
        //   this._onActorLeave(actor);
        //   return;
        // }
        if (this.pointer.isActorAliveUnderPointer(actor)) {
            this.doAction(actor);
            if (this.bubbles && actor.parent) {
                this.propagate(actor.parent);
            }
        }
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
        // In the case this is new
        // if (this.pointer.checkActorUnderPointer(actor) && !this.pointer.wasActorUnderPointer(actor)) {
        //   this._onActorEnter(actor);
        // }
        if (this.pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragmove', this);
        }
    }
}
class PointerEnterEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerenter';
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragenter', this);
        }
    }
}
class PointerLeaveEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerleave';
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragleave', this);
        }
    }
}
class PointerCancelEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointercancel';
    }
}
/**
 * Wheel Events
 *
 * Represents a mouse wheel event. See [[Pointers]] for more information on
 * handling point input.
 */
class WheelEvent extends _Events__WEBPACK_IMPORTED_MODULE_0__["GameEvent"] {
    /**
     * @param x            The `x` coordinate of the event (in world coordinates)
     * @param y            The `y` coordinate of the event (in world coordinates)
     * @param pageX        The `x` coordinate of the event (in document coordinates)
     * @param pageY        The `y` coordinate of the event (in document coordinates)
     * @param screenX      The `x` coordinate of the event (in screen coordinates)
     * @param screenY      The `y` coordinate of the event (in screen coordinates)
     * @param index        The index of the pointer (zero-based)
     * @param deltaX       The type of pointer
     * @param deltaY       The type of pointer
     * @param deltaZ       The type of pointer
     * @param deltaMode    The type of movement [[WheelDeltaMode]]
     * @param ev           The raw DOM event being handled
     */
    constructor(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
        super();
        this.x = x;
        this.y = y;
        this.pageX = pageX;
        this.pageY = pageY;
        this.screenX = screenX;
        this.screenY = screenY;
        this.index = index;
        this.deltaX = deltaX;
        this.deltaY = deltaY;
        this.deltaZ = deltaZ;
        this.deltaMode = deltaMode;
        this.ev = ev;
    }
}
/**
 *
 */
function createPointerEventByName(eventName, coordinates, pointer, index, pointerType, button, ev) {
    let factory;
    switch (eventName) {
        case 'up':
            factory = new PointerEventFactory(PointerUpEvent);
            break;
        case 'down':
            factory = new PointerEventFactory(PointerDownEvent);
            break;
        case 'move':
            factory = new PointerEventFactory(PointerMoveEvent);
            break;
        case 'cancel':
            factory = new PointerEventFactory(PointerCancelEvent);
            break;
        case 'enter':
            factory = new PointerEventFactory(PointerEnterEvent);
            break;
        case 'leave':
            factory = new PointerEventFactory(PointerLeaveEvent);
            break;
    }
    return factory.create(coordinates, pointer, index, pointerType, button, ev);
}


/***/ }),

/***/ "./Input/Pointers.ts":
/*!***************************!*\
  !*** ./Input/Pointers.ts ***!
  \***************************/
/*! exports provided: Pointers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pointers", function() { return Pointers; });
/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Class */ "./Class.ts");
/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Engine */ "./Engine.ts");
/* harmony import */ var _Pointer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pointer */ "./Input/Pointer.ts");
/* harmony import */ var _PointerEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PointerEvents */ "./Input/PointerEvents.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Traits_CapturePointer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Traits/CapturePointer */ "./Traits/CapturePointer.ts");







/**
 * A constant used to normalize wheel events across different browsers
 *
 * This normalization factor is pulled from https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
 */
const ScrollWheelNormalizationFactor = -1 / 40;
/**
 * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to
 * [W3C Pointer Events](http://www.w3.org/TR/pointerevents/).
 */
class Pointers extends _Class__WEBPACK_IMPORTED_MODULE_0__["Class"] {
    constructor(engine) {
        super();
        this._pointerDown = [];
        this._pointerUp = [];
        this._pointerMove = [];
        this._pointerCancel = [];
        this._wheel = [];
        this._pointers = [];
        this._activePointers = [];
        this._engine = engine;
        this._pointers.push(new _Pointer__WEBPACK_IMPORTED_MODULE_2__["Pointer"]());
        this._activePointers = [-1];
        this.primary = this._pointers[0];
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    /**
     * Initializes pointer event listeners
     */
    init(target) {
        target = target || this._engine.canvas;
        // Touch Events
        target.addEventListener('touchstart', this._handleTouchEvent('down', this._pointerDown));
        target.addEventListener('touchend', this._handleTouchEvent('up', this._pointerUp));
        target.addEventListener('touchmove', this._handleTouchEvent('move', this._pointerMove));
        target.addEventListener('touchcancel', this._handleTouchEvent('cancel', this._pointerCancel));
        // W3C Pointer Events
        // Current: IE11, IE10
        if (window.PointerEvent) {
            // IE11
            this._engine.canvas.style.touchAction = 'none';
            target.addEventListener('pointerdown', this._handlePointerEvent('down', this._pointerDown));
            target.addEventListener('pointerup', this._handlePointerEvent('up', this._pointerUp));
            target.addEventListener('pointermove', this._handlePointerEvent('move', this._pointerMove));
            target.addEventListener('pointercancel', this._handlePointerEvent('cancel', this._pointerCancel));
        }
        else if (window.MSPointerEvent) {
            // IE10
            this._engine.canvas.style.msTouchAction = 'none';
            target.addEventListener('MSPointerDown', this._handlePointerEvent('down', this._pointerDown));
            target.addEventListener('MSPointerUp', this._handlePointerEvent('up', this._pointerUp));
            target.addEventListener('MSPointerMove', this._handlePointerEvent('move', this._pointerMove));
            target.addEventListener('MSPointerCancel', this._handlePointerEvent('cancel', this._pointerCancel));
        }
        else {
            // Mouse Events
            target.addEventListener('mousedown', this._handleMouseEvent('down', this._pointerDown));
            target.addEventListener('mouseup', this._handleMouseEvent('up', this._pointerUp));
            target.addEventListener('mousemove', this._handleMouseEvent('move', this._pointerMove));
        }
        // MDN MouseWheelEvent
        const wheelOptions = {
            passive: !(this._engine.pageScrollPreventionMode === _Engine__WEBPACK_IMPORTED_MODULE_1__["ScrollPreventionMode"].All ||
                this._engine.pageScrollPreventionMode === _Engine__WEBPACK_IMPORTED_MODULE_1__["ScrollPreventionMode"].Canvas)
        };
        if ('onwheel' in document.createElement('div')) {
            // Modern Browsers
            target.addEventListener('wheel', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
        else if (document.onmousewheel !== undefined) {
            // Webkit and IE
            target.addEventListener('mousewheel', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
        else {
            // Remaining browser and older Firefox
            target.addEventListener('MozMousePixelScroll', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
    }
    /**
     * Synthesize a pointer event that looks like a real browser event to excalibur
     * @param eventName
     * @param pos
     */
    triggerEvent(eventName, pos, button = _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["NativePointerButton"].Left, pointerType = 'mouse', pointerId = 0) {
        let x = 0;
        let y = 0;
        let coords;
        if (pos instanceof _Algebra__WEBPACK_IMPORTED_MODULE_5__["GlobalCoordinates"]) {
            x = pos.pagePos.x;
            y = pos.pagePos.y;
            coords = pos;
        }
        else {
            x = pos.x;
            y = pos.y;
            coords = new _Algebra__WEBPACK_IMPORTED_MODULE_5__["GlobalCoordinates"](pos.clone(), pos.clone(), pos.clone());
        }
        const eventish = {
            pageX: x,
            pageY: y,
            pointerId: pointerId,
            pointerType: pointerType,
            button: button,
            preventDefault: () => {
                /* do nothing */
            }
        };
        switch (eventName) {
            case 'move':
                this._handlePointerEvent(eventName, this._pointerMove, coords)(eventish);
                break;
            case 'down':
                this._handlePointerEvent(eventName, this._pointerDown, coords)(eventish);
                break;
            case 'up':
                this._handlePointerEvent(eventName, this._pointerUp, coords)(eventish);
                break;
            case 'cancel':
                this._handlePointerEvent(eventName, this._pointerCancel, coords)(eventish);
                break;
        }
        for (const actor of this._engine.currentScene.actors) {
            const capturePointer = actor.traits.filter((t) => t instanceof _Traits_CapturePointer__WEBPACK_IMPORTED_MODULE_6__["CapturePointer"])[0];
            if (capturePointer) {
                capturePointer.update(actor, this._engine, 1);
            }
        }
        this.dispatchPointerEvents();
        this.update();
    }
    /**
     * Update all pointer events and pointers, meant to be called at the end of frame
     */
    update() {
        this._pointerUp.length = 0;
        this._pointerDown.length = 0;
        this._pointerMove.length = 0;
        this._pointerCancel.length = 0;
        this._wheel.length = 0;
        for (let i = 0; i < this._pointers.length; i++) {
            this._pointers[i].update();
        }
    }
    /**
     * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
     * @param index  The pointer index to retrieve
     */
    at(index) {
        if (index >= this._pointers.length) {
            // Ensure there is a pointer to retrieve
            for (let i = this._pointers.length - 1, max = index; i < max; i++) {
                this._pointers.push(new _Pointer__WEBPACK_IMPORTED_MODULE_2__["Pointer"]());
                this._activePointers.push(-1);
            }
        }
        return this._pointers[index];
    }
    /**
     * Get number of pointers being watched
     */
    count() {
        return this._pointers.length;
    }
    checkAndUpdateActorUnderPointer(actor) {
        for (const pointer of this._pointers) {
            if (pointer.checkActorUnderPointer(actor)) {
                pointer.addActorUnderPointer(actor);
            }
            else {
                pointer.removeActorUnderPointer(actor);
            }
        }
    }
    _dispatchWithBubble(events) {
        for (const evt of events) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                evt.propagate(actor);
                if (!evt.bubbles) {
                    // if the event stops bubbling part way stop processing
                    break;
                }
            }
        }
    }
    _dispatchPointerLeaveEvents() {
        const lastMoveEventPerPointerPerActor = {};
        const pointerLeave = [];
        for (const evt of this._pointerMove) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                // If the actor was under the pointer last frame, but not this this frame, pointer left
                if (!lastMoveEventPerPointerPerActor[evt.pointer.id + '+' + actor.id] &&
                    evt.pointer.wasActorUnderPointer(actor) &&
                    !evt.pointer.isActorAliveUnderPointer(actor)) {
                    lastMoveEventPerPointerPerActor[evt.pointer.id + '+' + actor.id] = evt;
                    const pe = Object(_PointerEvents__WEBPACK_IMPORTED_MODULE_3__["createPointerEventByName"])('leave', new _Algebra__WEBPACK_IMPORTED_MODULE_5__["GlobalCoordinates"](evt.worldPos, evt.pagePos, evt.screenPos), evt.pointer, evt.index, evt.pointerType, evt.button, evt.ev);
                    pe.propagate(actor);
                    pointerLeave.push(pe);
                }
            }
        }
        return pointerLeave;
    }
    _dispatchPointerEnterEvents() {
        const lastMoveEventPerPointer = {};
        const pointerEnter = [];
        for (const evt of this._pointerMove) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                // If the actor was not under the pointer last frame, but it is this frame, pointer entered
                if (!lastMoveEventPerPointer[evt.pointer.id] &&
                    !evt.pointer.wasActorUnderPointer(actor) &&
                    evt.pointer.isActorAliveUnderPointer(actor)) {
                    lastMoveEventPerPointer[evt.pointer.id] = evt;
                    const pe = Object(_PointerEvents__WEBPACK_IMPORTED_MODULE_3__["createPointerEventByName"])('enter', new _Algebra__WEBPACK_IMPORTED_MODULE_5__["GlobalCoordinates"](evt.worldPos, evt.pagePos, evt.screenPos), evt.pointer, evt.index, evt.pointerType, evt.button, evt.ev);
                    pe.propagate(actor);
                    pointerEnter.push(pe);
                    // if pointer is dragging set the drag target
                    if (evt.pointer.isDragging) {
                        evt.pointer.dragTarget = actor;
                    }
                }
            }
        }
        return pointerEnter;
    }
    dispatchPointerEvents() {
        this._dispatchWithBubble(this._pointerDown);
        this._dispatchWithBubble(this._pointerUp);
        this._dispatchWithBubble(this._pointerMove);
        this._dispatchPointerLeaveEvents();
        this._dispatchPointerEnterEvents();
        this._dispatchWithBubble(this._pointerCancel);
        // TODO some duplication here
        for (const evt of this._wheel) {
            for (const actor of this._pointers[evt.index].getActorsUnderPointer()) {
                this._propagateWheelPointerEvent(actor, evt);
                if (!evt.bubbles) {
                    // if the event stops bubbling part way stop processing
                    break;
                }
            }
        }
    }
    _propagateWheelPointerEvent(actor, wheelEvent) {
        actor.emit('pointerwheel', wheelEvent);
        // Recurse and propagate
        if (wheelEvent.bubbles && actor.parent) {
            this._propagateWheelPointerEvent(actor.parent, wheelEvent);
        }
    }
    _handleMouseEvent(eventName, eventArr) {
        return (e) => {
            e.preventDefault();
            const pointer = this.at(0);
            const coordinates = _Algebra__WEBPACK_IMPORTED_MODULE_5__["GlobalCoordinates"].fromPagePosition(e.pageX, e.pageY, this._engine);
            const pe = Object(_PointerEvents__WEBPACK_IMPORTED_MODULE_3__["createPointerEventByName"])(eventName, coordinates, pointer, 0, _Pointer__WEBPACK_IMPORTED_MODULE_2__["PointerType"].Mouse, this._nativeButtonToPointerButton(e.button), e);
            eventArr.push(pe);
            pointer.eventDispatcher.emit(eventName, pe);
        };
    }
    _handleTouchEvent(eventName, eventArr) {
        return (e) => {
            e.preventDefault();
            for (let i = 0, len = e.changedTouches.length; i < len; i++) {
                const index = this._pointers.length > 1 ? this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                if (index === -1) {
                    continue;
                }
                const pointer = this.at(index);
                const coordinates = _Algebra__WEBPACK_IMPORTED_MODULE_5__["GlobalCoordinates"].fromPagePosition(e.changedTouches[i].pageX, e.changedTouches[i].pageY, this._engine);
                const pe = Object(_PointerEvents__WEBPACK_IMPORTED_MODULE_3__["createPointerEventByName"])(eventName, coordinates, pointer, index, _Pointer__WEBPACK_IMPORTED_MODULE_2__["PointerType"].Touch, _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerButton"].Unknown, e);
                eventArr.push(pe);
                pointer.eventDispatcher.emit(eventName, pe);
                // only with multi-pointer
                if (this._pointers.length > 1) {
                    if (eventName === 'up') {
                        // remove pointer ID from pool when pointer is lifted
                        this._activePointers[index] = -1;
                    }
                    else if (eventName === 'down') {
                        // set pointer ID to given index
                        this._activePointers[index] = e.changedTouches[i].identifier;
                    }
                }
            }
        };
    }
    _handlePointerEvent(eventName, eventArr, coords) {
        return (e) => {
            e.preventDefault();
            // get the index for this pointer ID if multi-pointer is asked for
            const index = this._pointers.length > 1 ? this._getPointerIndex(e.pointerId) : 0;
            if (index === -1) {
                return;
            }
            const pointer = this.at(index);
            const coordinates = coords || _Algebra__WEBPACK_IMPORTED_MODULE_5__["GlobalCoordinates"].fromPagePosition(e.pageX, e.pageY, this._engine);
            const pe = Object(_PointerEvents__WEBPACK_IMPORTED_MODULE_3__["createPointerEventByName"])(eventName, coordinates, pointer, index, this._stringToPointerType(e.pointerType), this._nativeButtonToPointerButton(e.button), e);
            eventArr.push(pe);
            pointer.eventDispatcher.emit(eventName, pe);
            // only with multi-pointer
            if (this._pointers.length > 1) {
                if (eventName === 'up') {
                    // remove pointer ID from pool when pointer is lifted
                    this._activePointers[index] = -1;
                }
                else if (eventName === 'down') {
                    // set pointer ID to given index
                    this._activePointers[index] = e.pointerId;
                }
            }
        };
    }
    _handleWheelEvent(eventName, eventArr) {
        return (e) => {
            // Should we prevent page scroll because of this event
            if (this._engine.pageScrollPreventionMode === _Engine__WEBPACK_IMPORTED_MODULE_1__["ScrollPreventionMode"].All ||
                (this._engine.pageScrollPreventionMode === _Engine__WEBPACK_IMPORTED_MODULE_1__["ScrollPreventionMode"].Canvas && e.target === this._engine.canvas)) {
                e.preventDefault();
            }
            const x = e.pageX - _Util_Util__WEBPACK_IMPORTED_MODULE_4__["getPosition"](this._engine.canvas).x;
            const y = e.pageY - _Util_Util__WEBPACK_IMPORTED_MODULE_4__["getPosition"](this._engine.canvas).y;
            const transformedPoint = this._engine.screenToWorldCoordinates(new _Algebra__WEBPACK_IMPORTED_MODULE_5__["Vector"](x, y));
            // deltaX, deltaY, and deltaZ are the standard modern properties
            // wheelDeltaX, wheelDeltaY, are legacy properties in webkit browsers and older IE
            // e.detail is only used in opera
            const deltaX = e.deltaX || e.wheelDeltaX * ScrollWheelNormalizationFactor || 0;
            const deltaY = e.deltaY || e.wheelDeltaY * ScrollWheelNormalizationFactor || e.wheelDelta * ScrollWheelNormalizationFactor || e.detail || 0;
            const deltaZ = e.deltaZ || 0;
            let deltaMode = _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["WheelDeltaMode"].Pixel;
            if (e.deltaMode) {
                if (e.deltaMode === 1) {
                    deltaMode = _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["WheelDeltaMode"].Line;
                }
                else if (e.deltaMode === 2) {
                    deltaMode = _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["WheelDeltaMode"].Page;
                }
            }
            const we = new _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["WheelEvent"](transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, deltaX, deltaY, deltaZ, deltaMode, e);
            eventArr.push(we);
            this.at(0).eventDispatcher.emit(eventName, we);
        };
    }
    /**
     * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
     * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
     */
    _getPointerIndex(pointerId) {
        let idx;
        if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
            return idx;
        }
        for (let i = 0; i < this._activePointers.length; i++) {
            if (this._activePointers[i] === -1) {
                return i;
            }
        }
        // ignore pointer because game isn't watching
        return -1;
    }
    _nativeButtonToPointerButton(s) {
        switch (s) {
            case _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["NativePointerButton"].NoButton:
                return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerButton"].NoButton;
            case _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["NativePointerButton"].Left:
                return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerButton"].Left;
            case _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["NativePointerButton"].Middle:
                return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerButton"].Middle;
            case _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["NativePointerButton"].Right:
                return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerButton"].Right;
            case _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["NativePointerButton"].Unknown:
                return _PointerEvents__WEBPACK_IMPORTED_MODULE_3__["PointerButton"].Unknown;
            default:
                return _Util_Util__WEBPACK_IMPORTED_MODULE_4__["fail"](s);
        }
    }
    _stringToPointerType(s) {
        switch (s) {
            case 'touch':
                return _Pointer__WEBPACK_IMPORTED_MODULE_2__["PointerType"].Touch;
            case 'mouse':
                return _Pointer__WEBPACK_IMPORTED_MODULE_2__["PointerType"].Mouse;
            case 'pen':
                return _Pointer__WEBPACK_IMPORTED_MODULE_2__["PointerType"].Pen;
            default:
                return _Pointer__WEBPACK_IMPORTED_MODULE_2__["PointerType"].Unknown;
        }
    }
}


/***/ }),

/***/ "./Interfaces/Audio.ts":
/*!*****************************!*\
  !*** ./Interfaces/Audio.ts ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Interfaces/AudioImplementation.ts":
/*!*******************************************!*\
  !*** ./Interfaces/AudioImplementation.ts ***!
  \*******************************************/
/*! exports provided: ExResponse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExResponse", function() { return ExResponse; });
class ExResponse {
}
ExResponse.type = {
    any: '',
    blob: 'blob',
    json: 'json',
    text: 'text',
    document: 'document',
    arraybuffer: 'arraybuffer'
};


/***/ }),

/***/ "./Interfaces/Drawable.ts":
/*!********************************!*\
  !*** ./Interfaces/Drawable.ts ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Interfaces/Evented.ts":
/*!*******************************!*\
  !*** ./Interfaces/Evented.ts ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Interfaces/Index.ts":
/*!*****************************!*\
  !*** ./Interfaces/Index.ts ***!
  \*****************************/
/*! exports provided: ExResponse, has_initialize, hasOnInitialize, has_preupdate, hasOnPreUpdate, has_postupdate, hasOnPostUpdate, hasPreDraw, hasPostDraw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Trait__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Trait */ "./Interfaces/Trait.ts");
/* empty/unused harmony star reexport *//* harmony import */ var _Audio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Audio */ "./Interfaces/Audio.ts");
/* empty/unused harmony star reexport *//* harmony import */ var _AudioImplementation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AudioImplementation */ "./Interfaces/AudioImplementation.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExResponse", function() { return _AudioImplementation__WEBPACK_IMPORTED_MODULE_2__["ExResponse"]; });

/* harmony import */ var _Drawable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Drawable */ "./Interfaces/Drawable.ts");
/* empty/unused harmony star reexport *//* harmony import */ var _Evented__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Evented */ "./Interfaces/Evented.ts");
/* empty/unused harmony star reexport *//* harmony import */ var _Loadable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Loadable */ "./Interfaces/Loadable.ts");
/* empty/unused harmony star reexport *//* harmony import */ var _Loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Loader */ "./Interfaces/Loader.ts");
/* empty/unused harmony star reexport *//* harmony import */ var _LifecycleEvents__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./LifecycleEvents */ "./Interfaces/LifecycleEvents.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has_initialize", function() { return _LifecycleEvents__WEBPACK_IMPORTED_MODULE_7__["has_initialize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasOnInitialize", function() { return _LifecycleEvents__WEBPACK_IMPORTED_MODULE_7__["hasOnInitialize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has_preupdate", function() { return _LifecycleEvents__WEBPACK_IMPORTED_MODULE_7__["has_preupdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasOnPreUpdate", function() { return _LifecycleEvents__WEBPACK_IMPORTED_MODULE_7__["hasOnPreUpdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has_postupdate", function() { return _LifecycleEvents__WEBPACK_IMPORTED_MODULE_7__["has_postupdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasOnPostUpdate", function() { return _LifecycleEvents__WEBPACK_IMPORTED_MODULE_7__["hasOnPostUpdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasPreDraw", function() { return _LifecycleEvents__WEBPACK_IMPORTED_MODULE_7__["hasPreDraw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasPostDraw", function() { return _LifecycleEvents__WEBPACK_IMPORTED_MODULE_7__["hasPostDraw"]; });

/* harmony import */ var _PointerEventHandlers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PointerEventHandlers */ "./Interfaces/PointerEventHandlers.ts");
/* empty/unused harmony star reexport */










/***/ }),

/***/ "./Interfaces/LifecycleEvents.ts":
/*!***************************************!*\
  !*** ./Interfaces/LifecycleEvents.ts ***!
  \***************************************/
/*! exports provided: has_initialize, hasOnInitialize, has_preupdate, hasOnPreUpdate, has_postupdate, hasOnPostUpdate, hasPreDraw, hasPostDraw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "has_initialize", function() { return has_initialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasOnInitialize", function() { return hasOnInitialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "has_preupdate", function() { return has_preupdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasOnPreUpdate", function() { return hasOnPreUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "has_postupdate", function() { return has_postupdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasOnPostUpdate", function() { return hasOnPostUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasPreDraw", function() { return hasPreDraw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasPostDraw", function() { return hasPostDraw; });
/**
 * Type guard checking for internal initialize method
 * @internal
 * @param a
 */
function has_initialize(a) {
    return !!a._initialize;
}
/**
 *
 */
function hasOnInitialize(a) {
    return !!a.onInitialize;
}
/**
 *
 */
function has_preupdate(a) {
    return !!a._preupdate;
}
/**
 *
 */
function hasOnPreUpdate(a) {
    return !!a.onPreUpdate;
}
/**
 *
 */
function has_postupdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasOnPostUpdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasPreDraw(a) {
    return !!a.onPreDraw;
}
/**
 *
 */
function hasPostDraw(a) {
    return !!a.onPostDraw;
}


/***/ }),

/***/ "./Interfaces/Loadable.ts":
/*!********************************!*\
  !*** ./Interfaces/Loadable.ts ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Interfaces/Loader.ts":
/*!******************************!*\
  !*** ./Interfaces/Loader.ts ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Interfaces/PointerEventHandlers.ts":
/*!********************************************!*\
  !*** ./Interfaces/PointerEventHandlers.ts ***!
  \********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Interfaces/Trait.ts":
/*!*****************************!*\
  !*** ./Interfaces/Trait.ts ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Label.ts":
/*!******************!*\
  !*** ./Label.ts ***!
  \******************/
/*! exports provided: FontUnit, TextAlign, BaseAlign, FontStyle, LabelImpl, Label */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontUnit", function() { return FontUnit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextAlign", function() { return TextAlign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseAlign", function() { return BaseAlign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontStyle", function() { return FontStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelImpl", function() { return LabelImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Label", function() { return Label; });
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actor */ "./Actor.ts");
/* harmony import */ var _Configurable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Configurable */ "./Configurable.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Algebra */ "./Algebra.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Collision/CollisionType */ "./Collision/CollisionType.ts");





/**
 * Enum representing the different font size units
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
 */
var FontUnit;
(function (FontUnit) {
    /**
     * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
     */
    FontUnit[FontUnit["Em"] = 0] = "Em";
    /**
     * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element
     */
    FontUnit[FontUnit["Rem"] = 1] = "Rem";
    /**
     * Pixel is a unit of length in screen pixels
     */
    FontUnit[FontUnit["Px"] = 2] = "Px";
    /**
     * Point is a physical unit length (1/72 of an inch)
     */
    FontUnit[FontUnit["Pt"] = 3] = "Pt";
    /**
     * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
     */
    FontUnit[FontUnit["Percent"] = 4] = "Percent";
})(FontUnit || (FontUnit = {}));
/**
 * Enum representing the different horizontal text alignments
 */
var TextAlign;
(function (TextAlign) {
    /**
     * The text is left-aligned.
     */
    TextAlign[TextAlign["Left"] = 0] = "Left";
    /**
     * The text is right-aligned.
     */
    TextAlign[TextAlign["Right"] = 1] = "Right";
    /**
     * The text is centered.
     */
    TextAlign[TextAlign["Center"] = 2] = "Center";
    /**
     * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
     * right-aligned for right-to-left locales).
     */
    TextAlign[TextAlign["Start"] = 3] = "Start";
    /**
     * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
     * left-aligned for right-to-left locales).
     */
    TextAlign[TextAlign["End"] = 4] = "End";
})(TextAlign || (TextAlign = {}));
/**
 * Enum representing the different baseline text alignments
 */
var BaseAlign;
(function (BaseAlign) {
    /**
     * The text baseline is the top of the em square.
     */
    BaseAlign[BaseAlign["Top"] = 0] = "Top";
    /**
     * The text baseline is the hanging baseline.  Currently unsupported; this will act like
     * alphabetic.
     */
    BaseAlign[BaseAlign["Hanging"] = 1] = "Hanging";
    /**
     * The text baseline is the middle of the em square.
     */
    BaseAlign[BaseAlign["Middle"] = 2] = "Middle";
    /**
     * The text baseline is the normal alphabetic baseline.
     */
    BaseAlign[BaseAlign["Alphabetic"] = 3] = "Alphabetic";
    /**
     * The text baseline is the ideographic baseline; this is the bottom of
     * the body of the characters, if the main body of characters protrudes
     * beneath the alphabetic baseline.  Currently unsupported; this will
     * act like alphabetic.
     */
    BaseAlign[BaseAlign["Ideographic"] = 4] = "Ideographic";
    /**
     * The text baseline is the bottom of the bounding box.  This differs
     * from the ideographic baseline in that the ideographic baseline
     * doesn't consider descenders.
     */
    BaseAlign[BaseAlign["Bottom"] = 5] = "Bottom";
})(BaseAlign || (BaseAlign = {}));
/**
 * Enum representing the different possible font styles
 */
var FontStyle;
(function (FontStyle) {
    FontStyle[FontStyle["Normal"] = 0] = "Normal";
    FontStyle[FontStyle["Italic"] = 1] = "Italic";
    FontStyle[FontStyle["Oblique"] = 2] = "Oblique";
})(FontStyle || (FontStyle = {}));
/**
 * @hidden
 */
class LabelImpl extends _Actor__WEBPACK_IMPORTED_MODULE_1__["Actor"] {
    /**
     * @param textOrConfig    The text of the label, or label option bag
     * @param x           The x position of the label
     * @param y           The y position of the label
     * @param fontFamily  Use a value that is valid for the CSS `font-family` property. The default is `sans-serif`.
     * @param spriteFont  Use an Excalibur sprite font for the label's font, if a SpriteFont is provided it will take precedence
     * over a css font.
     */
    constructor(textOrConfig, x, y, fontFamily, spriteFont) {
        super(textOrConfig && typeof textOrConfig === 'object' ? textOrConfig : { pos: new _Algebra__WEBPACK_IMPORTED_MODULE_3__["Vector"](x, y) });
        /**
         * Sets or gets the bold property of the label's text, by default it's false
         */
        this.bold = false;
        /**
         * The font size in the selected units, default is 10 (default units is pixel)
         */
        this.fontSize = 10;
        /**
         * The font style for this label, the default is [[FontStyle.Normal]]
         */
        this.fontStyle = FontStyle.Normal;
        /**
         * The css units for a font size such as px, pt, em (SpriteFont only support px), by default is 'px';
         */
        this.fontUnit = FontUnit.Px;
        /**
         * Gets or sets the horizontal text alignment property for the label.
         */
        this.textAlign = TextAlign.Left;
        /**
         * Gets or sets the baseline alignment property for the label.
         */
        this.baseAlign = BaseAlign.Bottom;
        /**
         * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
         */
        this.letterSpacing = 0; //px
        /**
         * Whether or not the [[SpriteFont]] will be case-sensitive when matching characters.
         */
        this.caseInsensitive = true;
        let text = '';
        if (textOrConfig && typeof textOrConfig === 'object') {
            fontFamily = textOrConfig.fontFamily;
            spriteFont = textOrConfig.spriteFont;
            text = textOrConfig.text;
        }
        else {
            text = textOrConfig;
        }
        this.text = text || '';
        this.color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Black;
        this.spriteFont = spriteFont;
        this.body.collider.type = _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_4__["CollisionType"].PreventCollision;
        this.fontFamily = fontFamily || 'sans-serif'; // coalesce to default canvas font
        this._textShadowOn = false;
        this._shadowOffsetX = 0;
        this._shadowOffsetY = 0;
        if (spriteFont) {
            //this._textSprites = spriteFont.getTextSprites();
        }
    }
    /**
     * Returns the width of the text in the label (in pixels);
     * @param ctx  Rendering context to measure the string with
     */
    getTextWidth(ctx) {
        const oldFont = ctx.font;
        ctx.font = this._fontString;
        const width = ctx.measureText(this.text).width;
        ctx.font = oldFont;
        return width;
    }
    /* istanbul ignore next */
    _lookupFontUnit(fontUnit) {
        switch (fontUnit) {
            case FontUnit.Em:
                return 'em';
            case FontUnit.Rem:
                return 'rem';
            case FontUnit.Pt:
                return 'pt';
            case FontUnit.Px:
                return 'px';
            case FontUnit.Percent:
                return '%';
            default:
                return 'px';
        }
    }
    /* istanbul ignore next */
    _lookupTextAlign(textAlign) {
        switch (textAlign) {
            case TextAlign.Left:
                return 'left';
            case TextAlign.Right:
                return 'right';
            case TextAlign.Center:
                return 'center';
            case TextAlign.End:
                return 'end';
            case TextAlign.Start:
                return 'start';
            default:
                return 'start';
        }
    }
    /* istanbul ignore next */
    _lookupBaseAlign(baseAlign) {
        switch (baseAlign) {
            case BaseAlign.Alphabetic:
                return 'alphabetic';
            case BaseAlign.Bottom:
                return 'bottom';
            case BaseAlign.Hanging:
                return 'hanging';
            case BaseAlign.Ideographic:
                return 'ideographic';
            case BaseAlign.Middle:
                return 'middle';
            case BaseAlign.Top:
                return 'top';
            default:
                return 'alphabetic';
        }
    }
    /* istanbul ignore next */
    _lookupFontStyle(fontStyle) {
        const boldstring = this.bold ? ' bold' : '';
        switch (fontStyle) {
            case FontStyle.Italic:
                return 'italic' + boldstring;
            case FontStyle.Normal:
                return 'normal' + boldstring;
            case FontStyle.Oblique:
                return 'oblique' + boldstring;
            default:
                return 'normal' + boldstring;
        }
    }
    /**
     * Sets the text shadow for sprite fonts
     * @param offsetX      The x offset in pixels to place the shadow
     * @param offsetY      The y offset in pixels to place the shadow
     * @param shadowColor  The color of the text shadow
     */
    setTextShadow(offsetX, offsetY, shadowColor) {
        this.spriteFont.setTextShadow(offsetX, offsetY, shadowColor);
    }
    /**
     * Toggles text shadows on or off, only applies when using sprite fonts
     */
    useTextShadow(on) {
        this.spriteFont.useTextShadow(on);
    }
    /**
     * Clears the current text shadow
     */
    clearTextShadow() {
        this._textShadowOn = false;
        this._shadowOffsetX = 0;
        this._shadowOffsetY = 0;
    }
    update(engine, delta) {
        super.update(engine, delta);
    }
    draw(ctx, delta) {
        ctx.save();
        if (this._textShadowOn) {
            ctx.save();
            ctx.translate(this._shadowOffsetX, this._shadowOffsetY);
            this._fontDraw(ctx);
            ctx.restore();
        }
        this._fontDraw(ctx);
        super.draw(ctx, delta);
        ctx.restore();
    }
    _fontDraw(ctx) {
        if (this.spriteFont) {
            this.spriteFont.draw(ctx, this.text, 0, 0, {
                color: this.color.clone(),
                baseAlign: this.baseAlign,
                textAlign: this.textAlign,
                fontSize: this.fontSize,
                letterSpacing: this.letterSpacing,
                opacity: this.opacity
            });
        }
        else {
            const oldAlign = ctx.textAlign;
            const oldTextBaseline = ctx.textBaseline;
            ctx.textAlign = this._lookupTextAlign(this.textAlign);
            ctx.textBaseline = this._lookupBaseAlign(this.baseAlign);
            if (this.color) {
                this.color.a = this.opacity;
            }
            ctx.fillStyle = this.color.toString();
            ctx.font = this._fontString;
            if (this.maxWidth) {
                ctx.fillText(this.text, 0, 0, this.maxWidth);
            }
            else {
                ctx.fillText(this.text, 0, 0);
            }
            ctx.textAlign = oldAlign;
            ctx.textBaseline = oldTextBaseline;
        }
    }
    get _fontString() {
        return `${this._lookupFontStyle(this.fontStyle)} ${this.fontSize}${this._lookupFontUnit(this.fontUnit)} ${this.fontFamily}`;
    }
    debugDraw(ctx) {
        super.debugDraw(ctx);
    }
}
/**
 * Labels are the way to draw small amounts of text to the screen. They are
 * actors and inherit all of the benefits and capabilities.
 */
class Label extends Object(_Configurable__WEBPACK_IMPORTED_MODULE_2__["Configurable"])(LabelImpl) {
    constructor(textOrConfig, x, y, fontFamily, spriteFont) {
        super(textOrConfig, x, y, fontFamily, spriteFont);
    }
}


/***/ }),

/***/ "./Loader.css":
/*!********************!*\
  !*** ./Loader.css ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "/* Buttons styles start */\n\nbutton#excalibur-play {\n  display: inline-block;\n  position: relative;\n  z-index: 999;\n  border-radius: 6px;\n  border: none;\n  /*border: 3px solid;\n    border-color: white;\n    box-shadow: 0 0 10px #ccc;*/\n  padding: 1rem 1.5rem 1rem 4rem;\n  margin: 0;\n  text-decoration: none;\n  background: #00b233;\n  color: #ffffff;\n  font-family: sans-serif;\n  font-size: 2rem;\n  line-height: 1;\n  cursor: pointer;\n  text-align: center;\n  transition: background 250ms ease-in-out, transform 150ms ease;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\n  animation: excalibur-button-fadein 200ms;\n}\n\n/*\nbutton#excalibur-play {\n  display: none;\n}*/\n\nbutton#excalibur-play:after {\n  position: absolute;\n  content: '';\n  border: 8px solid;\n  border-color: transparent transparent transparent white;\n  left: 35px;\n  top: 24px;\n  width: 0;\n  height: 0;\n}\n\nbutton#excalibur-play:before {\n  position: absolute;\n  content: '';\n  border: 3px solid;\n  left: 19px;\n  top: 14px;\n  border-radius: 20px;\n  width: 30px;\n  height: 30px;\n}\n\nbutton#excalibur-play:hover,\nbutton#excalibur-play:focus {\n  background: #00982c;\n}\n\nbutton#excalibur-play:focus {\n  outline: 1px solid #fff;\n  outline-offset: -4px;\n}\n\nbutton#excalibur-play:active {\n  transform: scale(0.99);\n}\n\n@keyframes excalibur-button-fadein {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n/* Firefox < 16 */\n@-moz-keyframes excalibur-button-fadein {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n/* Safari, Chrome and Opera > 12.1 */\n@-webkit-keyframes excalibur-button-fadein {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n/* Internet Explorer */\n@-ms-keyframes excalibur-button-fadein {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n/* Opera < 12.1 */\n@-o-keyframes excalibur-button-fadein {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./Loader.logo.png":
/*!*************************!*\
  !*** ./Loader.logo.png ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=");

/***/ }),

/***/ "./Loader.ts":
/*!*******************!*\
  !*** ./Loader.ts ***!
  \*******************/
/*! exports provided: Loader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Util_WebAudio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Util/WebAudio */ "./Util/WebAudio.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Class */ "./Class.ts");
/* harmony import */ var _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Util/DrawUtil */ "./Util/DrawUtil.ts");
/* harmony import */ var _Loader_logo_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Loader.logo.png */ "./Loader.logo.png");
/* harmony import */ var _Loader_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Loader.css */ "./Loader.css");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Util/Util */ "./Util/Util.ts");








/**
 * Pre-loading assets
 *
 * The loader provides a mechanism to preload multiple resources at
 * one time. The loader must be passed to the engine in order to
 * trigger the loading progress bar.
 *
 * The [[Loader]] itself implements [[Loadable]] so you can load loaders.
 *
 * ## Example: Pre-loading resources for a game
 *
 * ```js
 * // create a loader
 * var loader = new ex.Loader();
 *
 * // create a resource dictionary (best practice is to keep a separate file)
 * var resources = {
 *   TextureGround: new ex.Texture("/images/textures/ground.png"),
 *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
 * };
 *
 * // loop through dictionary and add to loader
 * for (var loadable in resources) {
 *   if (resources.hasOwnProperty(loadable)) {
 *     loader.addResource(resources[loadable]);
 *   }
 * }
 *
 * // start game
 * game.start(loader).then(function () {
 *   console.log("Game started!");
 * });
 * ```
 *
 * ## Customize the Loader
 *
 * The loader can be customized to show different, text, logo, background color, and button.
 *
 * ```typescript
 * const loader = new ex.Loader([playerTexture]);
 *
 * // The loaders button text can simply modified using this
 * loader.playButtonText = 'Start the best game ever';
 *
 * // The logo can be changed by inserting a base64 image string here
 *
 * loader.logo = 'data:image/png;base64,iVBORw...';
 * loader.logoWidth = 15;
 * loader.logoHeight = 14;
 *
 * // The background color can be changed like so by supplying a valid CSS color string
 *
 * loader.backgroundColor = 'red'
 * loader.backgroundColor = '#176BAA'
 *
 * // To build a completely new button
 * loader.startButtonFactory = () => {
 *     let myButton = document.createElement('button');
 *     myButton.textContent = 'The best button';
 *     return myButton;
 * };
 *
 * engine.start(loader).then(() => {});
 * ```
 */
class Loader extends _Class__WEBPACK_IMPORTED_MODULE_3__["Class"] {
    /**
     * @param loadables  Optionally provide the list of resources you want to load at constructor time
     */
    constructor(loadables) {
        super();
        this._resourceList = [];
        this._index = 0;
        this._playButtonShown = false;
        this._resourceCount = 0;
        this._numLoaded = 0;
        this._progressCounts = {};
        this._totalCounts = {};
        // logo drawing stuff
        // base64 string encoding of the excalibur logo (logo-white.png)
        this.logo = _Loader_logo_png__WEBPACK_IMPORTED_MODULE_5__["default"];
        this.logoWidth = 468;
        this.logoHeight = 118;
        /**
         * Gets or sets the color of the loading bar, default is [[Color.White]]
         */
        this.loadingBarColor = _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].White;
        /**
         * Gets or sets the background color of the loader as a hex string
         */
        this.backgroundColor = '#176BAA';
        this.suppressPlayButton = false;
        /** Loads the css from Loader.css */
        this._playButtonStyles = _Loader_css__WEBPACK_IMPORTED_MODULE_6__["default"].toString();
        /**
         * Get/set play button text
         */
        this.playButtonText = 'Play game';
        /**
         * Return a html button element for excalibur to use as a play button
         */
        this.startButtonFactory = () => {
            const buttonElement = document.createElement('button');
            buttonElement.id = 'excalibur-play';
            buttonElement.textContent = this.playButtonText;
            buttonElement.style.display = 'none';
            return buttonElement;
        };
        this.getData = () => {
            return;
        };
        this.setData = () => {
            return;
        };
        this.processData = () => {
            return;
        };
        this.onprogress = (e) => {
            _Util_Log__WEBPACK_IMPORTED_MODULE_2__["Logger"].getInstance().debug('[ex.Loader] Loading ' + ((100 * e.loaded) / e.total).toFixed(0));
            return;
        };
        this.oncomplete = () => {
            return;
        };
        this.onerror = () => {
            return;
        };
        if (loadables) {
            this.addResources(loadables);
        }
    }
    get _image() {
        if (!this._imageElement) {
            this._imageElement = new Image();
            this._imageElement.src = this.logo;
        }
        return this._imageElement;
    }
    get playButtonRootElement() {
        return this._playButtonRootElement;
    }
    get playButtonElement() {
        return this._playButtonElement;
    }
    get _playButton() {
        if (!this._playButtonRootElement) {
            this._playButtonRootElement = document.createElement('div');
            this._playButtonRootElement.id = 'excalibur-play-root';
            this._playButtonRootElement.style.position = 'absolute';
            document.body.appendChild(this._playButtonRootElement);
        }
        if (!this._styleBlock) {
            this._styleBlock = document.createElement('style');
            this._styleBlock.textContent = this._playButtonStyles;
            document.head.appendChild(this._styleBlock);
        }
        if (!this._playButtonElement) {
            this._playButtonElement = this.startButtonFactory();
            this._playButtonRootElement.appendChild(this._playButtonElement);
        }
        return this._playButtonElement;
    }
    wireEngine(engine) {
        this._engine = engine;
    }
    /**
     * Add a resource to the loader to load
     * @param loadable  Resource to add
     */
    addResource(loadable) {
        const key = this._index++;
        this._resourceList.push(loadable);
        this._progressCounts[key] = 0;
        this._totalCounts[key] = 1;
        this._resourceCount++;
    }
    /**
     * Add a list of resources to the loader to load
     * @param loadables  The list of resources to load
     */
    addResources(loadables) {
        let i = 0;
        const len = loadables.length;
        for (i; i < len; i++) {
            this.addResource(loadables[i]);
        }
    }
    /**
     * Returns true if the loader has completely loaded all resources
     */
    isLoaded() {
        return this._numLoaded === this._resourceCount;
    }
    /**
     * Shows the play button and returns a promise that resolves when clicked
     */
    showPlayButton() {
        if (this.suppressPlayButton) {
            return Promise.resolve();
        }
        else {
            this._playButtonShown = true;
            this._playButton.style.display = 'block';
            const promise = new Promise((resolve) => {
                this._playButton.addEventListener('click', () => resolve());
                this._playButton.addEventListener('touchend', () => resolve());
                this._playButton.addEventListener('pointerup', () => resolve());
            });
            return promise;
        }
    }
    hidePlayButton() {
        this._playButtonShown = false;
        this._playButton.style.display = 'none';
    }
    /**
     * Clean up generated elements for the loader
     */
    dispose() {
        if (this._playButtonRootElement.parentElement) {
            this._playButtonRootElement.removeChild(this._playButtonElement);
            document.body.removeChild(this._playButtonRootElement);
            document.head.removeChild(this._styleBlock);
            this._playButtonRootElement = null;
            this._playButtonElement = null;
            this._styleBlock = null;
        }
    }
    /**
     * Begin loading all of the supplied resources, returning a promise
     * that resolves when loading of all is complete
     */
    load() {
        const complete = new Promise((resolve) => {
            const me = this;
            if (this._resourceList.length === 0) {
                me.showPlayButton().then(() => {
                    // Unlock audio context in chrome after user gesture
                    // https://github.com/excaliburjs/Excalibur/issues/262
                    // https://github.com/excaliburjs/Excalibur/issues/1031
                    _Util_WebAudio__WEBPACK_IMPORTED_MODULE_1__["WebAudio"].unlock().then(() => {
                        me.hidePlayButton();
                        me.oncomplete.call(me);
                        resolve();
                    });
                });
                return;
            }
            const progressArray = new Array(this._resourceList.length);
            const progressChunks = this._resourceList.length;
            for (const index in this._resourceList) {
                const resource = this._resourceList[index];
                if (this._engine) {
                    resource.wireEngine(this._engine);
                }
                resource.onprogress = (e) => {
                    const total = e.total;
                    const loaded = e.loaded;
                    progressArray[index] = { loaded: (loaded / total) * (100 / progressChunks), total: 100 };
                    const progressResult = progressArray.reduce(function (accum, next) {
                        return { loaded: accum.loaded + next.loaded, total: 100 };
                    }, { loaded: 0, total: 100 });
                    me.onprogress.call(me, progressResult);
                };
                resource.oncomplete = resource.onerror = () => {
                    me._numLoaded++;
                    if (me._numLoaded === me._resourceCount) {
                        setTimeout(() => {
                            me.showPlayButton().then(() => {
                                // Unlock audio context in chrome after user gesture
                                // https://github.com/excaliburjs/Excalibur/issues/262
                                // https://github.com/excaliburjs/Excalibur/issues/1031
                                _Util_WebAudio__WEBPACK_IMPORTED_MODULE_1__["WebAudio"].unlock().then(() => {
                                    me.hidePlayButton();
                                    me.oncomplete.call(me);
                                    resolve();
                                });
                            });
                        }, 200); // short delay in showing the button for aesthetics
                    }
                };
            }
            const loadNext = (list, index) => {
                if (!list[index]) {
                    return;
                }
                list[index].load().then(() => {
                    loadNext(list, index + 1);
                });
            };
            loadNext(this._resourceList, 0);
        });
        return complete;
    }
    updateResourceProgress(loadedBytes, totalBytes) {
        const chunkSize = 100 / this._resourceCount;
        const resourceProgress = loadedBytes / totalBytes;
        // This only works if we load 1 resource at a time
        const totalProgress = resourceProgress * chunkSize + this.progress * 100;
        this.onprogress({ loaded: totalProgress, total: 100 });
    }
    markResourceComplete() {
        this._numLoaded++;
    }
    /**
     * Returns the progess of the loader as a number between [0, 1] inclusive.
     */
    get progress() {
        return this._resourceCount > 0 ? Object(_Util_Util__WEBPACK_IMPORTED_MODULE_7__["clamp"])(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;
    }
    /**
     * Loader draw function. Draws the default Excalibur loading screen.
     * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
     * to customize the drawing, or just override entire method.
     */
    draw(ctx) {
        const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;
        const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;
        if (this._playButtonRootElement) {
            const left = ctx.canvas.offsetLeft;
            const top = ctx.canvas.offsetTop;
            const buttonWidth = this._playButton.clientWidth;
            const buttonHeight = this._playButton.clientHeight;
            if (this.playButtonPosition) {
                this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;
                this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;
            }
            else {
                this._playButtonRootElement.style.left = `${left + canvasWidth / 2 - buttonWidth / 2}px`;
                this._playButtonRootElement.style.top = `${top + canvasHeight / 2 - buttonHeight / 2 + 100}px`;
            }
        }
        ctx.fillStyle = this.backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        let logoY = canvasHeight / 2;
        const width = Math.min(this.logoWidth, canvasWidth * 0.75);
        let logoX = canvasWidth / 2 - width / 2;
        if (this.logoPosition) {
            logoX = this.logoPosition.x;
            logoY = this.logoPosition.y;
        }
        const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
        const oldAntialias = this._engine.getAntialiasing();
        this._engine.setAntialiasing(true);
        if (!this.logoPosition) {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);
        }
        else {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);
        }
        // loading box
        if (!this.suppressPlayButton && this._playButtonShown) {
            this._engine.setAntialiasing(oldAntialias);
            return;
        }
        let loadingX = logoX;
        let loadingY = logoY;
        if (this.loadingBarPosition) {
            loadingX = this.loadingBarPosition.x;
            loadingY = this.loadingBarPosition.y;
        }
        ctx.lineWidth = 2;
        _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_4__["roundRect"](ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);
        const progress = width * this.progress;
        const margin = 5;
        const progressWidth = progress - margin * 2;
        const height = 20 - margin * 2;
        _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_4__["roundRect"](ctx, loadingX + margin, loadingY + margin, progressWidth > 10 ? progressWidth : 10, height, 5, null, this.loadingBarColor);
        this._engine.setAntialiasing(oldAntialias);
    }
    /**
     * Perform any calculations or logic in the `update` method. The default `Loader` does not
     * do anything in this method so it is safe to override.
     */
    update(_engine, _delta) {
        // overridable update
    }
}


/***/ }),

/***/ "./Math/Index.ts":
/*!***********************!*\
  !*** ./Math/Index.ts ***!
  \***********************/
/*! exports provided: PerlinGenerator, PerlinDrawer2D, Random */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _PerlinNoise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PerlinNoise */ "./Math/PerlinNoise.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PerlinGenerator", function() { return _PerlinNoise__WEBPACK_IMPORTED_MODULE_0__["PerlinGenerator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PerlinDrawer2D", function() { return _PerlinNoise__WEBPACK_IMPORTED_MODULE_0__["PerlinDrawer2D"]; });

/* harmony import */ var _Random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Random */ "./Math/Random.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Random", function() { return _Random__WEBPACK_IMPORTED_MODULE_1__["Random"]; });





/***/ }),

/***/ "./Math/PerlinNoise.ts":
/*!*****************************!*\
  !*** ./Math/PerlinNoise.ts ***!
  \*****************************/
/*! exports provided: PerlinGenerator, PerlinDrawer2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerlinGenerator", function() { return PerlinGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerlinDrawer2D", function() { return PerlinDrawer2D; });
/* harmony import */ var _Random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Random */ "./Math/Random.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util/Util */ "./Util/Util.ts");



/**
 * Linear interpolation between a and b
 * @internal
 * @param time number between [0, 1]
 * @param a starting number
 * @param b ending number
 */
function _lerp(time, a, b) {
    return a + time * (b - a);
}
/**
 * Reduce t by a quintic function that produces a desired effect
 * @internal
 * @param t
 */
function _fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}
/**
 * Generates perlin noise based on the 2002 Siggraph paper http://mrl.nyu.edu/~perlin/noise/
 * Also https://flafla2.github.io/2014/08/09/perlinnoise.html
 */
class PerlinGenerator {
    constructor(options) {
        this._perm = [
            151,
            160,
            137,
            91,
            90,
            15,
            131,
            13,
            201,
            95,
            96,
            53,
            194,
            233,
            7,
            225,
            140,
            36,
            103,
            30,
            69,
            142,
            8,
            99,
            37,
            240,
            21,
            10,
            23,
            190,
            6,
            148,
            247,
            120,
            234,
            75,
            0,
            26,
            197,
            62,
            94,
            252,
            219,
            203,
            117,
            35,
            11,
            32,
            57,
            177,
            33,
            88,
            237,
            149,
            56,
            87,
            174,
            20,
            125,
            136,
            171,
            168,
            68,
            175,
            74,
            165,
            71,
            134,
            139,
            48,
            27,
            166,
            77,
            146,
            158,
            231,
            83,
            111,
            229,
            122,
            60,
            211,
            133,
            230,
            220,
            105,
            92,
            41,
            55,
            46,
            245,
            40,
            244,
            102,
            143,
            54,
            65,
            25,
            63,
            161,
            1,
            216,
            80,
            73,
            209,
            76,
            132,
            187,
            208,
            89,
            18,
            169,
            200,
            196,
            135,
            130,
            116,
            188,
            159,
            86,
            164,
            100,
            109,
            198,
            173,
            186,
            3,
            64,
            52,
            217,
            226,
            250,
            124,
            123,
            5,
            202,
            38,
            147,
            118,
            126,
            255,
            82,
            85,
            212,
            207,
            206,
            59,
            227,
            47,
            16,
            58,
            17,
            182,
            189,
            28,
            42,
            223,
            183,
            170,
            213,
            119,
            248,
            152,
            2,
            44,
            154,
            163,
            70,
            221,
            153,
            101,
            155,
            167,
            43,
            172,
            9,
            129,
            22,
            39,
            253,
            19,
            98,
            108,
            110,
            79,
            113,
            224,
            232,
            178,
            185,
            112,
            104,
            218,
            246,
            97,
            228,
            251,
            34,
            242,
            193,
            238,
            210,
            144,
            12,
            191,
            179,
            162,
            241,
            81,
            51,
            145,
            235,
            249,
            14,
            239,
            107,
            49,
            192,
            214,
            31,
            181,
            199,
            106,
            157,
            184,
            84,
            204,
            176,
            115,
            121,
            50,
            45,
            127,
            4,
            150,
            254,
            138,
            236,
            205,
            93,
            222,
            114,
            67,
            29,
            24,
            72,
            243,
            141,
            128,
            195,
            78,
            66,
            215,
            61,
            156,
            180
        ];
        this._p = new Uint8Array(512);
        this._defaultPerlinOptions = {
            octaves: 1,
            frequency: 1,
            amplitude: 1,
            persistance: 0.5
        };
        options = _Util_Util__WEBPACK_IMPORTED_MODULE_2__["extend"]({}, this._defaultPerlinOptions, options);
        this.persistance = options.persistance;
        this.amplitude = options.amplitude;
        this.frequency = options.frequency;
        this.octaves = options.octaves;
        if (options.seed) {
            this._random = new _Random__WEBPACK_IMPORTED_MODULE_0__["Random"](options.seed);
        }
        else {
            this._random = new _Random__WEBPACK_IMPORTED_MODULE_0__["Random"]();
        }
        this._perm = this._random.shuffle(this._perm);
        for (let i = 0; i < 512; i++) {
            this._p[i] = this._perm[i % 256] & 0xff;
        }
    }
    noise() {
        let amp = this.amplitude;
        let freq = this.frequency;
        let total = 0;
        let maxValue = 0;
        for (let i = 0; i < this.octaves; i++) {
            switch (arguments.length) {
                case 1:
                    total += this._noise1d(arguments[0] * freq) * amp;
                    break;
                case 2:
                    total += this._noise2d(arguments[0] * freq, arguments[1] * freq) * amp;
                    break;
                case 3:
                    total += this._noise3d(arguments[0] * freq, arguments[1] * freq, arguments[2] * freq) * amp;
                    break;
                /* istanbul ignore next */
                default:
                    throw new Error('Invalid arguments for perlin noise');
            }
            maxValue += amp;
            amp *= this.persistance;
            freq *= 2;
        }
        return total / maxValue;
    }
    /**
     * Generates a list starting at 0 and ending at 1 of continuous perlin noise, by default the step is 1/length;
     *
     */
    sequence(length, step) {
        if (!step) {
            step = 1 / length;
        }
        const array = new Array(length);
        for (let i = 0; i < length; i++) {
            array[i] = this.noise(i * step);
        }
        return array;
    }
    /**
     * Generates a 2D grid of perlin noise given a step value packed into a 1D array i = (x + y*width),
     * by default the step will 1/(min(dimension))
     */
    grid(width, height, step) {
        if (!step) {
            step = 1 / Math.min(width, height);
        }
        const array = new Array(width * height);
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                array[x + y * width] = this.noise(x * step, y * step);
            }
        }
        return array;
    }
    _gradient3d(hash, x, y, z) {
        const h = hash & 0xf;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
        return ((h & 0b1) === 0 ? u : -u) + ((h & 0b10) === 0 ? v : -v);
    }
    _gradient2d(hash, x, y) {
        const value = (hash & 0b1) === 0 ? x : y;
        return (hash & 0b10) === 0 ? -value : value;
    }
    _gradient1d(hash, x) {
        return (hash & 0b1) === 0 ? -x : x;
    }
    _noise1d(x) {
        const intX = Math.floor(x) & 0xff; // force 0-255 integers to lookup in permutation
        x -= Math.floor(x);
        const fadeX = _fade(x);
        return (_lerp(fadeX, this._gradient1d(this._p[intX], x), this._gradient1d(this._p[intX + 1], x - 1)) + 1) / 2;
    }
    _noise2d(x, y) {
        const intX = Math.floor(x) & 0xff;
        const intY = Math.floor(y) & 0xff;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const fadeX = _fade(x);
        const fadeY = _fade(y);
        const a = this._p[intX] + intY;
        const b = this._p[intX + 1] + intY;
        return ((_lerp(fadeY, _lerp(fadeX, this._gradient2d(this._p[a], x, y), this._gradient2d(this._p[b], x - 1, y)), _lerp(fadeX, this._gradient2d(this._p[a + 1], x, y - 1), this._gradient2d(this._p[b + 1], x - 1, y - 1))) +
            1) /
            2);
    }
    _noise3d(x, y, z) {
        const intX = Math.floor(x) & 0xff;
        const intY = Math.floor(y) & 0xff;
        const intZ = Math.floor(z) & 0xff;
        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);
        const fadeX = _fade(x);
        const fadeY = _fade(y);
        const fadeZ = _fade(z);
        const a = this._p[intX] + intY;
        const b = this._p[intX + 1] + intY;
        const aa = this._p[a] + intZ;
        const ba = this._p[b] + intZ;
        const ab = this._p[a + 1] + intZ;
        const bb = this._p[b + 1] + intZ;
        return ((_lerp(fadeZ, _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa], x, y, z), this._gradient3d(this._p[ba], x - 1, y, z)), _lerp(fadeX, this._gradient3d(this._p[ab], x, y - 1, z), this._gradient3d(this._p[bb], x - 1, y - 1, z))), _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa + 1], x, y, z - 1), this._gradient3d(this._p[ba + 1], x - 1, y, z - 1)), _lerp(fadeX, this._gradient3d(this._p[ab + 1], x, y - 1, z - 1), this._gradient3d(this._p[bb + 1], x - 1, y - 1, z - 1)))) +
            1) /
            2);
    }
}
/**
 * A helper to draw 2D perlin maps given a perlin generator and a function
 */
class PerlinDrawer2D {
    /**
     * @param generator - An existing perlin generator
     * @param colorFcn - A color function that takes a value between [0, 255] derived from the perlin generator, and returns a color
     */
    constructor(generator, colorFcn) {
        this.generator = generator;
        this.colorFcn = colorFcn;
        if (!colorFcn) {
            this.colorFcn = (val) => {
                return val < 125 ? _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Black : _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].White;
            };
        }
    }
    /**
     * Returns an image of 2D perlin noise
     */
    image(width, height) {
        const image = document.createElement('img');
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        this.draw(ctx, 0, 0, width, height);
        image.src = canvas.toDataURL();
        return image;
    }
    /**
     * This draws a 2D perlin grid on a canvas context, not recommended to be called every frame due to performance
     */
    draw(ctx, x, y, width, height) {
        const grid = this.generator.grid(width, height);
        const imageData = ctx.getImageData(x, y, width, height);
        for (let j = 0; j < height; j++) {
            for (let i = 0; i < width; i++) {
                const val = grid[i + width * j];
                const c = Math.floor(val * 255) & 0xff;
                const pixel = (i + j * imageData.width) * 4;
                const color = this.colorFcn(c);
                imageData.data[pixel] = color.r;
                imageData.data[pixel + 1] = color.g;
                imageData.data[pixel + 2] = color.b;
                imageData.data[pixel + 3] = Math.floor(color.a * 255);
            }
        }
        ctx.putImageData(imageData, x, y);
    }
}


/***/ }),

/***/ "./Math/Random.ts":
/*!************************!*\
  !*** ./Math/Random.ts ***!
  \************************/
/*! exports provided: Random */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Random", function() { return Random; });
/**
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 */
/**
 * 32-bit mask
 */
const BITMASK32 = 0xffffffff;
/**
 * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
 * of numbers each time it is called.
 * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
 * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
 *
 * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
 */
class Random {
    /**
     * If no seed is specified, the Date.now() is used
     */
    constructor(seed) {
        this.seed = seed;
        // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
        this._lowerMask = 0x7fffffff; // 31 bits same as _r
        this._upperMask = 0x80000000; // 34 high bits
        // Word size, 64 bits
        this._w = 32;
        // Degree of recurrence
        this._n = 624;
        // Middle word, an offset used in the recurrence defining the series x, 1<=m<n
        this._m = 397;
        // coefficients of teh rational normal form twist matrix
        this._a = 0x9908b0df;
        // tempering bit shifts and masks
        this._u = 11;
        this._s = 7;
        this._b = 0x9d2c5680;
        this._t = 15;
        this._c = 0xefc60000;
        this._l = 18;
        this._f = 1812433253;
        this._mt = new Array(this._n);
        // need to mask to support higher bit machines
        this._mt[0] = (seed || Date.now()) >>> 0;
        for (let i = 1; i < this._n; i++) {
            const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
            // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits
            this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;
        }
        this._index = this._n;
    }
    /**
     * Apply the twist
     */
    _twist() {
        const mag01 = [0x0, this._a];
        let y = 0, i = 0;
        for (; i < this._n - this._m; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        for (; i < this._n - 1; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
        this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        this._index = 0;
    }
    /**
     * Return next 32 bit integer number in sequence
     */
    nextInt() {
        if (this._index >= this._n) {
            this._twist();
        }
        let y = this._mt[this._index++];
        y ^= y >>> this._u;
        y ^= (y << this._s) & this._b;
        y ^= (y << this._t) & this._c;
        y ^= y >>> this._l;
        return y >>> 0;
    }
    /**
     * Return a random floating point number between [0, 1)
     */
    next() {
        return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
    }
    /**
     * Return a random floating point in range [min, max) min is included, max is not included
     */
    floating(min, max) {
        return (max - min) * this.next() + min;
    }
    /**
     * Return a random integer in range [min, max] min is included, max is included.
     * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
     */
    integer(min, max) {
        return Math.floor((max - min + 1) * this.next() + min);
    }
    /**
     * Returns true or false randomly with 50/50 odds by default.
     * By default the likelihood of returning a true is .5 (50%).
     * @param likelihood takes values between [0, 1]
     */
    bool(likelihood = 0.5) {
        return this.next() <= likelihood;
    }
    /**
     * Returns one element from an array at random
     */
    pickOne(array) {
        return array[this.integer(0, array.length - 1)];
    }
    /**
     * Returns a new array random picking elements from the original
     * @param array Original array to pick from
     * @param numPicks can be any positive number
     * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
     * just that it is possible)
     */
    pickSet(array, numPicks, allowDuplicates = false) {
        if (allowDuplicates) {
            return this._pickSetWithDuplicates(array, numPicks);
        }
        else {
            return this._pickSetWithoutDuplicates(array, numPicks);
        }
    }
    /**
     * Returns a new array randomly picking elements in the original (not reused)
     * @param array Array to pick elements out of
     * @param numPicks must be less than or equal to the number of elements in the array.
     */
    _pickSetWithoutDuplicates(array, numPicks) {
        if (numPicks > array.length || numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
        }
        if (numPicks === array.length) {
            return array;
        }
        const result = new Array(numPicks);
        let currentPick = 0;
        const tempArray = array.slice(0);
        while (currentPick < numPicks) {
            const index = this.integer(0, tempArray.length - 1);
            result[currentPick++] = tempArray[index];
            tempArray.splice(index, 1);
        }
        return result;
    }
    /**
     * Returns a new array random picking elements from the original allowing duplicates
     * @param array Array to pick elements out of
     * @param numPicks can be any positive number
     */
    _pickSetWithDuplicates(array, numPicks) {
        // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
        if (numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
        }
        const result = new Array(numPicks);
        for (let i = 0; i < numPicks; i++) {
            result[i] = this.pickOne(array);
        }
        return result;
    }
    /**
     * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
     * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    shuffle(array) {
        const tempArray = array.slice(0);
        let swap = null;
        for (let i = 0; i < tempArray.length - 2; i++) {
            const randomIndex = this.integer(i, tempArray.length - 1);
            swap = tempArray[i];
            tempArray[i] = tempArray[randomIndex];
            tempArray[randomIndex] = swap;
        }
        return tempArray;
    }
    /**
     * Generate a list of random integer numbers
     * @param length the length of the final array
     * @param min the minimum integer number to generate inclusive
     * @param max the maximum integer number to generate inclusive
     */
    range(length, min, max) {
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.integer(min, max);
        }
        return result;
    }
    /**
     * Returns the result of a d4 dice roll
     */
    d4() {
        return this.integer(1, 4);
    }
    /**
     * Returns the result of a d6 dice roll
     */
    d6() {
        return this.integer(1, 6);
    }
    /**
     * Returns the result of a d8 dice roll
     */
    d8() {
        return this.integer(1, 8);
    }
    /**
     * Returns the result of a d10 dice roll
     */
    d10() {
        return this.integer(1, 10);
    }
    /**
     * Returns the result of a d12 dice roll
     */
    d12() {
        return this.integer(1, 12);
    }
    /**
     * Returns the result of a d20 dice roll
     */
    d20() {
        return this.integer(1, 20);
    }
}


/***/ }),

/***/ "./Particles.ts":
/*!**********************!*\
  !*** ./Particles.ts ***!
  \**********************/
/*! exports provided: EmitterType, ParticleImpl, Particle, ParticleEmitterImpl, ParticleEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmitterType", function() { return EmitterType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleImpl", function() { return ParticleImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleEmitterImpl", function() { return ParticleEmitterImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleEmitter", function() { return ParticleEmitter; });
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Actor */ "./Actor.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Algebra */ "./Algebra.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Util/DrawUtil */ "./Util/DrawUtil.ts");
/* harmony import */ var _Traits_Index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Traits/Index */ "./Traits/Index.ts");
/* harmony import */ var _Configurable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Configurable */ "./Configurable.ts");
/* harmony import */ var _Math_Random__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Math/Random */ "./Math/Random.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Collision/CollisionType */ "./Collision/CollisionType.ts");









/**
 * An enum that represents the types of emitter nozzles
 */
var EmitterType;
(function (EmitterType) {
    /**
     * Constant for the circular emitter type
     */
    EmitterType[EmitterType["Circle"] = 0] = "Circle";
    /**
     * Constant for the rectangular emitter type
     */
    EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
})(EmitterType || (EmitterType = {}));
/**
 * @hidden
 */
class ParticleImpl {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        this.position = new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](0, 0);
        this.velocity = new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](0, 0);
        this.acceleration = new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](0, 0);
        this.particleRotationalVelocity = 0;
        this.currentRotation = 0;
        this.focus = null;
        this.focusAccel = 0;
        this.opacity = 1;
        this.beginColor = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].White;
        this.endColor = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].White;
        // Life is counted in ms
        this.life = 300;
        this.fadeFlag = false;
        // Color transitions
        this._rRate = 1;
        this._gRate = 1;
        this._bRate = 1;
        this._aRate = 0;
        this._currentColor = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].White;
        this.emitter = null;
        this.particleSize = 5;
        this.particleSprite = null;
        this.sizeRate = 0;
        this.elapsedMultiplier = 0;
        let emitter = emitterOrConfig;
        if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {
            const config = emitterOrConfig;
            emitter = config.emitter;
            life = config.life;
            opacity = config.opacity;
            endColor = config.endColor;
            beginColor = config.beginColor;
            position = config.position;
            velocity = config.velocity;
            acceleration = config.acceleration;
            startSize = config.startSize;
            endSize = config.endSize;
        }
        this.emitter = emitter;
        this.life = life || this.life;
        this.opacity = opacity || this.opacity;
        this.endColor = endColor || this.endColor.clone();
        this.beginColor = beginColor || this.beginColor.clone();
        this._currentColor = this.beginColor.clone();
        this.position = position || this.position;
        this.velocity = velocity || this.velocity;
        this.acceleration = acceleration || this.acceleration;
        this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
        this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
        this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
        this._aRate = this.opacity / this.life;
        this.startSize = startSize || 0;
        this.endSize = endSize || 0;
        if (this.endSize > 0 && this.startSize > 0) {
            this.sizeRate = (this.endSize - this.startSize) / this.life;
            this.particleSize = this.startSize;
        }
    }
    kill() {
        this.emitter.removeParticle(this);
    }
    update(delta) {
        this.life = this.life - delta;
        this.elapsedMultiplier = this.elapsedMultiplier + delta;
        if (this.life < 0) {
            this.kill();
        }
        if (this.fadeFlag) {
            this.opacity = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["clamp"](this._aRate * this.life, 0.0001, 1);
        }
        if (this.startSize > 0 && this.endSize > 0) {
            this.particleSize = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["clamp"](this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
        }
        this._currentColor.r = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["clamp"](this._currentColor.r + this._rRate * delta, 0, 255);
        this._currentColor.g = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["clamp"](this._currentColor.g + this._gRate * delta, 0, 255);
        this._currentColor.b = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["clamp"](this._currentColor.b + this._bRate * delta, 0, 255);
        this._currentColor.a = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["clamp"](this.opacity, 0.0001, 1);
        if (this.focus) {
            const accel = this.focus
                .sub(this.position)
                .normalize()
                .scale(this.focusAccel)
                .scale(delta / 1000);
            this.velocity = this.velocity.add(accel);
        }
        else {
            this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
        }
        this.position = this.position.add(this.velocity.scale(delta / 1000));
        if (this.particleRotationalVelocity) {
            this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);
        }
    }
    draw(ctx) {
        if (this.particleSprite) {
            this.particleSprite.rotation = this.currentRotation;
            this.particleSprite.scale.setTo(this.particleSize, this.particleSize);
            this.particleSprite.draw(ctx, this.position.x, this.position.y);
            return;
        }
        this._currentColor.a = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["clamp"](this.opacity, 0.0001, 1);
        ctx.fillStyle = this._currentColor.toString();
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.particleSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
    }
}
/**
 * Particle is used in a [[ParticleEmitter]]
 */
class Particle extends Object(_Configurable__WEBPACK_IMPORTED_MODULE_6__["Configurable"])(ParticleImpl) {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);
    }
}
/**
 * @hidden
 */
class ParticleEmitterImpl extends _Actor__WEBPACK_IMPORTED_MODULE_0__["Actor"] {
    /**
     * @param xOrConfig The x position of the emitter, or the particle emitter options bag
     * @param y         The y position of the emitter
     * @param width     The width of the emitter
     * @param height    The height of the emitter
     */
    constructor(xOrConfig, y, width, height) {
        super(typeof xOrConfig === 'number' ? { pos: new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](xOrConfig, y), width: width, height: height } : xOrConfig);
        this.numParticles = 0;
        /**
         * Gets or sets the isEmitting flag
         */
        this.isEmitting = true;
        /**
         * Gets or sets the backing particle collection
         */
        this.particles = null;
        /**
         * Gets or sets the backing deadParticle collection
         */
        this.deadParticles = null;
        /**
         * Gets or sets the minimum particle velocity
         */
        this.minVel = 0;
        /**
         * Gets or sets the maximum particle velocity
         */
        this.maxVel = 0;
        /**
         * Gets or sets the acceleration vector for all particles
         */
        this.acceleration = new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](0, 0);
        /**
         * Gets or sets the minimum angle in radians
         */
        this.minAngle = 0;
        /**
         * Gets or sets the maximum angle in radians
         */
        this.maxAngle = 0;
        /**
         * Gets or sets the emission rate for particles (particles/sec)
         */
        this.emitRate = 1; //particles/sec
        /**
         * Gets or sets the life of each particle in milliseconds
         */
        this.particleLife = 2000;
        /**
         * Gets or sets the opacity of each particle from 0 to 1.0
         */
        this.opacity = 1;
        /**
         * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
         */
        this.fadeFlag = false;
        /**
         * Gets or sets the optional focus where all particles should accelerate towards
         */
        this.focus = null;
        /**
         * Gets or sets the acceleration for focusing particles if a focus has been specified
         */
        this.focusAccel = 1;
        /*
         * Gets or sets the optional starting size for the particles
         */
        this.startSize = null;
        /*
         * Gets or sets the optional ending size for the particles
         */
        this.endSize = null;
        /**
         * Gets or sets the minimum size of all particles
         */
        this.minSize = 5;
        /**
         * Gets or sets the maximum size of all particles
         */
        this.maxSize = 5;
        /**
         * Gets or sets the beginning color of all particles
         */
        this.beginColor = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].White;
        /**
         * Gets or sets the ending color of all particles
         */
        this.endColor = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].White;
        /**
         * Gets or sets the sprite that a particle should use
         * @warning Performance intensive
         */
        this.particleSprite = null;
        /**
         * Gets or sets the emitter type for the particle emitter
         */
        this.emitterType = EmitterType.Rectangle;
        /**
         * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]
         */
        this.radius = 0;
        /**
         * Gets or sets the particle rotational speed velocity
         */
        this.particleRotationalVelocity = 0;
        /**
         * Indicates whether particles should start with a random rotation
         */
        this.randomRotation = false;
        this._particlesToEmit = 0;
        this.body.collider.type = _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_8__["CollisionType"].PreventCollision;
        this.particles = new _Util_Util__WEBPACK_IMPORTED_MODULE_3__["Collection"]();
        this.deadParticles = new _Util_Util__WEBPACK_IMPORTED_MODULE_3__["Collection"]();
        this.random = new _Math_Random__WEBPACK_IMPORTED_MODULE_7__["Random"]();
        // Remove offscreen culling from particle emitters
        for (let i = 0; i < this.traits.length; i++) {
            if (this.traits[i] instanceof _Traits_Index__WEBPACK_IMPORTED_MODULE_5__["OffscreenCulling"]) {
                this.traits.splice(i, 1);
            }
        }
    }
    removeParticle(particle) {
        this.deadParticles.push(particle);
    }
    /**
     * Causes the emitter to emit particles
     * @param particleCount  Number of particles to emit right now
     */
    emitParticles(particleCount) {
        for (let i = 0; i < particleCount; i++) {
            this.particles.push(this._createParticle());
        }
    }
    clearParticles() {
        this.particles.clear();
    }
    // Creates a new particle given the constraints of the emitter
    _createParticle() {
        // todo implement emitter constraints;
        let ranX = 0;
        let ranY = 0;
        const angle = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["randomInRange"](this.minAngle, this.maxAngle, this.random);
        const vel = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["randomInRange"](this.minVel, this.maxVel, this.random);
        const size = this.startSize || _Util_Util__WEBPACK_IMPORTED_MODULE_3__["randomInRange"](this.minSize, this.maxSize, this.random);
        const dx = vel * Math.cos(angle);
        const dy = vel * Math.sin(angle);
        if (this.emitterType === EmitterType.Rectangle) {
            ranX = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["randomInRange"](0, this.width, this.random);
            ranY = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["randomInRange"](0, this.height, this.random);
        }
        else if (this.emitterType === EmitterType.Circle) {
            const radius = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["randomInRange"](0, this.radius, this.random);
            ranX = radius * Math.cos(angle);
            ranY = radius * Math.sin(angle);
        }
        const p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](ranX, ranY), new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](dx, dy), this.acceleration, this.startSize, this.endSize);
        p.fadeFlag = this.fadeFlag;
        p.particleSize = size;
        if (this.particleSprite) {
            p.particleSprite = this.particleSprite;
        }
        p.particleRotationalVelocity = this.particleRotationalVelocity;
        if (this.randomRotation) {
            p.currentRotation = _Util_Util__WEBPACK_IMPORTED_MODULE_3__["randomInRange"](0, Math.PI * 2, this.random);
        }
        if (this.focus) {
            p.focus = this.focus.add(new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](this.pos.x, this.pos.y));
            p.focusAccel = this.focusAccel;
        }
        return p;
    }
    update(engine, delta) {
        super.update(engine, delta);
        if (this.isEmitting) {
            this._particlesToEmit += this.emitRate * (delta / 1000);
            //var numParticles = Math.ceil(this.emitRate * delta / 1000);
            if (this._particlesToEmit > 1.0) {
                this.emitParticles(Math.floor(this._particlesToEmit));
                this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
            }
        }
        this.particles.forEach((p) => p.update(delta));
        this.deadParticles.forEach((p) => this.particles.removeElement(p));
        this.deadParticles.clear();
    }
    draw(ctx) {
        // todo is there a more efficient to draw
        // possibly use a webgl offscreen canvas and shaders to do particles?
        this.particles.forEach((p) => p.draw(ctx));
    }
    debugDraw(ctx) {
        super.debugDraw(ctx);
        ctx.fillStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Black.toString();
        ctx.fillText('Particles: ' + this.particles.count(), this.pos.x, this.pos.y + 20);
        if (this.focus) {
            ctx.fillRect(this.focus.x + this.pos.x, this.focus.y + this.pos.y, 3, 3);
            _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_4__["line"](ctx, _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Yellow, this.focus.x + this.pos.x, this.focus.y + this.pos.y, this.center.x, this.center.y);
            ctx.fillText('Focus', this.focus.x + this.pos.x, this.focus.y + this.pos.y);
        }
    }
}
/**
 * Using a particle emitter is a great way to create interesting effects
 * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
 * extend [[Actor]] allowing you to use all of the features that come with.
 */
class ParticleEmitter extends Object(_Configurable__WEBPACK_IMPORTED_MODULE_6__["Configurable"])(ParticleEmitterImpl) {
    constructor(xOrConfig, y, width, height) {
        super(xOrConfig, y, width, height);
    }
}


/***/ }),

/***/ "./Physics.ts":
/*!********************!*\
  !*** ./Physics.ts ***!
  \********************/
/*! exports provided: CollisionResolutionStrategy, BroadphaseStrategy, Integrator, Physics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollisionResolutionStrategy", function() { return CollisionResolutionStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BroadphaseStrategy", function() { return BroadphaseStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Integrator", function() { return Integrator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Physics", function() { return Physics; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Algebra */ "./Algebra.ts");
/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Util/Decorators */ "./Util/Decorators.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Possible collision resolution strategies
 *
 * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated
 * simulated physical interactions.
 */
var CollisionResolutionStrategy;
(function (CollisionResolutionStrategy) {
    CollisionResolutionStrategy[CollisionResolutionStrategy["Box"] = 0] = "Box";
    CollisionResolutionStrategy[CollisionResolutionStrategy["RigidBody"] = 1] = "RigidBody";
})(CollisionResolutionStrategy || (CollisionResolutionStrategy = {}));
/**
 * Possible broadphase collision pair identification strategies
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy
 * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.
 */
var BroadphaseStrategy;
(function (BroadphaseStrategy) {
    BroadphaseStrategy[BroadphaseStrategy["Naive"] = 0] = "Naive";
    BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 1] = "DynamicAABBTree";
})(BroadphaseStrategy || (BroadphaseStrategy = {}));
/**
 * Possible numerical integrators for position and velocity
 */
var Integrator;
(function (Integrator) {
    Integrator[Integrator["Euler"] = 0] = "Euler";
})(Integrator || (Integrator = {}));
/**
 * The [[Physics]] object is the global configuration object for all Excalibur physics.
 */
/* istanbul ignore next */
class Physics {
    /**
     * Configures Excalibur to use box physics. Box physics which performs simple axis aligned arcade style physics.
     */
    static useBoxPhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;
    }
    /**
     * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
     * simulated physical interactions.
     */
    static useRigidBodyPhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.RigidBody;
    }
    static get dynamicTreeVelocityMultiplyer() {
        return Physics.dynamicTreeVelocityMultiplier;
    }
    static set dynamicTreeVelocityMultiplyer(value) {
        Physics.dynamicTreeVelocityMultiplier = value;
    }
}
/**
 * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.
 * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.
 *
 * This is a great way to globally simulate effects like gravity.
 */
Physics.acc = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0);
/**
 * Globally switches all Excalibur physics behavior on or off.
 */
Physics.enabled = true;
/**
 * Gets or sets the number of collision passes for Excalibur to perform on physics bodies.
 *
 * Reducing collision passes may cause things not to collide as expected in your game, but may increase performance.
 *
 * More passes can improve the visual quality of collisions when many objects are on the screen. This can reduce jitter, improve the
 * collision resolution of fast move objects, or the stability of large numbers of objects stacked together.
 *
 * Fewer passes will improve the performance of the game at the cost of collision quality, more passes will improve quality at the
 * cost of performance.
 *
 * The default is set to 5 passes which is a good start.
 */
Physics.collisionPasses = 5;
/**
 * Gets or sets the broadphase pair identification strategy.
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy
 * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.
 */
Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
/**
 * Globally switches the debug information for the broadphase strategy
 */
Physics.broadphaseDebug = false;
/**
 * Show the normals as a result of collision on the screen.
 */
Physics.showCollisionNormals = false;
/**
 * Show the position, velocity, and acceleration as graphical vectors.
 */
Physics.showMotionVectors = false;
/**
 * Show the axis-aligned bounding boxes of the collision bodies on the screen.
 */
Physics.showBounds = false;
/**
 * Show the bounding collision area shapes
 */
Physics.showArea = false;
/**
 * Show points of collision interpreted by excalibur as a result of collision.
 */
Physics.showContacts = false;
/**
 * Show the surface normals of the collision areas.
 */
Physics.showNormals = false;
/**
 * Gets or sets the global collision resolution strategy (narrowphase).
 *
 * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated
 * simulated physical interactions.
 */
Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;
/**
 * The default mass to use if none is specified
 */
Physics.defaultMass = 10;
/**
 * Gets or sets the position and velocity positional integrator, currently only Euler is supported.
 */
Physics.integrator = Integrator.Euler;
/**
 * Number of steps to use in integration. A higher number improves the positional accuracy over time. This can be useful to increase
 * if you have fast moving objects in your simulation or you have a large number of objects and need to increase stability.
 */
Physics.integrationSteps = 1;
/**
 * Gets or sets whether rotation is allowed in a RigidBody collision resolution
 */
Physics.allowRigidBodyRotation = true;
/**
 * Small value to help collision passes settle themselves after the narrowphase.
 */
Physics.collisionShift = 0.001;
/**
 * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);
 */
Physics.dynamicTreeVelocityMultiplier = 2;
/**
 * Pad RigidBody BoundingBox by a constant amount
 */
Physics.boundsPadding = 5;
/**
 * Surface epsilon is used to help deal with surface penetration
 */
Physics.surfaceEpsilon = 0.1;
/**
 * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent
 * bodies from tunneling through one another.
 */
Physics.checkForFastBodies = true;
/**
 * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the
 * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,
 * Excalibur will always perform the fast body raycast regardless of speed.
 */
Physics.disableMinimumSpeedForFastBody = false;
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_1__["obsolete"])({
        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',
        alternateMethod: 'dynamicTreeVelocityMultiplier'
    })
], Physics, "dynamicTreeVelocityMultiplyer", null);


/***/ }),

/***/ "./Polyfill.ts":
/*!*********************!*\
  !*** ./Polyfill.ts ***!
  \*********************/
/*! exports provided: polyfill */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyfill", function() { return polyfill; });
/* harmony import */ var core_js_es_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/es/array */ "../../node_modules/core-js/es/array/index.js");
/* harmony import */ var core_js_es_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_es_array__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_es_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/es/object */ "../../node_modules/core-js/es/object/index.js");
/* harmony import */ var core_js_es_object__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_es_object__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_es_function__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/es/function */ "../../node_modules/core-js/es/function/index.js");
/* harmony import */ var core_js_es_function__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_es_function__WEBPACK_IMPORTED_MODULE_2__);



/**
 * Polyfill adding function
 */
function polyfill() {
    /* istanbul ignore next */
    if (typeof window === 'undefined') {
        window = {
            audioContext: function () {
                return;
            }
        };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
        window.requestAnimationFrame =
            window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setInterval(callback, 1000 / 60);
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
        window.cancelAnimationFrame =
            window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                function () {
                    return;
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.AudioContext) {
        window.AudioContext =
            window.AudioContext ||
                window.webkitAudioContext ||
                window.mozAudioContext ||
                window.msAudioContext ||
                window.oAudioContext;
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.devicePixelRatio) {
        window.devicePixelRatio = window.devicePixelRatio || 1;
    }
}


/***/ }),

/***/ "./PostProcessing/ColorBlindCorrector.ts":
/*!***********************************************!*\
  !*** ./PostProcessing/ColorBlindCorrector.ts ***!
  \***********************************************/
/*! exports provided: ColorBlindness, ColorBlindCorrector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorBlindness", function() { return ColorBlindness; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorBlindCorrector", function() { return ColorBlindCorrector; });
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../Util/Log */ "./Util/Log.ts");

var ColorBlindness;
(function (ColorBlindness) {
    ColorBlindness[ColorBlindness["Protanope"] = 0] = "Protanope";
    ColorBlindness[ColorBlindness["Deuteranope"] = 1] = "Deuteranope";
    ColorBlindness[ColorBlindness["Tritanope"] = 2] = "Tritanope";
})(ColorBlindness || (ColorBlindness = {}));
/**
 * This post processor can correct colors and simulate color blindness.
 * It is possible to use this on every game, but the game's performance
 * will suffer measurably. It's better to use it as a helpful tool while developing your game.
 * Remember, the best practice is to design with color blindness in mind.
 */
class ColorBlindCorrector {
    constructor(engine, simulate = false, colorMode = ColorBlindness.Protanope) {
        this.engine = engine;
        this.simulate = simulate;
        this.colorMode = colorMode;
        /*eslint-disable */
        this._vertexShader = '' +
            'attribute vec2 a_position;' +
            'attribute vec2 a_texCoord;' +
            'uniform vec2 u_resolution;' +
            'varying vec2 v_texCoord;' +
            'void main() {' +
            // convert the rectangle from pixels to 0.0 to 1.0
            'vec2 zeroToOne = a_position / u_resolution;' +
            // convert from 0->1 to 0->2
            'vec2 zeroToTwo = zeroToOne * 2.0;' +
            // convert from 0->2 to -1->+1 (clipspace)
            'vec2 clipSpace = zeroToTwo - 1.0;' +
            'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' +
            // pass the texCoord to the fragment shader
            // The GPU will interpolate this value between points.
            'v_texCoord = a_texCoord;' +
            '}';
        this._fragmentShader = 'precision mediump float;' +
            // our texture
            'uniform sampler2D u_image;' +
            // the texCoords passed in from the vertex shader.
            'varying vec2 v_texCoord;' +
            // Color blind conversions
            /*'mat3 m[9] =' +
           '{' +
              'mat3(1.0, 0.0, 0.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0  ),' + // normal
              'mat3(0.567, 0.433, 0.0,  0.558, 0.442, 0.0,  0.0, 0.242, 0.758),' + // protanopia
              'mat3(0.817, 0.183, 0.0,  0.333, 0.667, 0.0,  0.0, 0.125,0.875),' + // protanomaly
              'mat3(0.625, 0.375, 0.0,  0.7, 0.3, 0.0,  0.0, 0.3,0.7  ),' + // deuteranopia
              'mat3(0.8, 0.2, 0.0,  0.258, 0.742, 0.0,  0.0, 0.142,0.858),' + // deuteranomaly
              'mat3(0.95, 0.05, 0.0,  0.0, 0.433, 0.567,  0.0, 0.475,0.525),' + // tritanopia
              'mat3(0.967, 0.033, 0.0,  0.0, 0.733, 0.267,  0.0, 0.183,0.817),' + // tritanomaly
              'mat3(0.299, 0.587, 0.114,  0.299, 0.587, 0.114,  0.299, 0.587,0.114),' + // achromatopsia
              'mat3(0.618, 0.320, 0.062,  0.163, 0.775, 0.062,  0.163, 0.320,0.516)' +  // achromatomaly
           '};' +*/
            'void main() {' +
            'vec4 o =  texture2D(u_image, v_texCoord);' +
            // RGB to LMS matrix conversion
            'float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);' +
            'float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);' +
            'float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);' +
            // Simulate color blindness
            '//MODE CODE//' +
            /* Deuteranope for testing
              'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;' +*/
            // LMS to RGB matrix conversion
            'vec4 error;' +
            'error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);' +
            'error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);' +
            'error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);' +
            'error.a = 1.0;' +
            'vec4 diff = o - error;' +
            'vec4 correction;' +
            'correction.r = 0.0;' +
            'correction.g =  (diff.r * 0.7) + (diff.g * 1.0);' +
            'correction.b =  (diff.r * 0.7) + (diff.b * 1.0);' +
            'correction = o + correction;' +
            'correction.a = o.a;' +
            '//SIMULATE//' +
            '}';
        this._internalCanvas = document.createElement('canvas');
        this._internalCanvas.width = engine.drawWidth;
        this._internalCanvas.height = engine.drawHeight;
        // eslint-disable-next-line
        this._gl = this._internalCanvas.getContext('webgl', { preserveDrawingBuffer: true });
        this._program = this._gl.createProgram();
        const fragmentShader = this._getShader('Fragment', this._getFragmentShaderByMode(colorMode));
        const vertextShader = this._getShader('Vertex', this._vertexShader);
        this._gl.attachShader(this._program, vertextShader);
        this._gl.attachShader(this._program, fragmentShader);
        this._gl.linkProgram(this._program);
        if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_0__["Logger"].getInstance().error('Unable to link shader program!');
        }
        this._gl.useProgram(this._program);
    }
    _getFragmentShaderByMode(colorMode) {
        let code = '';
        if (colorMode === ColorBlindness.Protanope) {
            code =
                'float l = 0.0 * L + 2.02344 * M + -2.52581 * S;' +
                    'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
        }
        else if (colorMode === ColorBlindness.Deuteranope) {
            code =
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
        }
        else if (colorMode === ColorBlindness.Tritanope) {
            code =
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                    'float s = -0.395913 * L + 0.801109 * M + 0.0 * S;';
        }
        if (this.simulate) {
            this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = error.rgba;');
        }
        else {
            this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = correction.rgba;');
        }
        return this._fragmentShader.replace('//MODE CODE//', code);
    }
    _setRectangle(x, y, width, height) {
        const x1 = x;
        const x2 = x + width;
        const y1 = y;
        const y2 = y + height;
        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), this._gl.STATIC_DRAW);
    }
    _getShader(type, program) {
        let shader;
        if (type === 'Fragment') {
            shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
        }
        else if (type === 'Vertex') {
            shader = this._gl.createShader(this._gl.VERTEX_SHADER);
        }
        else {
            _Util_Log__WEBPACK_IMPORTED_MODULE_0__["Logger"].getInstance().error('Error unknown shader type', type);
        }
        this._gl.shaderSource(shader, program);
        this._gl.compileShader(shader);
        if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_0__["Logger"].getInstance().error('Unable to compile shader!', this._gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
    process(image, out) {
        // look up where the vertex data needs to go.
        const positionLocation = this._gl.getAttribLocation(this._program, 'a_position');
        const texCoordLocation = this._gl.getAttribLocation(this._program, 'a_texCoord');
        const texCoordBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, texCoordBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), this._gl.STATIC_DRAW);
        this._gl.enableVertexAttribArray(texCoordLocation);
        this._gl.vertexAttribPointer(texCoordLocation, 2, this._gl.FLOAT, false, 0, 0);
        // Create a texture.
        const texture = this._gl.createTexture();
        this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
        // Set the parameters so we can render any size image.
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
        // Flip the texture when unpacking into the gl context, gl reads textures in the opposite order as everything else :/
        this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);
        // Upload the image into the texture.
        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
        // lookup uniforms
        const resolutionLocation = this._gl.getUniformLocation(this._program, 'u_resolution');
        // set the resolution
        this._gl.uniform2f(resolutionLocation, this._internalCanvas.width, this._internalCanvas.height);
        // Create a buffer for the position of the rectangle corners.
        const positionBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, positionBuffer);
        this._gl.enableVertexAttribArray(positionLocation);
        this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);
        // Set a rectangle the same size as the image.
        this._setRectangle(0, 0, image.width, image.height);
        // Draw the rectangle.
        this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
        // Grab transformed image from internal canvas
        const pixelData = new Uint8Array(image.width * image.height * 4);
        this._gl.readPixels(0, 0, image.width, image.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixelData);
        image.data.set(pixelData);
        out.putImageData(image, 0, 0);
    }
}


/***/ }),

/***/ "./PostProcessing/Index.ts":
/*!*********************************!*\
  !*** ./PostProcessing/Index.ts ***!
  \*********************************/
/*! exports provided: ColorBlindness, ColorBlindCorrector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ColorBlindCorrector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorBlindCorrector */ "./PostProcessing/ColorBlindCorrector.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorBlindness", function() { return _ColorBlindCorrector__WEBPACK_IMPORTED_MODULE_0__["ColorBlindness"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorBlindCorrector", function() { return _ColorBlindCorrector__WEBPACK_IMPORTED_MODULE_0__["ColorBlindCorrector"]; });

/* harmony import */ var _PostProcessor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostProcessor */ "./PostProcessing/PostProcessor.ts");
/* empty/unused harmony star reexport */



/***/ }),

/***/ "./PostProcessing/PostProcessor.ts":
/*!*****************************************!*\
  !*** ./PostProcessing/PostProcessor.ts ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./Promises.ts":
/*!*********************!*\
  !*** ./Promises.ts ***!
  \*********************/
/*! exports provided: PromiseState, Promise */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PromiseState", function() { return PromiseState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Promise", function() { return Promise; });
/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util/Decorators */ "./Util/Decorators.ts");
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Promise_1;

/**
 * Valid states for a promise to be in
 * @deprecated Will be removed in v0.26.0
 */
var PromiseState;
(function (PromiseState) {
    PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
    PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
    PromiseState[PromiseState["Pending"] = 2] = "Pending";
})(PromiseState || (PromiseState = {}));
/**
 * Promises are used to do asynchronous work and they are useful for
 * creating a chain of actions. In Excalibur they are used for loading,
 * sounds, animation, actions, and more.
 * @deprecated Will be removed in v0.26.0
 */
let Promise = Promise_1 = class Promise {
    constructor() {
        this._state = PromiseState.Pending;
        this._successCallbacks = [];
        this._rejectCallback = () => {
            return;
        };
    }
    /**
     * Create and resolve a Promise with an optional value
     * @param value  An optional value to wrap in a resolved promise
     */
    static resolve(value) {
        const promise = new Promise_1().resolve(value);
        return promise;
    }
    /**
     * Create and reject a Promise with an optional value
     * @param value  An optional value to wrap in a rejected promise
     */
    static reject(value) {
        const promise = new Promise_1().reject(value);
        return promise;
    }
    static join() {
        let promises = [];
        if (arguments.length > 0 && !Array.isArray(arguments[0])) {
            for (let _i = 0; _i < arguments.length; _i++) {
                promises[_i - 0] = arguments[_i];
            }
        }
        else if (arguments.length === 1 && Array.isArray(arguments[0])) {
            promises = arguments[0];
        }
        const joinedPromise = new Promise_1();
        if (!promises || !promises.length) {
            return joinedPromise.resolve();
        }
        const total = promises.length;
        let successes = 0;
        let rejects = 0;
        const errors = [];
        promises.forEach((p) => {
            p.then(() => {
                successes += 1;
                if (successes === total) {
                    joinedPromise.resolve();
                }
                else if (successes + rejects + errors.length === total) {
                    joinedPromise.reject(errors);
                }
            }, () => {
                rejects += 1;
                if (successes + rejects + errors.length === total) {
                    joinedPromise.reject(errors);
                }
            }).error((e) => {
                errors.push(e);
                if (errors.length + successes + rejects === total) {
                    joinedPromise.reject(errors);
                }
            });
        });
        return joinedPromise;
    }
    /**
     * Chain success and reject callbacks after the promise is resolved
     * @param successCallback  Call on resolution of promise
     * @param rejectCallback   Call on rejection of promise
     */
    then(successCallback, rejectCallback) {
        if (successCallback) {
            this._successCallbacks.push(successCallback);
            // If the promise is already resolved call immediately
            if (this.state() === PromiseState.Resolved) {
                try {
                    successCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
        }
        if (rejectCallback) {
            this._rejectCallback = rejectCallback;
            // If the promise is already rejected call immediately
            if (this.state() === PromiseState.Rejected) {
                try {
                    rejectCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
        }
        return this;
    }
    /**
     * Add an error callback to the promise
     * @param errorCallback  Call if there was an error in a callback
     */
    error(errorCallback) {
        if (errorCallback) {
            this._errorCallback = errorCallback;
        }
        return this;
    }
    /**
     * Resolve the promise and pass an option value to the success callbacks
     * @param value  Value to pass to the success callbacks
     */
    resolve(value) {
        if (this._state === PromiseState.Pending) {
            this._value = value;
            try {
                this._state = PromiseState.Resolved;
                this._successCallbacks.forEach((cb) => {
                    cb.call(this, this._value);
                });
            }
            catch (e) {
                this._handleError(e);
            }
        }
        else {
            throw new Error('Cannot resolve a promise that is not in a pending state!');
        }
        return this;
    }
    /**
     * Reject the promise and pass an option value to the reject callbacks
     * @param value  Value to pass to the reject callbacks
     */
    reject(value) {
        if (this._state === PromiseState.Pending) {
            this._value = value;
            try {
                this._state = PromiseState.Rejected;
                this._rejectCallback.call(this, this._value);
            }
            catch (e) {
                this._handleError(e);
            }
        }
        else {
            throw new Error('Cannot reject a promise that is not in a pending state!');
        }
        return this;
    }
    /**
     * Inspect the current state of a promise
     */
    state() {
        return this._state;
    }
    _handleError(e) {
        if (this._errorCallback) {
            this._errorCallback.call(this, e);
        }
        else {
            // rethrow error
            throw e;
        }
    }
};
Promise = Promise_1 = __decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_0__["obsolete"])({
        message: 'ex.Promises are being replaced by native browser promises in v0.26.0',
        alternateMethod: 'Use browser native promises'
    })
], Promise);



/***/ }),

/***/ "./Resources/Gif.ts":
/*!**************************!*\
  !*** ./Resources/Gif.ts ***!
  \**************************/
/*! exports provided: Gif, Stream, ParseGif */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gif", function() { return Gif; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stream", function() { return Stream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParseGif", function() { return ParseGif; });
/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Resource */ "./Resources/Resource.ts");
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Texture */ "./Resources/Texture.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Drawing_SpriteSheet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Drawing/SpriteSheet */ "./Drawing/SpriteSheet.ts");




/**
 * The [[Texture]] object allows games built in Excalibur to load image resources.
 * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]
 * to pre-load before starting a level or game.
 */
class Gif extends _Resource__WEBPACK_IMPORTED_MODULE_0__["Resource"] {
    /**
     * @param path       Path to the image resource
     * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].Magenta, bustCache = true) {
        super(path, 'arraybuffer', bustCache);
        this.path = path;
        this.color = color;
        this.bustCache = bustCache;
        /**
         * A [[Promise]] that resolves when the Texture is loaded.
         */
        this.loaded = new Promise((resolve) => {
            this._loadedResolve = resolve;
        });
        this._isLoaded = false;
        this._stream = null;
        this._gif = null;
        this._textures = [];
        this._animation = null;
        this._transparentColor = null;
        this._transparentColor = color;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return this._isLoaded;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    load() {
        const complete = new Promise((resolve, reject) => {
            return super.load().then(() => {
                this._stream = new Stream(this.getData());
                this._gif = new ParseGif(this._stream, this._transparentColor);
                const promises = [];
                for (let imageIndex = 0; imageIndex < this._gif.images.length; imageIndex++) {
                    const texture = new _Texture__WEBPACK_IMPORTED_MODULE_1__["Texture"](this._gif.images[imageIndex].src, false);
                    this._textures.push(texture);
                    promises.push(texture.load());
                }
                return Promise.all(promises).then(() => {
                    this._isLoaded = true;
                    this._loadedResolve(this._textures);
                    resolve(this._textures);
                });
            }, () => {
                reject('Error loading texture.');
            });
        });
        return complete;
    }
    asSprite(id = 0) {
        const sprite = this._textures[id].asSprite();
        return sprite;
    }
    asSpriteSheet() {
        const spriteArray = this._textures.map((texture) => {
            return texture.asSprite();
        });
        return new _Drawing_SpriteSheet__WEBPACK_IMPORTED_MODULE_3__["SpriteSheet"](spriteArray);
    }
    asAnimation(engine, speed) {
        const spriteSheet = this.asSpriteSheet();
        this._animation = spriteSheet.getAnimationForAll(engine, speed);
        return this._animation;
    }
    get readCheckBytes() {
        return this._gif.checkBytes;
    }
}
const bitsToNum = (ba) => {
    return ba.reduce(function (s, n) {
        return s * 2 + n;
    }, 0);
};
const byteToBitArr = (bite) => {
    const a = [];
    for (let i = 7; i >= 0; i--) {
        a.push(!!(bite & (1 << i)));
    }
    return a;
};
class Stream {
    constructor(dataArray) {
        this.data = null;
        this.len = 0;
        this.position = 0;
        this.readByte = () => {
            if (this.position >= this.data.byteLength) {
                throw new Error('Attempted to read past end of stream.');
            }
            return this.data[this.position++];
        };
        this.readBytes = (n) => {
            const bytes = [];
            for (let i = 0; i < n; i++) {
                bytes.push(this.readByte());
            }
            return bytes;
        };
        this.read = (n) => {
            let s = '';
            for (let i = 0; i < n; i++) {
                s += String.fromCharCode(this.readByte());
            }
            return s;
        };
        this.readUnsigned = () => {
            // Little-endian.
            const a = this.readBytes(2);
            return (a[1] << 8) + a[0];
        };
        this.data = new Uint8Array(dataArray);
        this.len = this.data.byteLength;
        if (this.len === 0) {
            throw new Error('No data loaded from file');
        }
    }
}
const lzwDecode = function (minCodeSize, data) {
    // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?
    let pos = 0; // Maybe this streaming thing should be merged with the Stream?
    const readCode = function (size) {
        let code = 0;
        for (let i = 0; i < size; i++) {
            if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
                code |= 1 << i;
            }
            pos++;
        }
        return code;
    };
    const output = [];
    const clearCode = 1 << minCodeSize;
    const eoiCode = clearCode + 1;
    let codeSize = minCodeSize + 1;
    let dict = [];
    const clear = function () {
        dict = [];
        codeSize = minCodeSize + 1;
        for (let i = 0; i < clearCode; i++) {
            dict[i] = [i];
        }
        dict[clearCode] = [];
        dict[eoiCode] = null;
    };
    let code;
    let last;
    while (true) {
        last = code;
        code = readCode(codeSize);
        if (code === clearCode) {
            clear();
            continue;
        }
        if (code === eoiCode) {
            break;
        }
        if (code < dict.length) {
            if (last !== clearCode) {
                dict.push(dict[last].concat(dict[code][0]));
            }
        }
        else {
            if (code !== dict.length) {
                throw new Error('Invalid LZW code.');
            }
            dict.push(dict[last].concat(dict[last][0]));
        }
        output.push.apply(output, dict[code]);
        if (dict.length === 1 << codeSize && codeSize < 12) {
            // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.
            codeSize++;
        }
    }
    // I don't know if this is technically an error, but some GIFs do it.
    //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');
    return output;
};
// The actual parsing; returns an object with properties.
class ParseGif {
    constructor(stream, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].Magenta) {
        this._st = null;
        this._handler = {};
        this._transparentColor = null;
        this.frames = [];
        this.images = [];
        this.globalColorTable = [];
        this.checkBytes = [];
        // LZW (GIF-specific)
        this.parseColorTable = (entries) => {
            // Each entry is 3 bytes, for RGB.
            const ct = [];
            for (let i = 0; i < entries; i++) {
                const rgb = this._st.readBytes(3);
                const rgba = '#' +
                    rgb
                        .map((x) => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    })
                        .join('');
                ct.push(rgba);
            }
            return ct;
        };
        this.readSubBlocks = () => {
            let size, data;
            data = '';
            do {
                size = this._st.readByte();
                data += this._st.read(size);
            } while (size !== 0);
            return data;
        };
        this.parseHeader = () => {
            const hdr = {
                sig: null,
                ver: null,
                width: null,
                height: null,
                colorRes: null,
                globalColorTableSize: null,
                gctFlag: null,
                sorted: null,
                globalColorTable: [],
                bgColor: null,
                pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            };
            hdr.sig = this._st.read(3);
            hdr.ver = this._st.read(3);
            if (hdr.sig !== 'GIF') {
                throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.
            }
            hdr.width = this._st.readUnsigned();
            hdr.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            hdr.gctFlag = bits.shift();
            hdr.colorRes = bitsToNum(bits.splice(0, 3));
            hdr.sorted = bits.shift();
            hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));
            hdr.bgColor = this._st.readByte();
            hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            if (hdr.gctFlag) {
                hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));
                this.globalColorTable = hdr.globalColorTable;
            }
            if (this._handler.hdr && this._handler.hdr(hdr)) {
                this.checkBytes.push(this._handler.hdr);
            }
        };
        this.parseExt = (block) => {
            const parseGCExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 4
                const bits = byteToBitArr(this._st.readByte());
                block.reserved = bits.splice(0, 3); // Reserved; should be 000.
                block.disposalMethod = bitsToNum(bits.splice(0, 3));
                block.userInput = bits.shift();
                block.transparencyGiven = bits.shift();
                block.delayTime = this._st.readUnsigned();
                block.transparencyIndex = this._st.readByte();
                block.terminator = this._st.readByte();
                if (this._handler.gce && this._handler.gce(block)) {
                    this.checkBytes.push(this._handler.gce);
                }
            };
            const parseComExt = (block) => {
                block.comment = this.readSubBlocks();
                if (this._handler.com && this._handler.com(block)) {
                    this.checkBytes.push(this._handler.com);
                }
            };
            const parsePTExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 12
                block.ptHeader = this._st.readBytes(12);
                block.ptData = this.readSubBlocks();
                if (this._handler.pte && this._handler.pte(block)) {
                    this.checkBytes.push(this._handler.pte);
                }
            };
            const parseAppExt = (block) => {
                const parseNetscapeExt = (block) => {
                    this.checkBytes.push(this._st.readByte()); // Always 3
                    block.unknown = this._st.readByte(); // ??? Always 1? What is this?
                    block.iterations = this._st.readUnsigned();
                    block.terminator = this._st.readByte();
                    if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {
                        this.checkBytes.push(this._handler.app);
                    }
                };
                const parseUnknownAppExt = (block) => {
                    block.appData = this.readSubBlocks();
                    // FIXME: This won't work if a handler wants to match on any identifier.
                    if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {
                        this.checkBytes.push(this._handler.app[block.identifier]);
                    }
                };
                this.checkBytes.push(this._st.readByte()); // Always 11
                block.identifier = this._st.read(8);
                block.authCode = this._st.read(3);
                switch (block.identifier) {
                    case 'NETSCAPE':
                        parseNetscapeExt(block);
                        break;
                    default:
                        parseUnknownAppExt(block);
                        break;
                }
            };
            const parseUnknownExt = (block) => {
                block.data = this.readSubBlocks();
                if (this._handler.unknown && this._handler.unknown(block)) {
                    this.checkBytes.push(this._handler.unknown);
                }
            };
            block.label = this._st.readByte();
            switch (block.label) {
                case 0xf9:
                    block.extType = 'gce';
                    parseGCExt(block);
                    break;
                case 0xfe:
                    block.extType = 'com';
                    parseComExt(block);
                    break;
                case 0x01:
                    block.extType = 'pte';
                    parsePTExt(block);
                    break;
                case 0xff:
                    block.extType = 'app';
                    parseAppExt(block);
                    break;
                default:
                    block.extType = 'unknown';
                    parseUnknownExt(block);
                    break;
            }
        };
        this.parseImg = (img) => {
            const deinterlace = (pixels, width) => {
                // Of course this defeats the purpose of interlacing. And it's *probably*
                // the least efficient way it's ever been implemented. But nevertheless...
                const newPixels = new Array(pixels.length);
                const rows = pixels.length / width;
                const cpRow = (toRow, fromRow) => {
                    const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
                    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
                };
                const offsets = [0, 4, 2, 1];
                const steps = [8, 8, 4, 2];
                let fromRow = 0;
                for (let pass = 0; pass < 4; pass++) {
                    for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                        cpRow(toRow, fromRow);
                        fromRow++;
                    }
                }
                return newPixels;
            };
            img.leftPos = this._st.readUnsigned();
            img.topPos = this._st.readUnsigned();
            img.width = this._st.readUnsigned();
            img.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            img.lctFlag = bits.shift();
            img.interlaced = bits.shift();
            img.sorted = bits.shift();
            img.reserved = bits.splice(0, 2);
            img.lctSize = bitsToNum(bits.splice(0, 3));
            if (img.lctFlag) {
                img.lct = this.parseColorTable(1 << (img.lctSize + 1));
            }
            img.lzwMinCodeSize = this._st.readByte();
            const lzwData = this.readSubBlocks();
            img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);
            if (img.interlaced) {
                // Move
                img.pixels = deinterlace(img.pixels, img.width);
            }
            this.frames.push(img);
            this.arrayToImage(img);
            if (this._handler.img && this._handler.img(img)) {
                this.checkBytes.push(this._handler);
            }
        };
        this.parseBlock = () => {
            const block = {
                sentinel: this._st.readByte(),
                type: ''
            };
            const blockChar = String.fromCharCode(block.sentinel);
            switch (blockChar) {
                case '!':
                    block.type = 'ext';
                    this.parseExt(block);
                    break;
                case ',':
                    block.type = 'img';
                    this.parseImg(block);
                    break;
                case ';':
                    block.type = 'eof';
                    if (this._handler.eof && this._handler.eof(block)) {
                        this.checkBytes.push(this._handler.eof);
                    }
                    break;
                default:
                    throw new Error('Unknown block: 0x' + block.sentinel.toString(16));
            }
            if (block.type !== 'eof') {
                this.parseBlock();
            }
        };
        this.arrayToImage = (frame) => {
            let count = 0;
            const c = document.createElement('canvas');
            c.id = count.toString();
            c.width = frame.width;
            c.height = frame.height;
            count++;
            const context = c.getContext('2d');
            const pixSize = 1;
            let y = 0;
            let x = 0;
            for (let i = 0; i < frame.pixels.length; i++) {
                if (x % frame.width === 0) {
                    y++;
                    x = 0;
                }
                if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {
                    context.fillStyle = `rgba(0, 0, 0, 0)`;
                }
                else {
                    context.fillStyle = this.globalColorTable[frame.pixels[i]];
                }
                context.fillRect(x, y, pixSize, pixSize);
                x++;
            }
            const img = new Image();
            img.src = c.toDataURL();
            this.images.push(img);
        };
        this._st = stream;
        this._handler = {};
        this._transparentColor = color;
        this.parseHeader();
        this.parseBlock();
    }
}


/***/ }),

/***/ "./Resources/Index.ts":
/*!****************************!*\
  !*** ./Resources/Index.ts ***!
  \****************************/
/*! exports provided: Resource, Sound, AudioContextFactory, WebAudioInstance, Texture, Gif, Stream, ParseGif */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Resource */ "./Resources/Resource.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Resource", function() { return _Resource__WEBPACK_IMPORTED_MODULE_0__["Resource"]; });

/* harmony import */ var _Sound_Index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sound/Index */ "./Resources/Sound/Index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sound", function() { return _Sound_Index__WEBPACK_IMPORTED_MODULE_1__["Sound"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AudioContextFactory", function() { return _Sound_Index__WEBPACK_IMPORTED_MODULE_1__["AudioContextFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebAudioInstance", function() { return _Sound_Index__WEBPACK_IMPORTED_MODULE_1__["WebAudioInstance"]; });

/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Texture */ "./Resources/Texture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return _Texture__WEBPACK_IMPORTED_MODULE_2__["Texture"]; });

/* harmony import */ var _Gif__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Gif */ "./Resources/Gif.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Gif", function() { return _Gif__WEBPACK_IMPORTED_MODULE_3__["Gif"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stream", function() { return _Gif__WEBPACK_IMPORTED_MODULE_3__["Stream"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParseGif", function() { return _Gif__WEBPACK_IMPORTED_MODULE_3__["ParseGif"]; });







/***/ }),

/***/ "./Resources/Resource.ts":
/*!*******************************!*\
  !*** ./Resources/Resource.ts ***!
  \*******************************/
/*! exports provided: Resource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Resource", function() { return Resource; });
/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Class */ "./Class.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util/Log */ "./Util/Log.ts");


/**
 * The [[Resource]] type allows games built in Excalibur to load generic resources.
 * For any type of remote resource it is recommended to use [[Resource]] for preloading.
 */
class Resource extends _Class__WEBPACK_IMPORTED_MODULE_0__["Class"] {
    /**
     * @param path          Path to the remote resource
     * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
     * @param bustCache     Whether or not to cache-bust requests
     */
    constructor(path, responseType, bustCache = true) {
        super();
        this.path = path;
        this.responseType = responseType;
        this.bustCache = bustCache;
        this.data = null;
        this.logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__["Logger"].getInstance();
        this.onprogress = () => {
            return;
        };
        this.oncomplete = () => {
            return;
        };
        this.onerror = () => {
            return;
        };
    }
    /**
     * Returns true if the Resource is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return this.data !== null;
    }
    wireEngine(_engine) {
        // override me
    }
    _cacheBust(uri) {
        const query = /\?\w*=\w*/;
        if (query.test(uri)) {
            uri += '&__=' + Date.now();
        }
        else {
            uri += '?__=' + Date.now();
        }
        return uri;
    }
    _start() {
        this.logger.debug('Started loading resource ' + this.path);
    }
    /**
     * Begin loading the resource and returns a promise to be resolved on completion
     */
    load() {
        return new Promise((resolve, reject) => {
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                resolve(this.data);
                this.oncomplete();
                return;
            }
            const request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.onloadstart = () => {
                this._start();
            };
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = () => {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);
                    this.onerror(request.response);
                    reject(request.response);
                    return;
                }
                this.data = this.processData(request.response);
                this.oncomplete();
                this.logger.debug('Completed loading resource', this.path);
                resolve(this.data);
            };
            request.send();
        });
    }
    /**
     * Returns the loaded data once the resource is loaded
     */
    getData() {
        return this.data;
    }
    /**
     * Sets the data for this resource directly
     */
    setData(data) {
        this.data = this.processData(data);
    }
    /**
     * This method is meant to be overridden to handle any additional
     * processing. Such as decoding downloaded audio bits.
     */
    processData(data) {
        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
        // Blob requires an object url
        if (this.responseType === 'blob') {
            return URL.createObjectURL(data);
        }
        return data;
    }
}


/***/ }),

/***/ "./Resources/Sound/AudioContext.ts":
/*!*****************************************!*\
  !*** ./Resources/Sound/AudioContext.ts ***!
  \*****************************************/
/*! exports provided: AudioContextFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContextFactory", function() { return AudioContextFactory; });
/**
 * Internal class used to build instances of AudioContext
 */
/* istanbul ignore next */
class AudioContextFactory {
    static create() {
        if (!this._INSTANCE) {
            if (window.AudioContext || window.webkitAudioContext) {
                this._INSTANCE = new window.AudioContext();
            }
        }
        return this._INSTANCE;
    }
}
AudioContextFactory._INSTANCE = null;


/***/ }),

/***/ "./Resources/Sound/Index.ts":
/*!**********************************!*\
  !*** ./Resources/Sound/Index.ts ***!
  \**********************************/
/*! exports provided: Sound, AudioContextFactory, WebAudioInstance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Sound__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sound */ "./Resources/Sound/Sound.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sound", function() { return _Sound__WEBPACK_IMPORTED_MODULE_0__["Sound"]; });

/* harmony import */ var _AudioContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AudioContext */ "./Resources/Sound/AudioContext.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AudioContextFactory", function() { return _AudioContext__WEBPACK_IMPORTED_MODULE_1__["AudioContextFactory"]; });

/* harmony import */ var _WebAudioInstance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebAudioInstance */ "./Resources/Sound/WebAudioInstance.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebAudioInstance", function() { return _WebAudioInstance__WEBPACK_IMPORTED_MODULE_2__["WebAudioInstance"]; });






/***/ }),

/***/ "./Resources/Sound/Sound.ts":
/*!**********************************!*\
  !*** ./Resources/Sound/Sound.ts ***!
  \**********************************/
/*! exports provided: Sound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sound", function() { return Sound; });
/* harmony import */ var _Interfaces_AudioImplementation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Interfaces/AudioImplementation */ "./Interfaces/AudioImplementation.ts");
/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Resource */ "./Resources/Resource.ts");
/* harmony import */ var _WebAudioInstance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebAudioInstance */ "./Resources/Sound/WebAudioInstance.ts");
/* harmony import */ var _AudioContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AudioContext */ "./Resources/Sound/AudioContext.ts");
/* harmony import */ var _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Events/MediaEvents */ "./Events/MediaEvents.ts");
/* harmony import */ var _Util_Sound__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Util/Sound */ "./Util/Sound.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






/**
 * The [[Sound]] object allows games built in Excalibur to load audio
 * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]
 * which means it can be passed to a [[Loader]] to pre-load before a game or level.
 */
class Sound extends _Resource__WEBPACK_IMPORTED_MODULE_1__["Resource"] {
    /**
     * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    constructor(...paths) {
        super('', '');
        this._loop = false;
        this._volume = 1;
        this._duration = undefined;
        this._isStopped = false;
        this._isPaused = false;
        this._tracks = [];
        this._wasPlayingOnHidden = false;
        this._processedData = new Promise((resolve) => {
            this._processedDataResolve = resolve;
        });
        this._audioContext = _AudioContext__WEBPACK_IMPORTED_MODULE_3__["AudioContextFactory"].create();
        this.responseType = _Interfaces_AudioImplementation__WEBPACK_IMPORTED_MODULE_0__["ExResponse"].type.arraybuffer;
        /* Chrome : MP3, WAV, Ogg
         * Firefox : WAV, Ogg,
         * IE : MP3, WAV coming soon
         * Safari MP3, WAV, Ogg
         */
        for (const path of paths) {
            if (Object(_Util_Sound__WEBPACK_IMPORTED_MODULE_5__["canPlayFile"])(path)) {
                this.path = path;
                break;
            }
        }
        if (!this.path) {
            this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
            this.logger.warn('Attempting to use', paths[0]);
            this.path = paths[0]; // select the first specified
        }
    }
    /**
     * Indicates whether the clip should loop when complete
     * @param value  Set the looping flag
     */
    set loop(value) {
        this._loop = value;
        for (const track of this._tracks) {
            track.loop = this._loop;
        }
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        this._volume = value;
        for (const track of this._tracks) {
            track.volume = this._volume;
        }
        this.emit('volumechange', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_4__["NativeSoundEvent"](this));
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);
    }
    get volume() {
        return this._volume;
    }
    get duration() {
        return this._duration;
    }
    /**
     * Return array of Current AudioInstances playing or being paused
     */
    get instances() {
        return this._tracks;
    }
    wireEngine(engine) {
        if (engine) {
            this._engine = engine;
            this._engine.on('hidden', () => {
                if (engine.pauseAudioWhenHidden && this.isPlaying()) {
                    this._wasPlayingOnHidden = true;
                    this.pause();
                }
            });
            this._engine.on('visible', () => {
                if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {
                    this.play();
                    this._wasPlayingOnHidden = false;
                }
            });
            this._engine.on('start', () => {
                this._isStopped = false;
            });
            this._engine.on('stop', () => {
                this.stop();
                this._isStopped = true;
            });
        }
    }
    /**
     * Returns how many instances of the sound are currently playing
     */
    instanceCount() {
        return this._tracks.length;
    }
    /**
     * Whether or not the sound is playing right now
     */
    isPlaying() {
        return this._tracks.some((t) => t.isPlaying());
    }
    /**
     * Play the sound, returns a promise that resolves when the sound is done playing
     * An optional volume argument can be passed in to play the sound. Max volume is 1.0
     */
    play(volume) {
        if (!this.isLoaded()) {
            this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');
            return Promise.resolve(true);
        }
        if (this._isStopped) {
            this.logger.warn('Cannot start playing. Engine is in a stopped state.');
            return Promise.resolve(false);
        }
        this.volume = volume || this.volume;
        if (this._isPaused) {
            return this._resumePlayback();
        }
        else {
            return this._startPlayback();
        }
    }
    /**
     * Stop the sound, and do not rewind
     */
    pause() {
        if (!this.isPlaying()) {
            return;
        }
        for (const track of this._tracks) {
            track.pause();
        }
        this._isPaused = true;
        this.emit('pause', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_4__["NativeSoundEvent"](this));
        this.logger.debug('Paused all instances of sound', this.path);
    }
    /**
     * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.
     */
    stop() {
        for (const track of this._tracks) {
            track.stop();
        }
        this.emit('stop', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_4__["NativeSoundEvent"](this));
        this._isPaused = false;
        this._tracks.length = 0;
        this.logger.debug('Stopped all instances of sound', this.path);
    }
    setData(data) {
        this.emit('emptied', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_4__["NativeSoundEvent"](this));
        this.data = data;
    }
    processData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            /**
             * Processes raw arraybuffer data and decodes into WebAudio buffer (async).
             */
            const audioBuffer = yield this._processArrayBufferData(data);
            this._setProcessedData(audioBuffer);
            return audioBuffer;
        });
    }
    /**
     * Get Id of provided AudioInstance in current trackList
     * @param track [[AudioInstance]] which Id is to be given
     */
    getTrackId(track) {
        return this._tracks.indexOf(track);
    }
    _resumePlayback() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isPaused) {
                const resumed = [];
                // ensure we resume *current* tracks (if paused)
                for (const track of this._tracks) {
                    resumed.push(track.play());
                }
                this._isPaused = false;
                this.emit('resume', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_4__["NativeSoundEvent"](this));
                this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);
                // resolve when resumed tracks are done
                yield Promise.all(resumed);
            }
            return true;
        });
    }
    /**
     * Starts playback, returns a promise that resolves when playback is complete
     */
    _startPlayback() {
        return __awaiter(this, void 0, void 0, function* () {
            const track = yield this._createNewTrack();
            const complete = yield track.play(() => {
                this.emit('playbackstart', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_4__["NativeSoundEvent"](this, track));
                this.logger.debug('Playing new instance for sound', this.path);
            });
            // when done, remove track
            this.emit('playbackend', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_4__["NativeSoundEvent"](this, track));
            this._tracks.splice(this.getTrackId(track), 1);
            return complete;
        });
    }
    _processArrayBufferData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this._audioContext.decodeAudioData(data.slice(0));
            }
            catch (e) {
                this.logger.error('Unable to decode ' +
                    ' this browser may not fully support this format, or the file may be corrupt, ' +
                    'if this is an mp3 try removing id3 tags and album art from the file.');
                return undefined;
            }
        });
    }
    _setProcessedData(processedData) {
        this._processedDataResolve(processedData);
        this._duration = typeof processedData === 'object' ? processedData.duration : undefined;
        this.emit('processed', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_4__["NativeSoundProcessedEvent"](this, processedData));
    }
    _createNewTrack() {
        this.processData(this.data);
        return new Promise((resolve) => {
            this._processedData.then((processedData) => {
                resolve(this._getTrackInstance(processedData));
                return processedData;
            }, (error) => {
                this.logger.error(error, 'Cannot create AudioInstance due to wrong processed data.');
            });
        });
    }
    _getTrackInstance(data) {
        const newTrack = new _WebAudioInstance__WEBPACK_IMPORTED_MODULE_2__["WebAudioInstance"](data);
        newTrack.loop = this.loop;
        newTrack.volume = this.volume;
        newTrack.duration = this.duration;
        this._tracks.push(newTrack);
        return newTrack;
    }
}


/***/ }),

/***/ "./Resources/Sound/WebAudioInstance.ts":
/*!*********************************************!*\
  !*** ./Resources/Sound/WebAudioInstance.ts ***!
  \*********************************************/
/*! exports provided: WebAudioInstance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebAudioInstance", function() { return WebAudioInstance; });
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Util/Util */ "./Util/Util.ts");
/* harmony import */ var _AudioContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AudioContext */ "./Resources/Sound/AudioContext.ts");


/**
 * Internal class representing a Web Audio AudioBufferSourceNode instance
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
 */
class WebAudioInstance {
    constructor(_src) {
        this._src = _src;
        this._volume = 1;
        this._duration = undefined;
        this._loop = false;
        this._isPlaying = false;
        this._isPaused = false;
        this._audioContext = _AudioContext__WEBPACK_IMPORTED_MODULE_1__["AudioContextFactory"].create();
        this._volumeNode = this._audioContext.createGain();
        /**
         * Current playback offset (in seconds)
         */
        this._currentOffset = 0;
        this._createNewBufferSource();
    }
    set loop(value) {
        this._loop = value;
        if (this._instance) {
            this._instance.loop = value;
            this._wireUpOnEnded();
        }
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        value = _Util_Util__WEBPACK_IMPORTED_MODULE_0__["clamp"](value, 0, 1.0);
        this._volume = value;
        if (this._isPlaying && this._volumeNode.gain.setTargetAtTime) {
            // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime
            // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.
            // This exponential ramp provides a more pleasant transition in gain
            this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);
        }
        else {
            this._volumeNode.gain.value = value;
        }
    }
    get volume() {
        return this._volume;
    }
    set duration(value) {
        this._duration = value;
    }
    /**
     * Duration of the sound, in seconds.
     */
    get duration() {
        return this._duration;
    }
    get _playbackRate() {
        return this._instance ? 1 / (this._instance.playbackRate.value || 1.0) : null;
    }
    isPlaying() {
        return this._isPlaying;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    play(playStarted = () => { }) {
        if (this._isPaused) {
            this._resumePlayBack();
            playStarted();
        }
        if (!this._isPlaying) {
            this._startPlayBack();
            playStarted();
        }
        return this._playingPromise;
    }
    pause() {
        if (!this._isPlaying) {
            return;
        }
        this._isPaused = true;
        this._isPlaying = false;
        this._instance.stop(0);
        // Playback rate will be a scale factor of how fast/slow the audio is being played
        // default is 1.0
        // we need to invert it to get the time scale
        this._setPauseOffset();
    }
    stop() {
        if (!this._isPlaying) {
            return;
        }
        this._isPlaying = false;
        this._isPaused = false;
        this._currentOffset = 0;
        this._instance.stop(0);
        // handler will not be wired up if we were looping
        if (!this._instance.onended) {
            this._handleOnEnded();
        }
    }
    _startPlayBack() {
        this._isPlaying = true;
        this._isPaused = false;
        this._playingPromise = new Promise((resolve) => {
            this._playingResolve = resolve;
        });
        if (!this._instance) {
            this._createNewBufferSource();
        }
        this._rememberStartTime();
        this._volumeNode.connect(this._audioContext.destination);
        this._instance.start(0, 0);
        this._currentOffset = 0;
        this._wireUpOnEnded();
    }
    _resumePlayBack() {
        if (!this._isPaused) {
            return;
        }
        this._isPaused = false;
        this._isPlaying = true;
        // a buffer source can only be started once
        // so we need to dispose of the previous instance before
        // "resuming" the next one
        this._instance.onended = null; // dispose of any previous event handler
        this._createNewBufferSource();
        const duration = this._playbackRate * this._src.duration;
        const restartTime = this._currentOffset % duration;
        this._rememberStartTime(restartTime * -1000);
        this._instance.start(0, restartTime);
        this._wireUpOnEnded();
    }
    _wireUpOnEnded() {
        if (!this.loop) {
            this._instance.onended = () => this._handleOnEnded();
        }
    }
    _handleOnEnded() {
        // pausing calls stop(0) which triggers onended event
        // so we don't "resolve" yet (when we resume we'll try again)
        if (!this._isPaused) {
            this._isPlaying = false;
            this._playingResolve(true);
        }
    }
    _rememberStartTime(amend) {
        this._startTime = new Date().getTime() + (amend | 0);
    }
    _setPauseOffset() {
        this._currentOffset = ((new Date().getTime() - this._startTime) * this._playbackRate) / 1000; // in seconds
    }
    _createNewBufferSource() {
        this._instance = this._audioContext.createBufferSource();
        this._instance.buffer = this._src;
        this._instance.loop = this.loop;
        this._instance.playbackRate.setValueAtTime(1.0, 0);
        this._instance.connect(this._volumeNode);
    }
}


/***/ }),

/***/ "./Resources/Texture.ts":
/*!******************************!*\
  !*** ./Resources/Texture.ts ***!
  \******************************/
/*! exports provided: Texture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Resource */ "./Resources/Resource.ts");
/* harmony import */ var _Drawing_Sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Drawing/Sprite */ "./Drawing/Sprite.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


/**
 * The [[Texture]] object allows games built in Excalibur to load image resources.
 * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]
 * to pre-load before starting a level or game.
 */
class Texture extends _Resource__WEBPACK_IMPORTED_MODULE_0__["Resource"] {
    /**
     * @param path       Path to the image resource or a base64 string representing an image "data:image/png;base64,iVB..."
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, bustCache = true) {
        super(path, 'blob', bustCache);
        this.path = path;
        this.bustCache = bustCache;
        this.loaded = new Promise((resolve) => {
            this._loadedResolve = resolve;
        });
        this._isLoaded = false;
        this._sprite = null;
        this._sprite = new _Drawing_Sprite__WEBPACK_IMPORTED_MODULE_1__["Sprite"](this, 0, 0, 0, 0);
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return this._isLoaded;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    load() {
        const _super = Object.create(null, {
            load: { get: () => super.load }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const complete = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                this.image = new Image();
                this.image.addEventListener('load', () => {
                    this._isLoaded = true;
                    this.width = this._sprite.width = this.image.naturalWidth;
                    this.height = this._sprite.height = this.image.naturalHeight;
                    this._sprite = new _Drawing_Sprite__WEBPACK_IMPORTED_MODULE_1__["Sprite"](this, 0, 0, this.width, this.height);
                    this._loadedResolve(this.image);
                    resolve(this.image);
                });
                if (this.path.indexOf('data:image/') > -1) {
                    this.image.src = this.path;
                    this.oncomplete();
                }
                else {
                    try {
                        this.image.src = yield _super.load.call(this);
                    }
                    catch (e) {
                        reject('Error loading texture');
                    }
                }
            }));
            return complete;
        });
    }
    asSprite() {
        return this._sprite;
    }
}


/***/ }),

/***/ "./Scene.ts":
/*!******************!*\
  !*** ./Scene.ts ***!
  \******************/
/*! exports provided: Scene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
/* harmony import */ var _ScreenElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScreenElement */ "./ScreenElement.ts");
/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Physics */ "./Physics.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Timer */ "./Timer.ts");
/* harmony import */ var _Collision_DynamicTreeCollisionBroadphase__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Collision/DynamicTreeCollisionBroadphase */ "./Collision/DynamicTreeCollisionBroadphase.ts");
/* harmony import */ var _TileMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TileMap */ "./TileMap.ts");
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Camera */ "./Camera.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Actor */ "./Actor.ts");
/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Class */ "./Class.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Util_Actors__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Util/Actors */ "./Util/Actors.ts");
/* harmony import */ var _Trigger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Trigger */ "./Trigger.ts");
/* harmony import */ var _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./EntityComponentSystem/System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _Drawing_CanvasDrawingSystem__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Drawing/CanvasDrawingSystem */ "./Drawing/CanvasDrawingSystem.ts");
/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Util/Decorators */ "./Util/Decorators.ts");
/* harmony import */ var _EntityComponentSystem_World__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./EntityComponentSystem/World */ "./EntityComponentSystem/World.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

















/**
 * [[Actor|Actors]] are composed together into groupings called Scenes in
 * Excalibur. The metaphor models the same idea behind real world
 * actors in a scene. Only actors in scenes will be updated and drawn.
 *
 * Typical usages of a scene include: levels, menus, loading screens, etc.
 */
class Scene extends _Class__WEBPACK_IMPORTED_MODULE_9__["Class"] {
    constructor(_engine) {
        super();
        /**
         * The actors in the current scene
         */
        this.actors = [];
        /**
         * The ECS world for the scene
         */
        this.world = new _EntityComponentSystem_World__WEBPACK_IMPORTED_MODULE_16__["World"](this);
        /**
         * Physics bodies in the current scene
         */
        this._bodies = [];
        /**
         * The triggers in the current scene
         */
        this.triggers = [];
        /**
         * The [[TileMap]]s in the scene, if any
         */
        this.tileMaps = [];
        this._isInitialized = false;
        this._broadphase = new _Collision_DynamicTreeCollisionBroadphase__WEBPACK_IMPORTED_MODULE_5__["DynamicTreeCollisionBroadphase"]();
        this._killQueue = [];
        this._triggerKillQueue = [];
        this._timers = [];
        this._cancelQueue = [];
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_3__["Logger"].getInstance();
        this.camera = new _Camera__WEBPACK_IMPORTED_MODULE_7__["Camera"]();
        if (_engine) {
            this.engine = _engine;
            this.camera.x = this.engine.halfDrawWidth;
            this.camera.y = this.engine.halfDrawHeight;
        }
    }
    /**
     * The [[ScreenElement]]s in a scene, if any; these are drawn last
     * @deprecated
     */
    get screenElements() {
        return this.actors.filter((a) => a instanceof _ScreenElement__WEBPACK_IMPORTED_MODULE_0__["ScreenElement"]);
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    /**
     * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     */
    onInitialize(_engine) {
        // will be overridden
    }
    /**
     * This is called when the scene is made active and started. It is meant to be overridden,
     * this is where you should setup any DOM UI or event handlers needed for the scene.
     */
    onActivate(_oldScene, _newScene) {
        // will be overridden
    }
    /**
     * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,
     * this is where you should cleanup any DOM UI or event handlers needed for the scene.
     */
    onDeactivate(_oldScene, _newScene) {
        // will be overridden
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before a scene is drawn.
     */
    onPreDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after a scene is drawn.
     */
    onPostDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Initializes actors in the scene
     */
    _initializeChildren() {
        for (const child of this.actors) {
            child._initialize(this.engine);
        }
    }
    /**
     * Gets whether or not the [[Scene]] has been initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Initializes the scene before the first update, meant to be called by engine not by users of
     * Excalibur
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.engine = engine;
            if (this.camera) {
                this.camera.x = engine.halfDrawWidth;
                this.camera.y = engine.halfDrawHeight;
            }
            // Initialize systems
            this.world.add(new _Drawing_CanvasDrawingSystem__WEBPACK_IMPORTED_MODULE_14__["CanvasDrawingSystem"]());
            // This order is important! we want to be sure any custom init that add actors
            // fire before the actor init
            this.onInitialize.call(this, engine);
            this._initializeChildren();
            this._logger.debug('Scene.onInitialize', this, engine);
            this.eventDispatcher.emit('initialize', new _Events__WEBPACK_IMPORTED_MODULE_2__["InitializeEvent"](engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.
     * @internal
     */
    _activate(oldScene, newScene) {
        this._logger.debug('Scene.onActivate', this);
        this.onActivate(oldScene, newScene);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.
     * @internal
     */
    _deactivate(oldScene, newScene) {
        this._logger.debug('Scene.onDeactivate', this);
        this.onDeactivate(oldScene, newScene);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(_engine, delta) {
        this.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_2__["PreUpdateEvent"](_engine, delta, this));
        this.onPreUpdate(_engine, delta);
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(_engine, delta) {
        this.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_2__["PostUpdateEvent"](_engine, delta, this));
        this.onPostUpdate(_engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     *
     * @internal
     */
    _predraw(_ctx, _delta) {
        this.emit('predraw', new _Events__WEBPACK_IMPORTED_MODULE_2__["PreDrawEvent"](_ctx, _delta, this));
        this.onPreDraw(_ctx, _delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     *
     * @internal
     */
    _postdraw(_ctx, _delta) {
        this.emit('postdraw', new _Events__WEBPACK_IMPORTED_MODULE_2__["PostDrawEvent"](_ctx, _delta, this));
        this.onPostDraw(_ctx, _delta);
    }
    /**
     * Updates all the actors and timers in the scene. Called by the [[Engine]].
     * @param engine  Reference to the current Engine
     * @param delta   The number of milliseconds since the last update
     */
    update(engine, delta) {
        this._preupdate(engine, delta);
        this.world.update(_EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_13__["SystemType"].Update, delta);
        if (this.camera) {
            this.camera.update(engine, delta);
        }
        let i, len;
        // Remove timers in the cancel queue before updating them
        for (i = 0, len = this._cancelQueue.length; i < len; i++) {
            this.removeTimer(this._cancelQueue[i]);
        }
        this._cancelQueue.length = 0;
        // Cycle through timers updating timers
        for (const timer of this._timers) {
            timer.update(delta);
        }
        // Cycle through actors updating tile maps
        for (i = 0, len = this.tileMaps.length; i < len; i++) {
            this.tileMaps[i].update(engine, delta);
        }
        // Cycle through actors updating actors
        for (i = 0, len = this.actors.length; i < len; i++) {
            this.actors[i].update(engine, delta);
            this._bodies[i] = this.actors[i].body;
        }
        // Cycle through triggers updating
        for (i = 0, len = this.triggers.length; i < len; i++) {
            this.triggers[i].update(engine, delta);
        }
        this._collectActorStats(engine);
        engine.input.pointers.dispatchPointerEvents();
        // Run the broadphase and narrowphase
        if (this._broadphase && _Physics__WEBPACK_IMPORTED_MODULE_1__["Physics"].enabled) {
            const beforeBroadphase = Date.now();
            this._broadphase.update(this._bodies, delta);
            let pairs = this._broadphase.broadphase(this._bodies, delta, engine.stats.currFrame);
            const afterBroadphase = Date.now();
            const beforeNarrowphase = Date.now();
            let iter = _Physics__WEBPACK_IMPORTED_MODULE_1__["Physics"].collisionPasses;
            const collisionDelta = delta / iter;
            while (iter > 0) {
                // Run the narrowphase
                pairs = this._broadphase.narrowphase(pairs, engine.stats.currFrame);
                // Run collision resolution strategy
                pairs = this._broadphase.resolve(pairs, collisionDelta, _Physics__WEBPACK_IMPORTED_MODULE_1__["Physics"].collisionResolutionStrategy);
                this._broadphase.runCollisionStartEnd(pairs);
                iter--;
            }
            const afterNarrowphase = Date.now();
            engine.stats.currFrame.physics.broadphase = afterBroadphase - beforeBroadphase;
            engine.stats.currFrame.physics.narrowphase = afterNarrowphase - beforeNarrowphase;
        }
        engine.stats.currFrame.actors.killed = this._killQueue.length + this._triggerKillQueue.length;
        this._processKillQueue(this._killQueue, this.actors);
        this._processKillQueue(this._triggerKillQueue, this.triggers);
        this._postupdate(engine, delta);
    }
    _processKillQueue(killQueue, collection) {
        // Remove actors from scene graph after being killed
        let actorIndex;
        for (const killed of killQueue) {
            //don't remove actors that were readded during the same frame they were killed
            if (killed.isKilled()) {
                actorIndex = collection.indexOf(killed);
                if (actorIndex > -1) {
                    collection.splice(actorIndex, 1);
                    this.world.remove(killed);
                    killed.children.forEach((c) => this.world.remove(c));
                }
            }
        }
        killQueue.length = 0;
    }
    /**
     * Draws all the actors in the Scene. Called by the [[Engine]].
     * @param ctx    The current rendering context
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        this._predraw(ctx, delta);
        this.world.update(_EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_13__["SystemType"].Draw, delta);
        this._postdraw(ctx, delta);
    }
    /**
     * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
     * @param ctx  The current rendering context
     */
    /* istanbul ignore next */
    debugDraw(ctx) {
        this.emit('predebugdraw', new _Events__WEBPACK_IMPORTED_MODULE_2__["PreDebugDrawEvent"](ctx, this));
        this._broadphase.debugDraw(ctx, 20);
        this.emit('postdebugdraw', new _Events__WEBPACK_IMPORTED_MODULE_2__["PostDebugDrawEvent"](ctx, this));
    }
    /**
     * Checks whether an actor is contained in this scene or not
     */
    contains(actor) {
        return this.actors.indexOf(actor) > -1;
    }
    add(entity) {
        if (entity instanceof _Actor__WEBPACK_IMPORTED_MODULE_8__["Actor"]) {
            entity.unkill();
        }
        if (entity instanceof _Actor__WEBPACK_IMPORTED_MODULE_8__["Actor"]) {
            if (!_Util_Util__WEBPACK_IMPORTED_MODULE_10__["contains"](this.actors, entity)) {
                this._broadphase.track(entity.body);
                entity.scene = this;
                if (entity instanceof _Trigger__WEBPACK_IMPORTED_MODULE_12__["Trigger"]) {
                    this.triggers.push(entity);
                }
                else {
                    this.actors.push(entity);
                }
                this.world.add(entity);
                entity.children.forEach((c) => this.world.add(c));
            }
            return;
        }
        if (entity instanceof _Timer__WEBPACK_IMPORTED_MODULE_4__["Timer"]) {
            if (!_Util_Util__WEBPACK_IMPORTED_MODULE_10__["contains"](this._timers, entity)) {
                this.addTimer(entity);
            }
            return;
        }
        if (entity instanceof _TileMap__WEBPACK_IMPORTED_MODULE_6__["TileMap"]) {
            if (!_Util_Util__WEBPACK_IMPORTED_MODULE_10__["contains"](this.tileMaps, entity)) {
                this.addTileMap(entity);
            }
        }
    }
    remove(entity) {
        if (entity instanceof _Actor__WEBPACK_IMPORTED_MODULE_8__["Actor"]) {
            if (!_Util_Util__WEBPACK_IMPORTED_MODULE_10__["contains"](this.actors, entity)) {
                return;
            }
            this._broadphase.untrack(entity.body);
            if (entity instanceof _Trigger__WEBPACK_IMPORTED_MODULE_12__["Trigger"]) {
                this._triggerKillQueue.push(entity);
            }
            else {
                if (!entity.isKilled()) {
                    entity.kill();
                }
                this._killQueue.push(entity);
            }
            entity.parent = null;
        }
        if (entity instanceof _Timer__WEBPACK_IMPORTED_MODULE_4__["Timer"]) {
            this.removeTimer(entity);
        }
        if (entity instanceof _TileMap__WEBPACK_IMPORTED_MODULE_6__["TileMap"]) {
            this.removeTileMap(entity);
        }
    }
    /**
     * Adds (any) actor to act as a piece of UI, meaning it is always positioned
     * in screen coordinates. UI actors do not participate in collisions.
     * @todo Should this be `ScreenElement` only?
     * @deprecated
     */
    addScreenElement(actor) {
        this.add(actor);
    }
    /**
     * Removes an actor as a piece of UI
     * @deprecated
     */
    removeScreenElement(actor) {
        this.remove(actor);
    }
    /**
     * Adds a [[TileMap]] to the scene, once this is done the TileMap will be drawn and updated.
     * @deprecated
     */
    addTileMap(tileMap) {
        this.tileMaps.push(tileMap);
        this.world.add(tileMap);
    }
    /**
     * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.
     * @deprecated
     */
    removeTileMap(tileMap) {
        const index = this.tileMaps.indexOf(tileMap);
        if (index > -1) {
            this.tileMaps.splice(index, 1);
            this.world.remove(tileMap);
        }
    }
    /**
     * Adds a [[Timer]] to the scene
     * @param timer  The timer to add
     */
    addTimer(timer) {
        this._timers.push(timer);
        timer.scene = this;
        return timer;
    }
    /**
     * Removes a [[Timer]] from the scene.
     * @warning Can be dangerous, use [[cancelTimer]] instead
     * @param timer  The timer to remove
     */
    removeTimer(timer) {
        const i = this._timers.indexOf(timer);
        if (i !== -1) {
            this._timers.splice(i, 1);
        }
        return timer;
    }
    /**
     * Cancels a [[Timer]], removing it from the scene nicely
     * @param timer  The timer to cancel
     */
    cancelTimer(timer) {
        this._cancelQueue.push(timer);
        return timer;
    }
    /**
     * Tests whether a [[Timer]] is active in the scene
     */
    isTimerActive(timer) {
        return this._timers.indexOf(timer) > -1 && !timer.complete;
    }
    isCurrentScene() {
        if (this.engine) {
            return this.engine.currentScene === this;
        }
        return false;
    }
    _collectActorStats(engine) {
        for (const _ui of this.screenElements) {
            engine.stats.currFrame.actors.ui++;
        }
        for (const actor of this.actors) {
            engine.stats.currFrame.actors.alive++;
            for (const child of actor.children) {
                if (_Util_Actors__WEBPACK_IMPORTED_MODULE_11__["isScreenElement"](child)) {
                    engine.stats.currFrame.actors.ui++;
                }
                else {
                    engine.stats.currFrame.actors.alive++;
                }
            }
        }
    }
}
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_15__["obsolete"])({
        message: 'Will be removed in excalibur v0.26.0',
        alternateMethod: 'ScreenElements now are normal actors with a Transform Coordinate Plane of Screen'
    })
], Scene.prototype, "screenElements", null);
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_15__["obsolete"])({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.add' })
], Scene.prototype, "addScreenElement", null);
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_15__["obsolete"])({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.remove' })
], Scene.prototype, "removeScreenElement", null);
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_15__["obsolete"])({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.add' })
], Scene.prototype, "addTileMap", null);
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_15__["obsolete"])({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.remove' })
], Scene.prototype, "removeTileMap", null);


/***/ }),

/***/ "./Screen.ts":
/*!*******************!*\
  !*** ./Screen.ts ***!
  \*******************/
/*! exports provided: DisplayMode, Resolution, Screen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayMode", function() { return DisplayMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Resolution", function() { return Resolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Screen", function() { return Screen; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Algebra */ "./Algebra.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Collision_Index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Collision/Index */ "./Collision/Index.ts");



/**
 * Enum representing the different display modes available to Excalibur.
 */
var DisplayMode;
(function (DisplayMode) {
    /**
     * Use the entire screen's css width/height for the game resolution dynamically. This is not the same as [[Screen.goFullScreen]]
     */
    DisplayMode["FullScreen"] = "FullScreen";
    /**
     * Use the parent DOM container's css width/height for the game resolution dynamically
     */
    DisplayMode["Container"] = "Container";
    /**
     * Default, use a specified resolution for the game
     */
    DisplayMode["Fixed"] = "Fixed";
    /**
     * Allow the game to be positioned with the [[EngineOptions.position]] option
     */
    DisplayMode["Position"] = "Position";
})(DisplayMode || (DisplayMode = {}));
/**
 * Convenience class for quick resolutions
 * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution
 */
class Resolution {
    /* istanbul ignore next */
    static get SVGA() {
        return { width: 800, height: 600 };
    }
    /* istanbul ignore next */
    static get Standard() {
        return { width: 1920, height: 1080 };
    }
    /* istanbul ignore next */
    static get Atari2600() {
        return { width: 160, height: 192 };
    }
    /* istanbul ignore next */
    static get GameBoy() {
        return { width: 160, height: 144 };
    }
    /* istanbul ignore next */
    static get GameBoyAdvance() {
        return { width: 240, height: 160 };
    }
    /* istanbul ignore next */
    static get NintendoDS() {
        return { width: 256, height: 192 };
    }
    /* istanbul ignore next */
    static get NES() {
        return { width: 256, height: 224 };
    }
    /* istanbul ignore next */
    static get SNES() {
        return { width: 256, height: 244 };
    }
}
/**
 * The Screen handles all aspects of interacting with the screen for Excalibur.
 */
class Screen {
    constructor(options) {
        var _a, _b, _c;
        this._antialiasing = true;
        this._resolutionStack = [];
        this._viewportStack = [];
        this._pixelRatio = null;
        this._isFullScreen = false;
        this._isDisposed = false;
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__["Logger"].getInstance();
        this._pixelRatioChangeHandler = () => {
            this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);
            this.applyResolutionAndViewport();
        };
        this._windowResizeHandler = () => {
            const parent = (this.displayMode === DisplayMode.Container ? (this.canvas.parentElement || document.body) : window);
            this._logger.debug('View port resized');
            this._setHeightByDisplayMode(parent);
            this._logger.info('parent.clientHeight ' + parent.clientHeight);
            this.applyResolutionAndViewport();
        };
        this.viewport = options.viewport;
        this.resolution = (_a = options.resolution) !== null && _a !== void 0 ? _a : Object.assign({}, this.viewport);
        this._displayMode = (_b = options.displayMode) !== null && _b !== void 0 ? _b : DisplayMode.Fixed;
        this._canvas = options.canvas;
        this._ctx = options.context;
        this._antialiasing = (_c = options.antialiasing) !== null && _c !== void 0 ? _c : this._antialiasing;
        this._browser = options.browser;
        this._position = options.position;
        this._pixelRatio = options.pixelRatio;
        this._applyDisplayMode();
        this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
        this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler);
    }
    dispose() {
        if (!this._isDisposed) {
            // Clean up handlers
            this._isDisposed = true;
            this._browser.window.off('resize', this._windowResizeHandler);
            this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);
        }
    }
    get pixelRatio() {
        if (this._pixelRatio) {
            return this._pixelRatio;
        }
        if (window.devicePixelRatio < 1) {
            return 1;
        }
        const devicePixelRatio = window.devicePixelRatio || 1;
        return devicePixelRatio;
    }
    get isHiDpi() {
        return this.pixelRatio !== 1;
    }
    get displayMode() {
        return this._displayMode;
    }
    get canvas() {
        return this._canvas;
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(resolution) {
        this._resolution = resolution;
    }
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return this._resolution;
    }
    set viewport(viewport) {
        this._viewport = viewport;
    }
    get scaledWidth() {
        return this._resolution.width * this.pixelRatio;
    }
    get scaledHeight() {
        return this._resolution.height * this.pixelRatio;
    }
    setCurrentCamera(camera) {
        this._camera = camera;
    }
    pushResolutionAndViewport() {
        this._resolutionStack.push(this.resolution);
        this._viewportStack.push(this.viewport);
        this.resolution = Object.assign({}, this.resolution);
        this.viewport = Object.assign({}, this.viewport);
    }
    popResolutionAndViewport() {
        this.resolution = this._resolutionStack.pop();
        this.viewport = this._viewportStack.pop();
    }
    applyResolutionAndViewport() {
        this._canvas.width = this.scaledWidth;
        this._canvas.height = this.scaledHeight;
        if (this._antialiasing) {
            this._canvas.style.imageRendering = 'auto';
        }
        else {
            this._canvas.style.imageRendering = 'pixelated';
            // Fall back to 'crisp-edges' if 'pixelated' is not supported
            // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering
            if (this._canvas.style.imageRendering === '') {
                this._canvas.style.imageRendering = 'crisp-edges';
            }
        }
        this._canvas.style.width = this.viewport.width + 'px';
        this._canvas.style.height = this.viewport.height + 'px';
        // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset
        this._ctx.resetTransform();
        this._ctx.scale(this.pixelRatio, this.pixelRatio);
        this._ctx.imageSmoothingEnabled = this._antialiasing;
    }
    get antialiasing() {
        return this._antialiasing;
    }
    set antialiasing(isSmooth) {
        this._antialiasing = isSmooth;
        this._ctx.imageSmoothingEnabled = this._antialiasing;
    }
    /**
     * Returns true if excalibur is fullscreened using the browser fullscreen api
     */
    get isFullScreen() {
        return this._isFullScreen;
    }
    /**
     * Requests to go fullscreen using the browser fullscreen api
     */
    goFullScreen() {
        return this._canvas.requestFullscreen().then(() => {
            this._isFullScreen = true;
        });
    }
    /**
     * Requests to exit fullscreen using the browser fullscreen api
     */
    exitFullScreen() {
        return document.exitFullscreen().then(() => {
            this._isFullScreen = false;
        });
    }
    /**
     * Transforms the current x, y from screen coordinates to world coordinates
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        var _a, _b, _c, _d;
        let newX = point.x;
        let newY = point.y;
        // transform back to world space
        newX = (newX / this.viewport.width) * this.drawWidth;
        newY = (newY / this.viewport.height) * this.drawHeight;
        // transform based on zoom
        newX = newX - this.halfDrawWidth;
        newY = newY - this.halfDrawHeight;
        // shift by focus
        newX += (_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
        newY += (_d = (_c = this._camera) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;
        return new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](Math.floor(newX), Math.floor(newY));
    }
    /**
     * Transforms a world coordinate, to a screen coordinate
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        var _a, _b, _c, _d;
        let screenX = point.x;
        let screenY = point.y;
        // shift by focus
        screenX -= (_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
        screenY -= (_d = (_c = this._camera) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;
        // transform back on zoom
        screenX = screenX + this.halfDrawWidth;
        screenY = screenY + this.halfDrawHeight;
        // transform back to screen space
        screenX = (screenX * this.viewport.width) / this.drawWidth;
        screenY = (screenY * this.viewport.height) / this.drawHeight;
        return new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](Math.floor(screenX), Math.floor(screenY));
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     */
    getWorldBounds() {
        const left = this.screenToWorldCoordinates(_Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Zero).x;
        const top = this.screenToWorldCoordinates(_Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Zero).y;
        const right = left + this.drawWidth;
        const bottom = top + this.drawHeight;
        return new _Collision_Index__WEBPACK_IMPORTED_MODULE_2__["BoundingBox"](left, top, right, bottom);
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.canvas.width;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.canvas.width / 2;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.canvas.height;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.canvas.height / 2;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        if (this._camera) {
            return this.scaledWidth / this._camera.z / this.pixelRatio;
        }
        return this.scaledWidth / this.pixelRatio;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.drawWidth / 2;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        if (this._camera) {
            return this.scaledHeight / this._camera.z / this.pixelRatio;
        }
        return this.scaledHeight / this.pixelRatio;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.drawHeight / 2;
    }
    _applyDisplayMode() {
        if (this.displayMode === DisplayMode.FullScreen || this.displayMode === DisplayMode.Container) {
            const parent = (this.displayMode === DisplayMode.Container ? (this.canvas.parentElement || document.body) : window);
            this._setHeightByDisplayMode(parent);
            this._browser.window.on('resize', this._windowResizeHandler);
        }
        else if (this.displayMode === DisplayMode.Position) {
            this._initializeDisplayModePosition(this._position);
        }
    }
    /**
     * Sets the internal canvas height based on the selected display mode.
     */
    _setHeightByDisplayMode(parent) {
        if (this.displayMode === DisplayMode.Container) {
            this.resolution = {
                width: parent.clientWidth,
                height: parent.clientHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FullScreen) {
            document.body.style.margin = '0px';
            document.body.style.overflow = 'hidden';
            this.resolution = {
                width: parent.innerWidth,
                height: parent.innerHeight
            };
            this.viewport = this.resolution;
        }
    }
    _initializeDisplayModePosition(position) {
        if (!position) {
            throw new Error('DisplayMode of Position was selected but no position option was given');
        }
        else {
            this.canvas.style.display = 'block';
            this.canvas.style.position = 'absolute';
            if (typeof position === 'string') {
                const specifiedPosition = position.split(' ');
                switch (specifiedPosition[0]) {
                    case 'top':
                        this.canvas.style.top = '0px';
                        break;
                    case 'bottom':
                        this.canvas.style.bottom = '0px';
                        break;
                    case 'middle':
                        this.canvas.style.top = '50%';
                        const offsetY = -this.halfDrawHeight;
                        this.canvas.style.marginTop = offsetY.toString();
                        break;
                    default:
                        throw new Error('Invalid Position Given');
                }
                if (specifiedPosition[1]) {
                    switch (specifiedPosition[1]) {
                        case 'left':
                            this.canvas.style.left = '0px';
                            break;
                        case 'right':
                            this.canvas.style.right = '0px';
                            break;
                        case 'center':
                            this.canvas.style.left = '50%';
                            const offsetX = -this.halfDrawWidth;
                            this.canvas.style.marginLeft = offsetX.toString();
                            break;
                        default:
                            throw new Error('Invalid Position Given');
                    }
                }
            }
            else {
                if (position.top) {
                    typeof position.top === 'number'
                        ? (this.canvas.style.top = position.top.toString() + 'px')
                        : (this.canvas.style.top = position.top);
                }
                if (position.right) {
                    typeof position.right === 'number'
                        ? (this.canvas.style.right = position.right.toString() + 'px')
                        : (this.canvas.style.right = position.right);
                }
                if (position.bottom) {
                    typeof position.bottom === 'number'
                        ? (this.canvas.style.bottom = position.bottom.toString() + 'px')
                        : (this.canvas.style.bottom = position.bottom);
                }
                if (position.left) {
                    typeof position.left === 'number'
                        ? (this.canvas.style.left = position.left.toString() + 'px')
                        : (this.canvas.style.left = position.left);
                }
            }
        }
    }
}


/***/ }),

/***/ "./ScreenElement.ts":
/*!**************************!*\
  !*** ./ScreenElement.ts ***!
  \**************************/
/*! exports provided: ScreenElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScreenElement", function() { return ScreenElement; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Algebra */ "./Algebra.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actor */ "./Actor.ts");
/* harmony import */ var _Traits_Index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Traits/Index */ "./Traits/Index.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Collision/CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Collision_Shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Collision/Shape */ "./Collision/Shape.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");






/**
 * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does
 * not participate in collisions. Drawn on top of all other actors.
 */
class ScreenElement extends _Actor__WEBPACK_IMPORTED_MODULE_1__["Actor"] {
    /**
     * @param xOrConfig  The starting x coordinate of the actor or the actor option bag
     * @param y       The starting y coordinate of the actor
     * @param width   The starting width of the actor
     * @param height  The starting height of the actor
     */
    constructor(xOrConfig, y, width, height) {
        if (typeof xOrConfig !== 'object') {
            super(xOrConfig, y, width, height);
        }
        else {
            super(xOrConfig);
        }
        this.components.transform.coordPlane = _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_5__["CoordPlane"].Screen;
        this.traits = [];
        this.traits.push(new _Traits_Index__WEBPACK_IMPORTED_MODULE_2__["CapturePointer"]());
        this.anchor.setTo(0, 0);
        this.body.collider.type = _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_3__["CollisionType"].PreventCollision;
        this.body.collider.shape = _Collision_Shape__WEBPACK_IMPORTED_MODULE_4__["Shape"].Box(this.width, this.height, this.anchor);
        this.enableCapturePointer = true;
    }
    _initialize(engine) {
        this._engine = engine;
        super._initialize(engine);
    }
    contains(x, y, useWorld = true) {
        if (useWorld) {
            return super.contains(x, y);
        }
        const coords = this._engine.worldToScreenCoordinates(new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](x, y));
        return super.contains(coords.x, coords.y);
    }
}


/***/ }),

/***/ "./TileMap.ts":
/*!********************!*\
  !*** ./TileMap.ts ***!
  \********************/
/*! exports provided: TileMapImpl, TileMap, TileSprite, CellImpl, Cell */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileMapImpl", function() { return TileMapImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileMap", function() { return TileMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileSprite", function() { return TileSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CellImpl", function() { return CellImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cell", function() { return Cell; });
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Collision/BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Algebra */ "./Algebra.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Configurable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Configurable */ "./Configurable.ts");
/* harmony import */ var _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EntityComponentSystem/Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _Drawing_CanvasDrawComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Drawing/CanvasDrawComponent */ "./Drawing/CanvasDrawComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");









/**
 * @hidden
 */
class TileMapImpl extends _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_6__["Entity"] {
    /**
     * @param xOrConfig     The x coordinate to anchor the TileMap's upper left corner (should not be changed once set) or TileMap option bag
     * @param y             The y coordinate to anchor the TileMap's upper left corner (should not be changed once set)
     * @param cellWidth     The individual width of each cell (in pixels) (should not be changed once set)
     * @param cellHeight    The individual height of each cell (in pixels) (should not be changed once set)
     * @param rows          The number of rows in the TileMap (should not be changed once set)
     * @param cols          The number of cols in the TileMap (should not be changed once set)
     */
    constructor(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
        super();
        this._collidingX = -1;
        this._collidingY = -1;
        this._onScreenXStart = 0;
        this._onScreenXEnd = 9999;
        this._onScreenYStart = 0;
        this._onScreenYEnd = 9999;
        this._spriteSheets = {};
        this.logger = _Util_Log__WEBPACK_IMPORTED_MODULE_3__["Logger"].getInstance();
        this.data = [];
        this.z = 0;
        this.visible = true;
        this.isOffscreen = false;
        this.rotation = 0;
        this.scale = _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"].One;
        if (xOrConfig && typeof xOrConfig === 'object') {
            const config = xOrConfig;
            xOrConfig = config.x;
            y = config.y;
            cellWidth = config.cellWidth;
            cellHeight = config.cellHeight;
            rows = config.rows;
            cols = config.cols;
        }
        this.x = xOrConfig;
        this.y = y;
        this.cellWidth = cellWidth;
        this.cellHeight = cellHeight;
        this.rows = rows;
        this.cols = cols;
        this.data = new Array(rows * cols);
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                (() => {
                    const cd = new Cell(i * cellWidth + xOrConfig, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                    this.data[i + j * cols] = cd;
                })();
            }
        }
        this.addComponent(new _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_8__["TransformComponent"]());
        this.addComponent(new _Drawing_CanvasDrawComponent__WEBPACK_IMPORTED_MODULE_7__["CanvasDrawComponent"]((ctx, delta) => this.draw(ctx, delta)));
    }
    get pos() {
        return Object(_Algebra__WEBPACK_IMPORTED_MODULE_2__["vec"])(this.x, this.y);
    }
    set pos(val) {
        this.x = val.x;
        this.y = val.y;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    registerSpriteSheet(key, spriteSheet) {
        this._spriteSheets[key] = spriteSheet;
    }
    /**
     * Returns the intersection vector that can be used to resolve collisions with actors. If there
     * is no collision null is returned.
     */
    collides(actor) {
        const width = actor.pos.x + actor.width;
        const height = actor.pos.y + actor.height;
        const actorBounds = actor.body.collider.bounds;
        const overlaps = [];
        if (actor.width <= 0 || actor.height <= 0) {
            return null;
        }
        // trace points for overlap
        for (let x = actorBounds.left; x <= width; x += Math.min(actor.width / 2, this.cellWidth / 2)) {
            for (let y = actorBounds.top; y <= height; y += Math.min(actor.height / 2, this.cellHeight / 2)) {
                const cell = this.getCellByPoint(x, y);
                if (cell && cell.solid) {
                    const overlap = actorBounds.intersect(cell.bounds);
                    const dir = actor.center.sub(cell.center);
                    if (overlap && overlap.dot(dir) > 0) {
                        overlaps.push(overlap);
                    }
                }
            }
        }
        if (overlaps.length === 0) {
            return null;
        }
        // Return the smallest change other than zero
        const result = overlaps.reduce((accum, next) => {
            let x = accum.x;
            let y = accum.y;
            if (Math.abs(accum.x) < Math.abs(next.x)) {
                x = next.x;
            }
            if (Math.abs(accum.y) < Math.abs(next.y)) {
                y = next.y;
            }
            return new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](x, y);
        });
        return result;
    }
    /**
     * Returns the [[Cell]] by index (row major order)
     */
    getCellByIndex(index) {
        return this.data[index];
    }
    /**
     * Returns the [[Cell]] by its x and y coordinates
     */
    getCell(x, y) {
        if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
            return null;
        }
        return this.data[x + y * this.cols];
    }
    /**
     * Returns the [[Cell]] by testing a point in global coordinates,
     * returns `null` if no cell was found.
     */
    getCellByPoint(x, y) {
        x = Math.floor((x - this.x) / this.cellWidth);
        y = Math.floor((y - this.y) / this.cellHeight);
        const cell = this.getCell(x, y);
        if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
            return cell;
        }
        return null;
    }
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    update(engine, delta) {
        this.onPreUpdate(engine, delta);
        this.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_4__["PreUpdateEvent"](engine, delta, this));
        const worldCoordsUpperLeft = engine.screenToWorldCoordinates(new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](0, 0));
        const worldCoordsLowerRight = engine.screenToWorldCoordinates(new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](engine.canvas.clientWidth, engine.canvas.clientHeight));
        this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - this.x) / this.cellWidth) - 2, 0);
        this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
        this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - this.x) / this.cellWidth) + 2, 0);
        this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
        this.onPostUpdate(engine, delta);
        this.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_4__["PostUpdateEvent"](engine, delta, this));
    }
    /**
     * Draws the tile map to the screen. Called by the [[Scene]].
     * @param ctx    The current rendering context
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        this.emit('predraw', new _Events__WEBPACK_IMPORTED_MODULE_4__["PreDrawEvent"](ctx, delta, this));
        let x = this._onScreenXStart;
        const xEnd = Math.min(this._onScreenXEnd, this.cols);
        let y = this._onScreenYStart;
        const yEnd = Math.min(this._onScreenYEnd, this.rows);
        let cs, csi, cslen;
        for (x; x < xEnd; x++) {
            for (y; y < yEnd; y++) {
                // get non-negative tile sprites
                cs = this.getCell(x, y).sprites.filter((s) => {
                    return s.spriteId > -1;
                });
                for (csi = 0, cslen = cs.length; csi < cslen; csi++) {
                    const ss = this._spriteSheets[cs[csi].spriteSheetKey];
                    // draw sprite, warning if sprite doesn't exist
                    if (ss) {
                        const sprite = ss.getSprite(cs[csi].spriteId);
                        if (sprite) {
                            sprite.draw(ctx, x * this.cellWidth, y * this.cellHeight);
                        }
                        else {
                            this.logger.warn('Sprite does not exist for id', cs[csi].spriteId, 'in sprite sheet', cs[csi].spriteSheetKey, sprite, ss);
                        }
                    }
                    else {
                        this.logger.warn('Sprite sheet', cs[csi].spriteSheetKey, 'does not exist', ss);
                    }
                }
            }
            y = this._onScreenYStart;
        }
        this.emit('postdraw', new _Events__WEBPACK_IMPORTED_MODULE_4__["PostDrawEvent"](ctx, delta, this));
    }
    /**
     * Draws all the tile map's debug info. Called by the [[Scene]].
     * @param ctx  The current rendering context
     */
    debugDraw(ctx) {
        const width = this.cols * this.cellWidth;
        const height = this.rows * this.cellHeight;
        ctx.save();
        ctx.strokeStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Red.toString();
        for (let x = 0; x < this.cols + 1; x++) {
            ctx.beginPath();
            ctx.moveTo(this.x + x * this.cellWidth, this.y);
            ctx.lineTo(this.x + x * this.cellWidth, this.y + height);
            ctx.stroke();
        }
        for (let y = 0; y < this.rows + 1; y++) {
            ctx.beginPath();
            ctx.moveTo(this.x, this.y + y * this.cellHeight);
            ctx.lineTo(this.x + width, this.y + y * this.cellHeight);
            ctx.stroke();
        }
        const solid = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Red;
        solid.a = 0.3;
        this.data
            .filter(function (cell) {
            return cell.solid;
        })
            .forEach(function (cell) {
            ctx.fillStyle = solid.toString();
            ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
        });
        if (this._collidingY > -1 && this._collidingX > -1) {
            ctx.fillStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Cyan.toString();
            ctx.fillRect(this.x + this._collidingX * this.cellWidth, this.y + this._collidingY * this.cellHeight, this.cellWidth, this.cellHeight);
        }
        ctx.restore();
    }
}
/**
 * The [[TileMap]] class provides a lightweight way to do large complex scenes with collision
 * without the overhead of actors.
 */
class TileMap extends Object(_Configurable__WEBPACK_IMPORTED_MODULE_5__["Configurable"])(TileMapImpl) {
    constructor(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
        super(xOrConfig, y, cellWidth, cellHeight, rows, cols);
    }
}
/**
 * Tile sprites are used to render a specific sprite from a [[TileMap]]'s spritesheet(s)
 */
class TileSprite {
    /**
     * @param spriteSheetKey  The key of the spritesheet to use
     * @param spriteId        The index of the sprite in the [[SpriteSheet]]
     */
    constructor(spriteSheetKey, spriteId) {
        this.spriteSheetKey = spriteSheetKey;
        this.spriteId = spriteId;
    }
}
/**
 * @hidden
 */
class CellImpl {
    /**
     * @param xOrConfig Gets or sets x coordinate of the cell in world coordinates or cell option bag
     * @param y       Gets or sets y coordinate of the cell in world coordinates
     * @param width   Gets or sets the width of the cell
     * @param height  Gets or sets the height of the cell
     * @param index   The index of the cell in row major order
     * @param solid   Gets or sets whether this cell is solid
     * @param sprites The list of tile sprites to use to draw in this cell (in order)
     */
    constructor(xOrConfig, y, width, height, index, solid = false, sprites = []) {
        this.solid = false;
        this.sprites = [];
        if (xOrConfig && typeof xOrConfig === 'object') {
            const config = xOrConfig;
            xOrConfig = config.x;
            y = config.y;
            width = config.width;
            height = config.height;
            index = config.index;
            solid = config.solid;
            sprites = config.sprites;
        }
        this.x = xOrConfig;
        this.y = y;
        this.width = width;
        this.height = height;
        this.index = index;
        this.solid = solid;
        this.sprites = sprites;
        this._bounds = new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_0__["BoundingBox"](this.x, this.y, this.x + this.width, this.y + this.height);
    }
    get bounds() {
        return this._bounds;
    }
    get center() {
        return new _Algebra__WEBPACK_IMPORTED_MODULE_2__["Vector"](this.x + this.width / 2, this.y + this.height / 2);
    }
    /**
     * Add another [[TileSprite]] to this cell
     */
    pushSprite(tileSprite) {
        this.sprites.push(tileSprite);
    }
    /**
     * Remove an instance of [[TileSprite]] from this cell
     */
    removeSprite(tileSprite) {
        let index = -1;
        if ((index = this.sprites.indexOf(tileSprite)) > -1) {
            this.sprites.splice(index, 1);
        }
    }
    /**
     * Clear all sprites from this cell
     */
    clearSprites() {
        this.sprites.length = 0;
    }
}
/**
 * TileMap Cell
 *
 * A light-weight object that occupies a space in a collision map. Generally
 * created by a [[TileMap]].
 *
 * Cells can draw multiple sprites. Note that the order of drawing is the order
 * of the sprites in the array so the last one will be drawn on top. You can
 * use transparency to create layers this way.
 */
class Cell extends Object(_Configurable__WEBPACK_IMPORTED_MODULE_5__["Configurable"])(CellImpl) {
    constructor(xOrConfig, y, width, height, index, solid, sprites) {
        super(xOrConfig, y, width, height, index, solid, sprites);
    }
}


/***/ }),

/***/ "./Timer.ts":
/*!******************!*\
  !*** ./Timer.ts ***!
  \******************/
/*! exports provided: Timer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/**
 * The Excalibur timer hooks into the internal timer and fires callbacks,
 * after a certain interval, optionally repeating.
 */
class Timer {
    constructor(fcn, interval, repeats, numberOfRepeats) {
        this.id = 0;
        this.interval = 10;
        this.repeats = false;
        this.maxNumberOfRepeats = -1;
        this._elapsedTime = 0;
        this._totalTimeAlive = 0;
        this._paused = false;
        this._numberOfTicks = 0;
        this.complete = false;
        this.scene = null;
        if (typeof fcn !== 'function') {
            const options = fcn;
            fcn = options.fcn;
            interval = options.interval;
            repeats = options.repeats;
            numberOfRepeats = options.numberOfRepeats;
        }
        if (!!numberOfRepeats && numberOfRepeats >= 0) {
            this.maxNumberOfRepeats = numberOfRepeats;
            if (!repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this.id = Timer.id++;
        this.interval = interval || this.interval;
        this.repeats = repeats || this.repeats;
        this._callbacks = [];
        if (fcn) {
            this.on(fcn);
        }
    }
    /**
     * Adds a new callback to be fired after the interval is complete
     * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.
     */
    on(fcn) {
        this._callbacks.push(fcn);
    }
    /**
     * Removes a callback from the callback list to be fired after the interval is complete.
     * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.
     */
    off(fcn) {
        const index = this._callbacks.indexOf(fcn);
        this._callbacks.splice(index, 1);
    }
    /**
     * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
     * @param delta  Number of elapsed milliseconds since the last update.
     */
    update(delta) {
        if (!this._paused) {
            this._totalTimeAlive += delta;
            this._elapsedTime += delta;
            if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {
                this.complete = true;
            }
            if (!this.complete && this._elapsedTime >= this.interval) {
                this._callbacks.forEach((c) => {
                    c.call(this);
                });
                this._numberOfTicks++;
                if (this.repeats) {
                    this._elapsedTime = 0;
                }
                else {
                    this.complete = true;
                }
            }
        }
    }
    /**
     * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
     * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
     * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes
     */
    reset(newInterval, newNumberOfRepeats) {
        if (!!newInterval && newInterval >= 0) {
            this.interval = newInterval;
        }
        if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {
            this.maxNumberOfRepeats = newNumberOfRepeats;
            if (!this.repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this.complete = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
    }
    get timesRepeated() {
        return this._numberOfTicks;
    }
    getTimeRunning() {
        return this._totalTimeAlive;
    }
    /**
     * Pauses the timer so that no more time will be incremented towards the next call
     */
    pause() {
        this._paused = true;
    }
    /**
     * Unpauses the timer. Time will now increment towards the next call
     */
    unpause() {
        this._paused = false;
    }
    /**
     * Cancels the timer, preventing any further executions.
     */
    cancel() {
        if (this.scene) {
            this.scene.cancelTimer(this);
        }
    }
}
Timer.id = 0;


/***/ }),

/***/ "./Traits/CapturePointer.ts":
/*!**********************************!*\
  !*** ./Traits/CapturePointer.ts ***!
  \**********************************/
/*! exports provided: CapturePointer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CapturePointer", function() { return CapturePointer; });
/**
 * Revises pointer events path accordingly to the actor
 */
class CapturePointer {
    update(actor, engine) {
        if (!actor.enableCapturePointer) {
            return;
        }
        if (actor.isKilled()) {
            return;
        }
        engine.input.pointers.checkAndUpdateActorUnderPointer(actor);
    }
}


/***/ }),

/***/ "./Traits/Index.ts":
/*!*************************!*\
  !*** ./Traits/Index.ts ***!
  \*************************/
/*! exports provided: CapturePointer, OffscreenCulling, TileMapCollisionDetection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CapturePointer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CapturePointer */ "./Traits/CapturePointer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CapturePointer", function() { return _CapturePointer__WEBPACK_IMPORTED_MODULE_0__["CapturePointer"]; });

/* harmony import */ var _OffscreenCulling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OffscreenCulling */ "./Traits/OffscreenCulling.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OffscreenCulling", function() { return _OffscreenCulling__WEBPACK_IMPORTED_MODULE_1__["OffscreenCulling"]; });

/* harmony import */ var _TileMapCollisionDetection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileMapCollisionDetection */ "./Traits/TileMapCollisionDetection.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TileMapCollisionDetection", function() { return _TileMapCollisionDetection__WEBPACK_IMPORTED_MODULE_2__["TileMapCollisionDetection"]; });






/***/ }),

/***/ "./Traits/OffscreenCulling.ts":
/*!************************************!*\
  !*** ./Traits/OffscreenCulling.ts ***!
  \************************************/
/*! exports provided: OffscreenCulling */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OffscreenCulling", function() { return OffscreenCulling; });
/* harmony import */ var _Util_CullingBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../Util/CullingBox */ "./Util/CullingBox.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Events */ "./Events.ts");


class OffscreenCulling {
    constructor() {
        this.cullingBox = new _Util_CullingBox__WEBPACK_IMPORTED_MODULE_0__["CullingBox"]();
    }
    update(actor, engine) {
        const events = actor.eventDispatcher;
        let isSpriteOffScreen = true;
        if (actor.currentDrawing != null) {
            isSpriteOffScreen = this.cullingBox.isSpriteOffScreen(actor, engine);
        }
        let actorBoundsOffscreen = false;
        if (engine && engine.currentScene && engine.currentScene.camera && engine.currentScene.camera.viewport && !actor.parent) {
            actorBoundsOffscreen = !engine.currentScene.camera.viewport.intersect(actor.body.collider.bounds);
        }
        if (!actor.isOffScreen) {
            if (actorBoundsOffscreen && isSpriteOffScreen) {
                events.emit('exitviewport', new _Events__WEBPACK_IMPORTED_MODULE_1__["ExitViewPortEvent"](actor));
                actor.isOffScreen = true;
            }
        }
        else {
            if (!actorBoundsOffscreen || !isSpriteOffScreen) {
                events.emit('enterviewport', new _Events__WEBPACK_IMPORTED_MODULE_1__["EnterViewPortEvent"](actor));
                actor.isOffScreen = false;
            }
        }
    }
}


/***/ }),

/***/ "./Traits/TileMapCollisionDetection.ts":
/*!*********************************************!*\
  !*** ./Traits/TileMapCollisionDetection.ts ***!
  \*********************************************/
/*! exports provided: TileMapCollisionDetection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileMapCollisionDetection", function() { return TileMapCollisionDetection; });
/* harmony import */ var _Collision_Side__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collision/Side */ "./Collision/Side.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Collision/CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Collision_Index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Collision/Index */ "./Collision/Index.ts");




class TileMapCollisionDetection {
    update(actor, engine) {
        const eventDispatcher = actor.eventDispatcher;
        if (actor.body.collider.type !== _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_2__["CollisionType"].PreventCollision && engine.currentScene && engine.currentScene.tileMaps) {
            for (let j = 0; j < engine.currentScene.tileMaps.length; j++) {
                const map = engine.currentScene.tileMaps[j];
                let intersectMap;
                let side = _Collision_Side__WEBPACK_IMPORTED_MODULE_0__["Side"].None;
                let max = 2;
                while ((intersectMap = map.collides(actor))) {
                    if (max-- < 0) {
                        break;
                    }
                    side = _Collision_Index__WEBPACK_IMPORTED_MODULE_3__["BoundingBox"].getSideFromIntersection(intersectMap);
                    eventDispatcher.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_1__["PreCollisionEvent"](actor, null, side, intersectMap));
                    if (actor.body.collider.type === _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_2__["CollisionType"].Active) {
                        actor.pos.y += intersectMap.y;
                        actor.pos.x += intersectMap.x;
                        eventDispatcher.emit('postcollision', new _Events__WEBPACK_IMPORTED_MODULE_1__["PostCollisionEvent"](actor, null, side, intersectMap));
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./Trigger.ts":
/*!********************!*\
  !*** ./Trigger.ts ***!
  \********************/
/*! exports provided: Trigger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Trigger", function() { return Trigger; });
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Drawing/Color */ "./Drawing/Color.ts");
/* harmony import */ var _Actions_Action__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actions/Action */ "./Actions/Action.ts");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventDispatcher */ "./EventDispatcher.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Actor */ "./Actor.ts");
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Algebra */ "./Algebra.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Collision/CollisionType */ "./Collision/CollisionType.ts");








const triggerDefaults = {
    pos: _Algebra__WEBPACK_IMPORTED_MODULE_4__["Vector"].Zero,
    width: 10,
    height: 10,
    visible: false,
    action: () => {
        return;
    },
    filter: () => true,
    repeat: -1
};
/**
 * Triggers are a method of firing arbitrary code on collision. These are useful
 * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
 * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
 */
class Trigger extends _Actor__WEBPACK_IMPORTED_MODULE_3__["Actor"] {
    /**
     *
     * @param opts Trigger options
     */
    constructor(opts) {
        super(opts.pos.x, opts.pos.y, opts.width, opts.height);
        /**
         * Action to fire when triggered by collision
         */
        this.action = () => {
            return;
        };
        /**
         * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
         * filter return true for the collided actor.
         */
        this.filter = () => true;
        /**
         * Number of times to repeat before killing the trigger,
         */
        this.repeat = -1;
        opts = _Util_Util__WEBPACK_IMPORTED_MODULE_6__["extend"]({}, triggerDefaults, opts);
        this.filter = opts.filter || this.filter;
        this.repeat = opts.repeat || this.repeat;
        this.action = opts.action || this.action;
        if (opts.target) {
            this.target = opts.target;
        }
        this.visible = opts.visible;
        this.body.collider.type = _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_7__["CollisionType"].Passive;
        this.eventDispatcher = new _EventDispatcher__WEBPACK_IMPORTED_MODULE_2__["EventDispatcher"](this);
        this.actionQueue = new _Actions_Action__WEBPACK_IMPORTED_MODULE_1__["ActionQueue"](this);
        this.on('collisionstart', (evt) => {
            if (Object(_Actor__WEBPACK_IMPORTED_MODULE_3__["isActor"])(evt.other) && this.filter(evt.other)) {
                this.emit('enter', new _Events__WEBPACK_IMPORTED_MODULE_5__["EnterTriggerEvent"](this, evt.other));
                this._dispatchAction();
                // remove trigger if its done, -1 repeat forever
                if (this.repeat === 0) {
                    this.kill();
                }
            }
        });
        this.on('collisionend', (evt) => {
            if (Object(_Actor__WEBPACK_IMPORTED_MODULE_3__["isActor"])(evt.other) && this.filter(evt.other)) {
                this.emit('exit', new _Events__WEBPACK_IMPORTED_MODULE_5__["ExitTriggerEvent"](this, evt.other));
            }
        });
    }
    set target(target) {
        this._target = target;
        this.filter = (actor) => actor === target;
    }
    get target() {
        return this._target;
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    _dispatchAction() {
        this.action.call(this);
        this.repeat--;
    }
    /* istanbul ignore next */
    debugDraw(ctx) {
        super.debugDraw(ctx);
        // Meant to draw debug information about actors
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        const bb = this.body.collider.bounds;
        const wp = this.getWorldPos();
        bb.left = bb.left - wp.x;
        bb.right = bb.right - wp.x;
        bb.top = bb.top - wp.y;
        bb.bottom = bb.bottom - wp.y;
        // Currently collision primitives cannot rotate
        // ctx.rotate(this.rotation);
        ctx.fillStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Violet.toString();
        ctx.strokeStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Violet.toString();
        ctx.fillText('Trigger', 10, 10);
        bb.debugDraw(ctx);
        ctx.restore();
    }
}


/***/ }),

/***/ "./Util/Actors.ts":
/*!************************!*\
  !*** ./Util/Actors.ts ***!
  \************************/
/*! exports provided: isVanillaActor, isScreenElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVanillaActor", function() { return isVanillaActor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isScreenElement", function() { return isScreenElement; });
/* harmony import */ var _ScreenElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ScreenElement */ "./ScreenElement.ts");
/* harmony import */ var _Label__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Label */ "./Label.ts");
/* harmony import */ var _Trigger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Trigger */ "./Trigger.ts");



/**
 * Type guard to detect if something is an actor
 * @deprecated
 * @param actor
 */
function isVanillaActor(actor) {
    return !(actor instanceof _ScreenElement__WEBPACK_IMPORTED_MODULE_0__["ScreenElement"]) && !(actor instanceof _Trigger__WEBPACK_IMPORTED_MODULE_2__["Trigger"]) && !(actor instanceof _Label__WEBPACK_IMPORTED_MODULE_1__["Label"]);
}
/**
 * Type guard to detect a screen element
 * TODO: Move to screen element
 */
function isScreenElement(actor) {
    return actor instanceof _ScreenElement__WEBPACK_IMPORTED_MODULE_0__["ScreenElement"];
}


/***/ }),

/***/ "./Util/Browser.ts":
/*!*************************!*\
  !*** ./Util/Browser.ts ***!
  \*************************/
/*! exports provided: BrowserComponent, BrowserEvents */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserComponent", function() { return BrowserComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserEvents", function() { return BrowserEvents; });
class BrowserComponent {
    constructor(nativeComponent) {
        this.nativeComponent = nativeComponent;
        this._paused = false;
        this._nativeHandlers = {};
    }
    on(eventName, handler) {
        if (this._nativeHandlers[eventName]) {
            this.off(eventName, this._nativeHandlers[eventName]);
        }
        this._nativeHandlers[eventName] = this._decorate(handler);
        this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);
    }
    off(eventName, handler) {
        if (!handler) {
            handler = this._nativeHandlers[eventName];
        }
        this.nativeComponent.removeEventListener(eventName, handler);
        this._nativeHandlers[eventName] = null;
    }
    _decorate(handler) {
        return (evt) => {
            if (!this._paused) {
                handler(evt);
            }
        };
    }
    pause() {
        this._paused = true;
    }
    resume() {
        this._paused = false;
    }
    clear() {
        for (const event in this._nativeHandlers) {
            this.off(event);
        }
    }
}
class BrowserEvents {
    constructor(_windowGlobal, _documentGlobal) {
        this._windowGlobal = _windowGlobal;
        this._documentGlobal = _documentGlobal;
        this._windowComponent = new BrowserComponent(this._windowGlobal);
        this._documentComponent = new BrowserComponent(this._documentGlobal);
    }
    get window() {
        return this._windowComponent;
    }
    get document() {
        return this._documentComponent;
    }
    pause() {
        this.window.pause();
        this.document.pause();
    }
    resume() {
        this.window.resume();
        this.document.resume();
    }
    clear() {
        this.window.clear();
        this.document.clear();
    }
}


/***/ }),

/***/ "./Util/CullingBox.ts":
/*!****************************!*\
  !*** ./Util/CullingBox.ts ***!
  \****************************/
/*! exports provided: CullingBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullingBox", function() { return CullingBox; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Drawing/Color */ "./Drawing/Color.ts");


class CullingBox {
    constructor() {
        this._topLeft = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0);
        this._topRight = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0);
        this._bottomLeft = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0);
        this._bottomRight = new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0);
    }
    isSpriteOffScreen(actor, engine) {
        const drawingWidth = actor.currentDrawing.drawWidth;
        const drawingHeight = actor.currentDrawing.drawHeight;
        const rotation = actor.rotation;
        const anchor = actor.center;
        const worldPos = actor.getWorldPos();
        this._topLeft.x = worldPos.x - drawingWidth / 2;
        this._topLeft.y = worldPos.y - drawingHeight / 2;
        this._topLeft = this._topLeft.rotate(rotation, anchor);
        this._topRight.x = worldPos.x + drawingWidth / 2;
        this._topRight.y = worldPos.y - drawingHeight / 2;
        this._topRight = this._topRight.rotate(rotation, anchor);
        this._bottomLeft.x = worldPos.x - drawingWidth / 2;
        this._bottomLeft.y = worldPos.y + drawingHeight / 2;
        this._bottomLeft = this._bottomLeft.rotate(rotation, anchor);
        this._bottomRight.x = worldPos.x + drawingWidth / 2;
        this._bottomRight.y = worldPos.y + drawingHeight / 2;
        this._bottomRight = this._bottomRight.rotate(rotation, anchor);
        ///
        const topLeftScreen = engine.worldToScreenCoordinates(this._topLeft);
        const topRightScreen = engine.worldToScreenCoordinates(this._topRight);
        const bottomLeftScreen = engine.worldToScreenCoordinates(this._bottomLeft);
        const bottomRightScreen = engine.worldToScreenCoordinates(this._bottomRight);
        this._xCoords = [];
        this._yCoords = [];
        this._xCoords.push(topLeftScreen.x, topRightScreen.x, bottomLeftScreen.x, bottomRightScreen.x);
        this._yCoords.push(topLeftScreen.y, topRightScreen.y, bottomLeftScreen.y, bottomRightScreen.y);
        this._xMin = Math.min.apply(null, this._xCoords);
        this._yMin = Math.min.apply(null, this._yCoords);
        this._xMax = Math.max.apply(null, this._xCoords);
        this._yMax = Math.max.apply(null, this._yCoords);
        const minWorld = engine.screenToWorldCoordinates(new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](this._xMin, this._yMin));
        const maxWorld = engine.screenToWorldCoordinates(new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](this._xMax, this._yMax));
        this._xMinWorld = minWorld.x;
        this._yMinWorld = minWorld.y;
        this._xMaxWorld = maxWorld.x;
        this._yMaxWorld = maxWorld.y;
        const boundingPoints = [
            new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](this._xMin, this._yMin),
            new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](this._xMax, this._yMin),
            new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](this._xMin, this._yMax),
            new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](this._xMax, this._yMax) // bottom right
        ];
        // sprite can be wider than canvas screen (and still visible within canvas)
        // top or bottom of sprite must be within canvas
        if (boundingPoints[0].x < 0 &&
            boundingPoints[1].x > engine.canvas.clientWidth &&
            (boundingPoints[0].y > 0 || boundingPoints[2].y < engine.canvas.clientHeight)) {
            return false;
        }
        // sprite can be taller than canvas screen (and still visible within canvas)
        // left or right of sprite must be within canvas
        if (boundingPoints[0].y < 0 &&
            boundingPoints[2].y > engine.canvas.clientHeight &&
            (boundingPoints[1].x > 0 || boundingPoints[0].x < engine.canvas.clientWidth)) {
            return false;
        }
        // otherwise if any corner is visible, we're not offscreen
        for (let i = 0; i < boundingPoints.length; i++) {
            if (boundingPoints[i].x > 0 &&
                boundingPoints[i].y > 0 &&
                boundingPoints[i].x < engine.canvas.clientWidth &&
                boundingPoints[i].y < engine.canvas.clientHeight) {
                return false;
            }
        }
        return true;
    }
    debugDraw(ctx) {
        // bounding rectangle
        ctx.beginPath();
        ctx.strokeStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].White.toString();
        ctx.rect(this._xMinWorld, this._yMinWorld, this._xMaxWorld - this._xMinWorld, this._yMaxWorld - this._yMinWorld);
        ctx.stroke();
        ctx.fillStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Red.toString();
        ctx.beginPath();
        ctx.arc(this._topLeft.x, this._topLeft.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Green.toString();
        ctx.beginPath();
        ctx.arc(this._topRight.x, this._topRight.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Blue.toString();
        ctx.beginPath();
        ctx.arc(this._bottomLeft.x, this._bottomLeft.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = _Drawing_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].Magenta.toString();
        ctx.beginPath();
        ctx.arc(this._bottomRight.x, this._bottomRight.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
    }
}


/***/ }),

/***/ "./Util/Decorators.ts":
/*!****************************!*\
  !*** ./Util/Decorators.ts ***!
  \****************************/
/*! exports provided: maxMessages, resetObsoleteCounter, obsolete */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxMessages", function() { return maxMessages; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetObsoleteCounter", function() { return resetObsoleteCounter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "obsolete", function() { return obsolete; });
/* harmony import */ var _Flags__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Flags */ "./Flags.ts");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Log */ "./Util/Log.ts");
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Util */ "./Util/Util.ts");



const maxMessages = 5;
const obsoleteMessage = {};
const resetObsoleteCounter = () => {
    for (const message in obsoleteMessage) {
        obsoleteMessage[message] = 0;
    }
};
const logMessage = (message, options) => {
    const suppressObsoleteMessages = _Flags__WEBPACK_IMPORTED_MODULE_0__["Flags"].isEnabled('suppress-obsolete-message');
    if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {
        _Log__WEBPACK_IMPORTED_MODULE_1__["Logger"].getInstance().warn(message);
        // tslint:disable-next-line: no-console
        if (console.trace && options.showStackTrace) {
            // tslint:disable-next-line: no-console
            console.trace();
        }
    }
    obsoleteMessage[message]++;
};
/**
 * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
 * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
 */
function obsolete(options) {
    options = Object(_Util__WEBPACK_IMPORTED_MODULE_2__["extend"])({}, {
        message: 'This feature will be removed in future versions of Excalibur.',
        alternateMethod: null,
        showStackTrack: false
    }, options);
    return function (target, property, descriptor) {
        if (descriptor &&
            !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')) {
            throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');
        }
        const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;
        const message = `${methodSignature} is marked obsolete: ${options.message}` +
            (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');
        if (!obsoleteMessage[message]) {
            obsoleteMessage[message] = 0;
        }
        // If descriptor is null it is a class
        const method = descriptor ? Object.assign({}, descriptor) : target;
        if (!descriptor) {
            // with es2015 classes we need to change our decoration tactic
            class DecoratedClass extends method {
                constructor(...args) {
                    logMessage(message, options);
                    super(...args);
                }
            }
            return DecoratedClass;
        }
        if (descriptor && descriptor.value) {
            method.value = function () {
                logMessage(message, options);
                return descriptor.value.apply(this, arguments);
            };
            return method;
        }
        if (descriptor && descriptor.get) {
            method.get = function () {
                logMessage(message, options);
                return descriptor.get.apply(this, arguments);
            };
        }
        if (descriptor && descriptor.set) {
            method.set = function () {
                logMessage(message, options);
                return descriptor.set.apply(this, arguments);
            };
        }
        return method;
    };
}


/***/ }),

/***/ "./Util/Detector.ts":
/*!**************************!*\
  !*** ./Util/Detector.ts ***!
  \**************************/
/*! exports provided: Detector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Detector", function() { return Detector; });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Log */ "./Util/Log.ts");

/**
 * This is the list of features that will be used to log the supported
 * features to the console when Detector.logBrowserFeatures() is called.
 */
const REPORTED_FEATURES = {
    webgl: 'WebGL',
    webaudio: 'WebAudio',
    gamepadapi: 'Gamepad API'
};
/**
 * Excalibur internal feature detection helper class
 */
class Detector {
    constructor() {
        this._features = null;
        this.failedTests = [];
        // critical browser features required for ex to run
        this._criticalTests = {
            // Test canvas/2d context support
            canvasSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('2d'));
            },
            // Test array buffer support ex uses for downloading binary data
            arrayBufferSupport: function () {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', '/');
                try {
                    xhr.responseType = 'arraybuffer';
                }
                catch (e) {
                    return false;
                }
                return xhr.responseType === 'arraybuffer';
            },
            // Test data urls ex uses for sprites
            dataUrlSupport: function () {
                const canvas = document.createElement('canvas');
                return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
            },
            // Test object url support for loading
            objectUrlSupport: function () {
                return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;
            },
            // RGBA support for colors
            rgbaSupport: function () {
                const style = document.createElement('a').style;
                style.cssText = 'background-color:rgba(150,255,150,.5)';
                return ('' + style.backgroundColor).indexOf('rgba') > -1;
            }
        };
        // warnings excalibur performance will be degraded
        this._warningTest = {
            webAudioSupport: function () {
                return !!(window.AudioContext ||
                    window.webkitAudioContext ||
                    window.mozAudioContext ||
                    window.msAudioContext ||
                    window.oAudioContext);
            },
            webglSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('webgl'));
            }
        };
        this._features = this._loadBrowserFeatures();
    }
    /**
     * Returns a map of currently supported browser features. This method
     * treats the features as a singleton and will only calculate feature
     * support if it has not previously been done.
     */
    getBrowserFeatures() {
        if (this._features === null) {
            this._features = this._loadBrowserFeatures();
        }
        return this._features;
    }
    /**
     * Report on non-critical browser support for debugging purposes.
     * Use native browser console colors for visibility.
     */
    logBrowserFeatures() {
        let msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
        const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];
        const supported = this.getBrowserFeatures();
        for (const feature of Object.keys(REPORTED_FEATURES)) {
            if (supported[feature]) {
                msg += '(%c\u2713%c)'; // (✓)
                args.push('font-weight: bold; color: green');
                args.push('font-weight: normal; color: inherit');
            }
            else {
                msg += '(%c\u2717%c)'; // (✗)
                args.push('font-weight: bold; color: red');
                args.push('font-weight: normal; color: inherit');
            }
            msg += ' ' + REPORTED_FEATURES[feature] + '\n';
        }
        args.unshift(msg);
        // eslint-disable-next-line no-console
        console.log.apply(console, args);
    }
    /**
     * Executes several IIFE's to get a constant reference to supported
     * features within the current execution context.
     */
    _loadBrowserFeatures() {
        return {
            // IIFE to check canvas support
            canvas: (() => {
                return this._criticalTests.canvasSupport();
            })(),
            // IIFE to check arraybuffer support
            arraybuffer: (() => {
                return this._criticalTests.arrayBufferSupport();
            })(),
            // IIFE to check dataurl support
            dataurl: (() => {
                return this._criticalTests.dataUrlSupport();
            })(),
            // IIFE to check objecturl support
            objecturl: (() => {
                return this._criticalTests.objectUrlSupport();
            })(),
            // IIFE to check rgba support
            rgba: (() => {
                return this._criticalTests.rgbaSupport();
            })(),
            // IIFE to check webaudio support
            webaudio: (() => {
                return this._warningTest.webAudioSupport();
            })(),
            // IIFE to check webgl support
            webgl: (() => {
                return this._warningTest.webglSupport();
            })(),
            // IIFE to check gamepadapi support
            gamepadapi: (() => {
                return !!navigator.getGamepads;
            })()
        };
    }
    test() {
        // Critical test will for ex not to run
        let failedCritical = false;
        for (const test in this._criticalTests) {
            if (!this._criticalTests[test].call(this)) {
                this.failedTests.push(test);
                _Log__WEBPACK_IMPORTED_MODULE_0__["Logger"].getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                failedCritical = true;
            }
        }
        if (failedCritical) {
            return false;
        }
        // Warning tests do not for ex to return false to compatibility
        for (const warning in this._warningTest) {
            if (!this._warningTest[warning]()) {
                _Log__WEBPACK_IMPORTED_MODULE_0__["Logger"].getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
            }
        }
        return true;
    }
}


/***/ }),

/***/ "./Util/DrawUtil.ts":
/*!**************************!*\
  !*** ./Util/DrawUtil.ts ***!
  \**************************/
/*! exports provided: line, point, vector, roundRect, circle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "line", function() { return line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vector", function() { return vector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundRect", function() { return roundRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circle", function() { return circle; });
/* harmony import */ var _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Drawing/Color */ "./Drawing/Color.ts");

/* istanbul ignore next */
/**
 * Draw a line on canvas context
 *
 * @param ctx The canvas context
 * @param color The color of the line
 * @param x1 The start x coordinate
 * @param y1 The start y coordinate
 * @param x2 The ending x coordinate
 * @param y2 The ending y coordinate
 * @param thickness The line thickness
 * @param cap The [[LineCapStyle]] (butt, round, or square)
 */
function line(ctx, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Red, x1, y1, x2, y2, thickness = 1, cap = 'butt') {
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.lineCap = cap;
    ctx.strokeStyle = color.toString();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.closePath();
    ctx.stroke();
}
/* istanbul ignore next */
/**
 * Draw the vector as a point onto the canvas.
 */
function point(ctx, color = _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].Red, point) {
    ctx.beginPath();
    ctx.strokeStyle = color.toString();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw the vector as a line onto the canvas starting a origin point.
 */
/* istanbul ignore next */
/**
 *
 */
function vector(ctx, color, origin, vector, scale = 1.0) {
    const c = color ? color.toString() : 'blue';
    const v = vector.scale(scale);
    ctx.beginPath();
    ctx.strokeStyle = c;
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(origin.x + v.x, origin.y + v.y);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw a round rectangle on a canvas context
 *
 * @param ctx The canvas context
 * @param x The top-left x coordinate
 * @param y The top-left y coordinate
 * @param width The width of the rectangle
 * @param height The height of the rectangle
 * @param radius The border radius of the rectangle
 * @param stroke The [[Color]] to stroke rectangle with
 * @param fill The [[Color]] to fill rectangle with
 */
function roundRect(ctx, x, y, width, height, radius = 5, stroke = _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].White, fill = null) {
    let br;
    if (typeof radius === 'number') {
        br = { tl: radius, tr: radius, br: radius, bl: radius };
    }
    else {
        const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
        for (const prop in defaultRadius) {
            if (defaultRadius.hasOwnProperty(prop)) {
                const side = prop;
                br[side] = radius[side] || defaultRadius[side];
            }
        }
    }
    ctx.beginPath();
    ctx.moveTo(x + br.tl, y);
    ctx.lineTo(x + width - br.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
    ctx.lineTo(x + width, y + height - br.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
    ctx.lineTo(x + br.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
    ctx.lineTo(x, y + br.tl);
    ctx.quadraticCurveTo(x, y, x + br.tl, y);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}
/**
 *
 */
function circle(ctx, x, y, radius, stroke = _Drawing_Color__WEBPACK_IMPORTED_MODULE_0__["Color"].White, fill = null) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}


/***/ }),

/***/ "./Util/EasingFunctions.ts":
/*!*********************************!*\
  !*** ./Util/EasingFunctions.ts ***!
  \*********************************/
/*! exports provided: EasingFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EasingFunctions", function() { return EasingFunctions; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util/Decorators */ "./Util/Decorators.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
 * Given a time, the function will return a value from positive startValue to positive endValue.
 *
 * ```js
 * function Linear (t) {
 *    return t * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInQuad (t) {
 *    return t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutQuad (t) {
 *    return t * (2 - t);
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutQuad (t) {
 *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInCubic (t) {
 *    return t * t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutCubic (t) {
 *    return (--t) * t * t + 1;
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutCubic (t) {
 *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
 * }
 * ```
 */
class EasingFunctions {
    static CreateReversibleEasingFunction(easing) {
        return (time, start, end, duration) => {
            if (end < start) {
                return start - (easing(time, end, start, duration) - end);
            }
            else {
                return easing(time, start, end, duration);
            }
        };
    }
    static CreateReversableEasingFunction(easing) {
        return EasingFunctions.CreateReversibleEasingFunction(easing);
    }
    static CreateVectorEasingFunction(easing) {
        return (time, start, end, duration) => {
            return new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));
        };
    }
}
EasingFunctions.Linear = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    return (endValue * currentTime) / duration + startValue;
});
EasingFunctions.EaseInQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return -endValue * currentTime * (currentTime - 2) + startValue;
});
EasingFunctions.EaseInOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime + startValue;
    }
    currentTime--;
    return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;
});
EasingFunctions.EaseInCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    currentTime--;
    return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
});
EasingFunctions.EaseInOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;
    }
    currentTime -= 2;
    return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;
});
__decorate([
    Object(_Util_Decorators__WEBPACK_IMPORTED_MODULE_1__["obsolete"])({
        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',
        alternateMethod: 'CreateReversibleEasingFunction'
    })
], EasingFunctions, "CreateReversableEasingFunction", null);


/***/ }),

/***/ "./Util/Index.ts":
/*!***********************!*\
  !*** ./Util/Index.ts ***!
  \***********************/
/*! exports provided: TwoPI, extend, base64Encode, nullish, clamp, randomInRange, randomIntInRange, canonicalizeAngle, toDegrees, toRadians, getPosition, addItemToArray, removeItemFromArray, contains, getOppositeSide, getSideFromDirection, Collection, fail, DrawUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util */ "./Util/Util.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TwoPI", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["TwoPI"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["extend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "base64Encode", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["base64Encode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nullish", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["nullish"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["clamp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomInRange", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["randomInRange"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomIntInRange", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["randomIntInRange"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "canonicalizeAngle", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["canonicalizeAngle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["toDegrees"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["toRadians"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPosition", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["getPosition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addItemToArray", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["addItemToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeItemFromArray", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["removeItemFromArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["contains"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOppositeSide", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["getOppositeSide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getSideFromDirection", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["getSideFromDirection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Collection", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["Collection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fail", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["fail"]; });

/* harmony import */ var _DrawUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawUtil */ "./Util/DrawUtil.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "DrawUtil", function() { return _DrawUtil__WEBPACK_IMPORTED_MODULE_1__; });





/***/ }),

/***/ "./Util/Log.ts":
/*!*********************!*\
  !*** ./Util/Log.ts ***!
  \*********************/
/*! exports provided: LogLevel, Logger, ConsoleAppender, ScreenAppender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLevel", function() { return LogLevel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return Logger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleAppender", function() { return ConsoleAppender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScreenAppender", function() { return ScreenAppender; });
/* eslint-disable no-console */
/**
 * Logging level that Excalibur will tag
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
})(LogLevel || (LogLevel = {}));
/**
 * Static singleton that represents the logging facility for Excalibur.
 * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
 * Derive from [[Appender]] to create your own logging appenders.
 */
class Logger {
    constructor() {
        this._appenders = [];
        /**
         * Gets or sets the default logging level. Excalibur will only log
         * messages if equal to or above this level. Default: [[LogLevel.Info]]
         */
        this.defaultLevel = LogLevel.Info;
        if (Logger._INSTANCE) {
            throw new Error('Logger is a singleton');
        }
        Logger._INSTANCE = this;
        // Default console appender
        Logger._INSTANCE.addAppender(new ConsoleAppender());
        return Logger._INSTANCE;
    }
    /**
     * Gets the current static instance of Logger
     */
    static getInstance() {
        if (Logger._INSTANCE == null) {
            Logger._INSTANCE = new Logger();
        }
        return Logger._INSTANCE;
    }
    /**
     * Adds a new [[Appender]] to the list of appenders to write to
     */
    addAppender(appender) {
        this._appenders.push(appender);
    }
    /**
     * Clears all appenders from the logger
     */
    clearAppenders() {
        this._appenders.length = 0;
    }
    /**
     * Logs a message at a given LogLevel
     * @param level  The LogLevel`to log the message at
     * @param args   An array of arguments to write to an appender
     */
    _log(level, args) {
        if (level == null) {
            level = this.defaultLevel;
        }
        const len = this._appenders.length;
        for (let i = 0; i < len; i++) {
            if (level >= this.defaultLevel) {
                this._appenders[i].log(level, args);
            }
        }
    }
    /**
     * Writes a log message at the [[LogLevel.Debug]] level
     * @param args  Accepts any number of arguments
     */
    debug(...args) {
        this._log(LogLevel.Debug, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Info]] level
     * @param args  Accepts any number of arguments
     */
    info(...args) {
        this._log(LogLevel.Info, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Warn]] level
     * @param args  Accepts any number of arguments
     */
    warn(...args) {
        this._log(LogLevel.Warn, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Error]] level
     * @param args  Accepts any number of arguments
     */
    error(...args) {
        this._log(LogLevel.Error, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Fatal]] level
     * @param args  Accepts any number of arguments
     */
    fatal(...args) {
        this._log(LogLevel.Fatal, args);
    }
}
Logger._INSTANCE = null;
/**
 * Console appender for browsers (i.e. `console.log`)
 */
class ConsoleAppender {
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        // Check for console support
        if (!console && !console.log && console.warn && console.error) {
            // todo maybe do something better than nothing
            return;
        }
        // Create a new console args array
        const consoleArgs = [];
        consoleArgs.unshift.apply(consoleArgs, args);
        consoleArgs.unshift('[' + LogLevel[level] + '] : ');
        if (level < LogLevel.Warn) {
            // Call .log for Debug/Info
            if (console.log.apply) {
                // this is required on some older browsers that don't support apply on console.log :(
                console.log.apply(console, consoleArgs);
            }
            else {
                console.log(consoleArgs.join(' '));
            }
        }
        else if (level < LogLevel.Error) {
            // Call .warn for Warn
            if (console.warn.apply) {
                console.warn.apply(console, consoleArgs);
            }
            else {
                console.warn(consoleArgs.join(' '));
            }
        }
        else {
            // Call .error for Error/Fatal
            if (console.error.apply) {
                console.error.apply(console, consoleArgs);
            }
            else {
                console.error(consoleArgs.join(' '));
            }
        }
    }
}
/**
 * On-screen (canvas) appender
 */
class ScreenAppender {
    /**
     * @param width   Width of the screen appender in pixels
     * @param height  Height of the screen appender in pixels
     */
    constructor(width, height) {
        // @todo Clean this up
        this._messages = [];
        this._canvas = document.createElement('canvas');
        this._canvas.width = width || window.innerWidth;
        this._canvas.height = height || window.innerHeight;
        this._canvas.style.position = 'absolute';
        // eslint-disable-next-line
        this._ctx = this._canvas.getContext('2d'); // eslint-disable-line
        document.body.appendChild(this._canvas);
    }
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        const message = args.join(',');
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
        let pos = 10;
        let opacity = 1.0;
        for (let i = 0; i < this._messages.length; i++) {
            this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
            this._ctx.fillText(this._messages[i], 200, pos);
            pos += 10;
            opacity = opacity > 0 ? opacity - 0.05 : 0;
        }
    }
}


/***/ }),

/***/ "./Util/Observable.ts":
/*!****************************!*\
  !*** ./Util/Observable.ts ***!
  \****************************/
/*! exports provided: Observable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return Observable; });
class Observable {
    constructor() {
        this.observers = [];
    }
    register(observer) {
        this.observers.push(observer);
    }
    unregister(observer) {
        const i = this.observers.indexOf(observer);
        if (i !== -1) {
            this.observers.splice(i, 1);
        }
    }
    notifyAll(message) {
        this.observers.forEach((o) => o.notify(message));
    }
}


/***/ }),

/***/ "./Util/SortedList.ts":
/*!****************************!*\
  !*** ./Util/SortedList.ts ***!
  \****************************/
/*! exports provided: SortedList, BinaryTreeNode, MockedElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SortedList", function() { return SortedList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryTreeNode", function() { return BinaryTreeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MockedElement", function() { return MockedElement; });
/* harmony import */ var _Decorators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Decorators */ "./Util/Decorators.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * A sorted list implementation. NOTE: this implementation is not self-balancing
 * @deprecated
 */
let SortedList = class SortedList {
    constructor(getComparable) {
        this._getComparable = getComparable;
    }
    find(element) {
        return this._find(this._root, element);
    }
    _find(node, element) {
        if (node == null) {
            return false;
        }
        else if (this._getComparable(element) === node.getKey()) {
            if (node.getData().indexOf(element) > -1) {
                return true;
            }
            else {
                return false;
            }
        }
        else if (this._getComparable(element) < node.getKey()) {
            return this._find(node.getLeft(), element);
        }
        else {
            return this._find(node.getRight(), element);
        }
    }
    // returns the array of elements at a specific key value
    get(key) {
        return this._get(this._root, key);
    }
    _get(node, key) {
        if (node == null) {
            return [];
        }
        else if (key === node.getKey()) {
            return node.getData();
        }
        else if (key < node.getKey()) {
            return this._get(node.getLeft(), key);
        }
        else {
            return this._get(node.getRight(), key);
        }
    }
    add(element) {
        if (this._root == null) {
            this._root = new BinaryTreeNode(this._getComparable(element), [element], null, null);
            return true;
        }
        else {
            return this._insert(this._root, element);
        }
    }
    _insert(node, element) {
        if (node != null) {
            if (this._getComparable(element) === node.getKey()) {
                if (node.getData().indexOf(element) > -1) {
                    return false; // the element we're trying to insert already exists
                }
                else {
                    node.getData().push(element);
                    return true;
                }
            }
            else if (this._getComparable(element) < node.getKey()) {
                if (node.getLeft() == null) {
                    node.setLeft(new BinaryTreeNode(this._getComparable(element), [element], null, null));
                    return true;
                }
                else {
                    return this._insert(node.getLeft(), element);
                }
            }
            else {
                if (node.getRight() == null) {
                    node.setRight(new BinaryTreeNode(this._getComparable(element), [element], null, null));
                    return true;
                }
                else {
                    return this._insert(node.getRight(), element);
                }
            }
        }
        return false;
    }
    removeByComparable(element) {
        this._root = this._remove(this._root, element);
    }
    _remove(node, element) {
        if (node == null) {
            return null;
        }
        else if (this._getComparable(element) === node.getKey()) {
            const elementIndex = node.getData().indexOf(element);
            // if the node contains the element, remove the element
            if (elementIndex > -1) {
                node.getData().splice(elementIndex, 1);
                // if we have removed the last element at this node, remove the node
                if (node.getData().length === 0) {
                    // if the node is a leaf
                    if (node.getLeft() == null && node.getRight() == null) {
                        return null;
                    }
                    else if (node.getLeft() == null) {
                        return node.getRight();
                    }
                    else if (node.getRight() == null) {
                        return node.getLeft();
                    }
                    // if node has 2 children
                    const temp = this._findMinNode(node.getRight());
                    node.setKey(temp.getKey());
                    node.setData(temp.getData());
                    node.setRight(this._cleanup(node.getRight(), temp)); //"cleanup nodes" (move them up recursively)
                    return node;
                }
                else {
                    // this prevents the node from being removed since it still contains elements
                    return node;
                }
            }
        }
        else if (this._getComparable(element) < node.getKey()) {
            node.setLeft(this._remove(node.getLeft(), element));
            return node;
        }
        else {
            node.setRight(this._remove(node.getRight(), element));
            return node;
        }
        return null;
    }
    // called once we have successfully removed the element we wanted, recursively corrects the part of the tree below the removed node
    _cleanup(node, element) {
        const comparable = element.getKey();
        if (node == null) {
            return null;
        }
        else if (comparable === node.getKey()) {
            // if the node is a leaf
            if (node.getLeft() == null && node.getRight() == null) {
                return null;
            }
            else if (node.getLeft() == null) {
                return node.getRight();
            }
            else if (node.getRight() == null) {
                return node.getLeft();
            }
            // if node has 2 children
            const temp = this._findMinNode(node.getRight());
            node.setKey(temp.getKey());
            node.setData(temp.getData());
            node.setRight(this._cleanup(node.getRight(), temp));
            return node;
        }
        else if (element.getKey() < node.getKey()) {
            node.setLeft(this._cleanup(node.getLeft(), element));
            return node;
        }
        else {
            node.setRight(this._cleanup(node.getRight(), element));
            return node;
        }
    }
    _findMinNode(node) {
        let current = node;
        while (current.getLeft() != null) {
            current = current.getLeft();
        }
        return current;
    }
    list() {
        const results = new Array();
        this._list(this._root, results);
        return results;
    }
    _list(treeNode, results) {
        if (treeNode != null) {
            this._list(treeNode.getLeft(), results);
            treeNode.getData().forEach((element) => {
                results.push(element);
            });
            this._list(treeNode.getRight(), results);
        }
    }
};
SortedList = __decorate([
    Object(_Decorators__WEBPACK_IMPORTED_MODULE_0__["obsolete"])({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use built in JS array.sort' })
], SortedList);

/**
 * A tree node part of [[SortedList]]
 * @deprecated
 */
let BinaryTreeNode = class BinaryTreeNode {
    constructor(key, data, left, right) {
        this._key = key;
        this._data = data;
        this._left = left;
        this._right = right;
    }
    getKey() {
        return this._key;
    }
    setKey(key) {
        this._key = key;
    }
    getData() {
        return this._data;
    }
    setData(data) {
        this._data = data;
    }
    getLeft() {
        return this._left;
    }
    setLeft(left) {
        this._left = left;
    }
    getRight() {
        return this._right;
    }
    setRight(right) {
        this._right = right;
    }
};
BinaryTreeNode = __decorate([
    Object(_Decorators__WEBPACK_IMPORTED_MODULE_0__["obsolete"])({ message: 'Will be removed in excalibur v0.26.0' })
], BinaryTreeNode);

/**
 * Mock element for testing
 *
 * @internal
 * @deprecated
 */
class MockedElement {
    constructor(key) {
        this._key = 0;
        this._key = key;
    }
    getTheKey() {
        return this._key;
    }
    setKey(key) {
        this._key = key;
    }
}


/***/ }),

/***/ "./Util/Sound.ts":
/*!***********************!*\
  !*** ./Util/Sound.ts ***!
  \***********************/
/*! exports provided: canPlayFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canPlayFile", function() { return canPlayFile; });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Log */ "./Util/Log.ts");

/**
 * Whether or not the browser can play this file as HTML5 Audio
 */
function canPlayFile(file) {
    try {
        const a = new Audio();
        const filetype = /.*\.([A-Za-z0-9]+)$/;
        const type = file.match(filetype)[1];
        if (a.canPlayType('audio/' + type)) {
            return true;
        }
        else {
            return false;
        }
    }
    catch (e) {
        _Log__WEBPACK_IMPORTED_MODULE_0__["Logger"].getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
        return false;
    }
}


/***/ }),

/***/ "./Util/Util.ts":
/*!**********************!*\
  !*** ./Util/Util.ts ***!
  \**********************/
/*! exports provided: TwoPI, extend, base64Encode, nullish, clamp, randomInRange, randomIntInRange, canonicalizeAngle, toDegrees, toRadians, getPosition, addItemToArray, removeItemFromArray, contains, getOppositeSide, getSideFromDirection, Collection, fail */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TwoPI", function() { return TwoPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "base64Encode", function() { return base64Encode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nullish", function() { return nullish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomInRange", function() { return randomInRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomIntInRange", function() { return randomIntInRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canonicalizeAngle", function() { return canonicalizeAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return toDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return toRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPosition", function() { return getPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addItemToArray", function() { return addItemToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeItemFromArray", function() { return removeItemFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return contains; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOppositeSide", function() { return getOppositeSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSideFromDirection", function() { return getSideFromDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Collection", function() { return Collection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fail", function() { return fail; });
/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Algebra */ "./Algebra.ts");
/* harmony import */ var _Math_Random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math/Random */ "./Math/Random.ts");
/* harmony import */ var _Collision_Side__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Collision/Side */ "./Collision/Side.ts");



/**
 * Two PI constant
 */
const TwoPI = Math.PI * 2;
/**
 * Merges one or more objects into a single target object
 *
 * @returns Merged object with properties from other objects
 * @credit https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
 */
function extend() {
    const extended = {};
    let deep = false;
    let i = 0;
    const length = arguments.length;
    // Check if a deep merge
    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
        deep = arguments[0];
        i++;
    }
    // Merge the object into the extended object
    const assignExists = typeof Object.assign === 'function';
    let merge = null;
    if (!assignExists) {
        merge = function (obj) {
            for (const prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    // If deep merge and property is an object, merge properties
                    if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                        extended[prop] = extend(true, extended[prop], obj[prop]);
                    }
                    else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };
    }
    else {
        merge = Object.assign;
    }
    // Loop through each object and conduct a merge
    for (; i < length; i++) {
        const obj = arguments[i];
        if (!assignExists) {
            merge(obj);
        }
        else {
            merge(extended, obj);
        }
    }
    return extended;
}
/**
 * Encode a string in base64
 * @deprecated This method is marked for removal
 */
function base64Encode(inputStr) {
    const b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    let outputStr = '';
    let i = 0;
    while (i < inputStr.length) {
        //all three "& 0xff" added below are there to fix a known bug
        //with bytes returned by xhr.responseText
        const byte1 = inputStr.charCodeAt(i++) & 0xff;
        const byte2 = inputStr.charCodeAt(i++) & 0xff;
        const byte3 = inputStr.charCodeAt(i++) & 0xff;
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        let enc3, enc4;
        if (isNaN(byte2)) {
            enc3 = enc4 = 64;
        }
        else {
            enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
            if (isNaN(byte3)) {
                enc4 = 64;
            }
            else {
                enc4 = byte3 & 63;
            }
        }
        outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
    }
    return outputStr;
}
/**
 * Sugar that will use `nullishVal` if it's not null or undefined. Simulates the `??` operator
 * @param nullishVal
 * @param defaultVal
 */
function nullish(nullishVal, defaultVal) {
    return nullishVal !== null && nullishVal !== undefined ? nullishVal : defaultVal;
}
/**
 * Clamps a value between a min and max inclusive
 */
function clamp(val, min, max) {
    return Math.min(Math.max(min, val), max);
}
/**
 * Find a random floating point number in range
 */
function randomInRange(min, max, random = new _Math_Random__WEBPACK_IMPORTED_MODULE_1__["Random"]()) {
    return random ? random.floating(min, max) : min + Math.random() * (max - min);
}
/**
 * Find a random integer in a range
 */
function randomIntInRange(min, max, random = new _Math_Random__WEBPACK_IMPORTED_MODULE_1__["Random"]()) {
    return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
}
/**
 * Convert an angle to be the equivalent in the range [0, 2PI]
 */
function canonicalizeAngle(angle) {
    let tmpAngle = angle;
    if (angle > TwoPI) {
        while (tmpAngle > TwoPI) {
            tmpAngle -= TwoPI;
        }
    }
    if (angle < 0) {
        while (tmpAngle < 0) {
            tmpAngle += TwoPI;
        }
    }
    return tmpAngle;
}
/**
 * Convert radians to degrees
 */
function toDegrees(radians) {
    return (180 / Math.PI) * radians;
}
/**
 * Convert degrees to radians
 */
function toRadians(degrees) {
    return (degrees / 180) * Math.PI;
}
/**
 * Find the screen position of an HTML element
 */
function getPosition(el) {
    let oLeft = 0, oTop = 0;
    const calcOffsetLeft = (parent) => {
        oLeft += parent.offsetLeft;
        if (parent.offsetParent) {
            calcOffsetLeft(parent.offsetParent);
        }
    };
    const calcOffsetTop = (parent) => {
        oTop += parent.offsetTop;
        if (parent.offsetParent) {
            calcOffsetTop(parent.offsetParent);
        }
    };
    calcOffsetLeft(el);
    calcOffsetTop(el);
    return new _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"](oLeft, oTop);
}
/**
 * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.
 * @deprecated
 */
function addItemToArray(item, array) {
    if (array.indexOf(item) === -1) {
        array.push(item);
        return true;
    }
    return false;
}
/**
 * Remove an item from an list
 */
function removeItemFromArray(item, array) {
    let index = -1;
    if ((index = array.indexOf(item)) > -1) {
        array.splice(index, 1);
        return true;
    }
    return false;
}
/**
 * See if an array contains something
 */
function contains(array, obj) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === obj) {
            return true;
        }
    }
    return false;
}
/**
 * Get the opposit side
 * TODO: Move to Side type
 * @deprecated
 */
function getOppositeSide(side) {
    if (side === _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Top) {
        return _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Bottom;
    }
    if (side === _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Bottom) {
        return _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Top;
    }
    if (side === _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Left) {
        return _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Right;
    }
    if (side === _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Right) {
        return _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Left;
    }
    return _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].None;
}
/**
 * Returns the side in the direction of the vector supplied
 * @param direction Vector to check
 * TODO: Move to Side type
 */
function getSideFromDirection(direction) {
    const directions = [_Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Left, _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Right, _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Up, _Algebra__WEBPACK_IMPORTED_MODULE_0__["Vector"].Down];
    const directionEnum = [_Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Left, _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Right, _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Top, _Collision_Side__WEBPACK_IMPORTED_MODULE_2__["Side"].Bottom];
    let max = -Number.MAX_VALUE;
    let maxIndex = -1;
    for (let i = 0; i < directions.length; i++) {
        if (directions[i].dot(direction) > max) {
            max = directions[i].dot(direction);
            maxIndex = i;
        }
    }
    return directionEnum[maxIndex];
}
/**
 * Excalibur's dynamically resizing collection
 * @deprecated Will be removed in future releases
 */
class Collection {
    /**
     * @param initialSize  Initial size of the internal backing array
     */
    constructor(initialSize = Collection.DefaultSize) {
        this._internalArray = null;
        this._endPointer = 0;
        this._internalArray = new Array(initialSize);
    }
    _resize() {
        const newSize = this._internalArray.length * 2;
        const newArray = new Array(newSize);
        const count = this.count();
        for (let i = 0; i < count; i++) {
            newArray[i] = this._internalArray[i];
        }
        delete this._internalArray;
        this._internalArray = newArray;
    }
    /**
     * Push elements to the end of the collection
     */
    push(element) {
        if (this._endPointer === this._internalArray.length) {
            this._resize();
        }
        return (this._internalArray[this._endPointer++] = element);
    }
    /**
     * Removes elements from the end of the collection
     */
    pop() {
        this._endPointer = this._endPointer - 1 < 0 ? 0 : this._endPointer - 1;
        return this._internalArray[this._endPointer];
    }
    /**
     * Returns the count of the collection
     */
    count() {
        return this._endPointer;
    }
    /**
     * Empties the collection
     */
    clear() {
        this._endPointer = 0;
    }
    /**
     * Returns the size of the internal backing array
     */
    internalSize() {
        return this._internalArray.length;
    }
    /**
     * Returns an element at a specific index
     * @param index  Index of element to retrieve
     */
    elementAt(index) {
        if (index >= this.count()) {
            //Logger.getInstance().error('Invalid parameter: ' + index);
            throw new Error('Invalid index ' + index);
        }
        return this._internalArray[index];
    }
    /**
     * Inserts an element at a specific index
     * @param index  Index to insert the element
     * @param value  Element to insert
     */
    insert(index, value) {
        if (index >= this.count()) {
            this._resize();
        }
        return (this._internalArray[index] = value);
    }
    /**
     * Removes an element at a specific index
     * @param index  Index of element to remove
     */
    remove(index) {
        const count = this.count();
        if (count === 0) {
            //Logger.getInstance().error('Invalid parameter: ' + index);
            throw new Error('Invalid parameter ' + index);
        }
        // O(n) Shift
        const removed = this._internalArray[index];
        for (let i = index; i < count; i++) {
            this._internalArray[i] = this._internalArray[i + 1];
        }
        this._endPointer--;
        return removed;
    }
    /**
     * Removes an element by reference
     * @param element  Element to retrieve
     */
    removeElement(element) {
        const index = this._internalArray.indexOf(element);
        this.remove(index);
    }
    /**
     * Returns a array representing the collection
     */
    toArray() {
        return this._internalArray.slice(0, this._endPointer);
    }
    /**
     * Iterate over every element in the collection
     * @param func  Callback to call for each element passing a reference to the element and its index, returned values are ignored
     */
    forEach(func) {
        let i = 0;
        const count = this.count();
        for (i; i < count; i++) {
            func.call(this, this._internalArray[i], i);
        }
    }
    /**
     * Mutate every element in the collection
     * @param func  Callback to call for each element passing a reference to the element and its index, any values returned mutate
     * the collection
     */
    map(func) {
        const count = this.count();
        for (let i = 0; i < count; i++) {
            this._internalArray[i] = func.call(this, this._internalArray[i], i);
        }
    }
}
/**
 * Default collection size
 */
Collection.DefaultSize = 200;
/**
 * Used for exhaustive checks at compile time
 */
function fail(message) {
    throw new Error(message);
}


/***/ }),

/***/ "./Util/WebAudio.ts":
/*!**************************!*\
  !*** ./Util/WebAudio.ts ***!
  \**************************/
/*! exports provided: WebAudio */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebAudio", function() { return WebAudio; });
/* harmony import */ var _Resources_Sound_AudioContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Resources/Sound/AudioContext */ "./Resources/Sound/AudioContext.ts");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Log */ "./Util/Log.ts");


/**
 * Patch for detecting legacy web audio in browsers
 * @internal
 * @param source
 */
function isLegacyWebAudioSource(source) {
    return !!source.playbackState;
}
class WebAudio {
    /**
     * Play an empty sound to unlock Safari WebAudio context. Call this function
     * right after a user interaction event.
     * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     */
    static unlock() {
        const promise = new Promise((resolve, reject) => {
            if (WebAudio._UNLOCKED || !_Resources_Sound_AudioContext__WEBPACK_IMPORTED_MODULE_0__["AudioContextFactory"].create()) {
                return resolve(true);
            }
            const unlockTimeoutTimer = setTimeout(() => {
                _Log__WEBPACK_IMPORTED_MODULE_1__["Logger"].getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');
                resolve();
            }, 200);
            const audioContext = _Resources_Sound_AudioContext__WEBPACK_IMPORTED_MODULE_0__["AudioContextFactory"].create();
            audioContext.resume().then(() => {
                // create empty buffer and play it
                const buffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                let ended = false;
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.onended = () => (ended = true);
                source.start(0);
                // by checking the play state after some time, we know if we're really unlocked
                setTimeout(() => {
                    if (isLegacyWebAudioSource(source)) {
                        if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                    else {
                        if (audioContext.currentTime > 0 || ended) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                }, 0);
                clearTimeout(unlockTimeoutTimer);
                resolve();
            }, () => {
                reject();
            });
        });
        return promise;
    }
    static isUnlocked() {
        return this._UNLOCKED;
    }
}
WebAudio._UNLOCKED = false;


/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/*! exports provided: EX_VERSION, Flags, ScrollPreventionMode, Engine, DisplayMode, Resolution, Screen, Actor, CollisionType, Vector, Ray, Line, Projection, GlobalCoordinates, vec, StrategyContainer, Axis, LockCameraToActorStrategy, LockCameraToActorAxisStrategy, ElasticToActorStrategy, RadiusAroundActorStrategy, LimitCameraBoundsStrategy, Camera, Class, Configurable, Debug, FrameStats, PhysicsStats, EventDispatcher, MediaEvent, NativeSoundEvent, NativeSoundProcessedEvent, EventTypes, GameEvent, KillEvent, PreKillEvent, PostKillEvent, GameStartEvent, GameStopEvent, PreDrawEvent, PostDrawEvent, PreDebugDrawEvent, PostDebugDrawEvent, PreUpdateEvent, PostUpdateEvent, PreFrameEvent, PostFrameEvent, GamepadConnectEvent, GamepadDisconnectEvent, GamepadButtonEvent, GamepadAxisEvent, SubscribeEvent, UnsubscribeEvent, VisibleEvent, HiddenEvent, PreCollisionEvent, PostCollisionEvent, CollisionStartEvent, CollisionEndEvent, InitializeEvent, ActivateEvent, DeactivateEvent, ExitViewPortEvent, EnterViewPortEvent, EnterTriggerEvent, ExitTriggerEvent, Label, FontStyle, FontUnit, TextAlign, BaseAlign, Loader, Particle, ParticleEmitter, EmitterType, CollisionResolutionStrategy, BroadphaseStrategy, Integrator, Physics, Scene, TileMap, Cell, TileSprite, Timer, Trigger, ScreenElement, ActionContext, RotationType, Actions, Internal, Body, isCollider, Collider, BoundingBox, Circle, CollisionContact, CollisionJumpTable, ClosestLine, ClosestLineJumpTable, CollisionGroup, CollisionGroupManager, TreeNode, DynamicTree, DynamicTreeCollisionBroadphase, Edge, Pair, ConvexPolygon, Side, Shape, Animation, Color, Polygon, Sprite, SpriteSheet, SpriteFont, CanvasDrawComponent, CanvasDrawingSystem, Effects, ExResponse, has_initialize, hasOnInitialize, has_preupdate, hasOnPreUpdate, has_postupdate, hasOnPostUpdate, hasPreDraw, hasPostDraw, PerlinGenerator, PerlinDrawer2D, Random, ColorBlindness, ColorBlindCorrector, Resource, Sound, AudioContextFactory, WebAudioInstance, Texture, Gif, Stream, ParseGif, Component, TagComponent, AddedComponent, isAddedComponent, RemovedComponent, isRemovedComponent, Entity, EntityManager, Query, QueryManager, SystemType, System, AddedEntity, isAddedSystemEntity, RemovedEntity, isRemoveSystemEntity, SystemManager, World, CoordPlane, TransformComponent, Events, Input, Traits, Util, BrowserComponent, BrowserEvents, maxMessages, resetObsoleteCounter, obsolete, Detector, CullingBox, EasingFunctions, LogLevel, Logger, ConsoleAppender, ScreenAppender, SortedList, BinaryTreeNode, MockedElement, PromiseState, Promise */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EX_VERSION", function() { return EX_VERSION; });
/* harmony import */ var _Polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polyfill */ "./Polyfill.ts");
/* harmony import */ var _Flags__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Flags */ "./Flags.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Flags", function() { return _Flags__WEBPACK_IMPORTED_MODULE_1__["Flags"]; });

/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Engine */ "./Engine.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScrollPreventionMode", function() { return _Engine__WEBPACK_IMPORTED_MODULE_2__["ScrollPreventionMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Engine", function() { return _Engine__WEBPACK_IMPORTED_MODULE_2__["Engine"]; });

/* harmony import */ var _Screen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Screen */ "./Screen.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DisplayMode", function() { return _Screen__WEBPACK_IMPORTED_MODULE_3__["DisplayMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Resolution", function() { return _Screen__WEBPACK_IMPORTED_MODULE_3__["Resolution"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Screen", function() { return _Screen__WEBPACK_IMPORTED_MODULE_3__["Screen"]; });

/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Actor */ "./Actor.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Actor", function() { return _Actor__WEBPACK_IMPORTED_MODULE_4__["Actor"]; });

/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Collision/CollisionType */ "./Collision/CollisionType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionType", function() { return _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_5__["CollisionType"]; });

/* harmony import */ var _Algebra__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Algebra */ "./Algebra.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return _Algebra__WEBPACK_IMPORTED_MODULE_6__["Vector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return _Algebra__WEBPACK_IMPORTED_MODULE_6__["Ray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return _Algebra__WEBPACK_IMPORTED_MODULE_6__["Line"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Projection", function() { return _Algebra__WEBPACK_IMPORTED_MODULE_6__["Projection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GlobalCoordinates", function() { return _Algebra__WEBPACK_IMPORTED_MODULE_6__["GlobalCoordinates"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vec", function() { return _Algebra__WEBPACK_IMPORTED_MODULE_6__["vec"]; });

/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Camera */ "./Camera.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StrategyContainer", function() { return _Camera__WEBPACK_IMPORTED_MODULE_7__["StrategyContainer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Axis", function() { return _Camera__WEBPACK_IMPORTED_MODULE_7__["Axis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LockCameraToActorStrategy", function() { return _Camera__WEBPACK_IMPORTED_MODULE_7__["LockCameraToActorStrategy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LockCameraToActorAxisStrategy", function() { return _Camera__WEBPACK_IMPORTED_MODULE_7__["LockCameraToActorAxisStrategy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ElasticToActorStrategy", function() { return _Camera__WEBPACK_IMPORTED_MODULE_7__["ElasticToActorStrategy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RadiusAroundActorStrategy", function() { return _Camera__WEBPACK_IMPORTED_MODULE_7__["RadiusAroundActorStrategy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LimitCameraBoundsStrategy", function() { return _Camera__WEBPACK_IMPORTED_MODULE_7__["LimitCameraBoundsStrategy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return _Camera__WEBPACK_IMPORTED_MODULE_7__["Camera"]; });

/* harmony import */ var _Class__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Class */ "./Class.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Class", function() { return _Class__WEBPACK_IMPORTED_MODULE_8__["Class"]; });

/* harmony import */ var _Configurable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Configurable */ "./Configurable.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Configurable", function() { return _Configurable__WEBPACK_IMPORTED_MODULE_9__["Configurable"]; });

/* harmony import */ var _Debug__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Debug */ "./Debug.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Debug", function() { return _Debug__WEBPACK_IMPORTED_MODULE_10__["Debug"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FrameStats", function() { return _Debug__WEBPACK_IMPORTED_MODULE_10__["FrameStats"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PhysicsStats", function() { return _Debug__WEBPACK_IMPORTED_MODULE_10__["PhysicsStats"]; });

/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./EventDispatcher */ "./EventDispatcher.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return _EventDispatcher__WEBPACK_IMPORTED_MODULE_11__["EventDispatcher"]; });

/* harmony import */ var _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Events/MediaEvents */ "./Events/MediaEvents.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MediaEvent", function() { return _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_12__["MediaEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NativeSoundEvent", function() { return _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_12__["NativeSoundEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NativeSoundProcessedEvent", function() { return _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_12__["NativeSoundProcessedEvent"]; });

/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Events */ "./Events.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventTypes", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["EventTypes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GameEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["GameEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KillEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["KillEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PreKillEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PreKillEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PostKillEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PostKillEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GameStartEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["GameStartEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GameStopEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["GameStopEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PreDrawEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PreDrawEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PostDrawEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PostDrawEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PreDebugDrawEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PreDebugDrawEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PostDebugDrawEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PostDebugDrawEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PreUpdateEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PreUpdateEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PostUpdateEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PostUpdateEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PreFrameEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PreFrameEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PostFrameEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PostFrameEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GamepadConnectEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["GamepadConnectEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GamepadDisconnectEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["GamepadDisconnectEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GamepadButtonEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["GamepadButtonEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GamepadAxisEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["GamepadAxisEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SubscribeEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["SubscribeEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnsubscribeEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["UnsubscribeEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VisibleEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["VisibleEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HiddenEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["HiddenEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PreCollisionEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PreCollisionEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PostCollisionEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["PostCollisionEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionStartEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["CollisionStartEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionEndEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["CollisionEndEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InitializeEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["InitializeEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActivateEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["ActivateEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DeactivateEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["DeactivateEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExitViewPortEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["ExitViewPortEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EnterViewPortEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["EnterViewPortEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EnterTriggerEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["EnterTriggerEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExitTriggerEvent", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__["ExitTriggerEvent"]; });

/* harmony import */ var _Label__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Label */ "./Label.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Label", function() { return _Label__WEBPACK_IMPORTED_MODULE_14__["Label"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FontStyle", function() { return _Label__WEBPACK_IMPORTED_MODULE_14__["FontStyle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FontUnit", function() { return _Label__WEBPACK_IMPORTED_MODULE_14__["FontUnit"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextAlign", function() { return _Label__WEBPACK_IMPORTED_MODULE_14__["TextAlign"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseAlign", function() { return _Label__WEBPACK_IMPORTED_MODULE_14__["BaseAlign"]; });

/* harmony import */ var _Loader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Loader */ "./Loader.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return _Loader__WEBPACK_IMPORTED_MODULE_15__["Loader"]; });

/* harmony import */ var _Particles__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Particles */ "./Particles.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return _Particles__WEBPACK_IMPORTED_MODULE_16__["Particle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParticleEmitter", function() { return _Particles__WEBPACK_IMPORTED_MODULE_16__["ParticleEmitter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EmitterType", function() { return _Particles__WEBPACK_IMPORTED_MODULE_16__["EmitterType"]; });

/* harmony import */ var _Physics__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Physics */ "./Physics.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionResolutionStrategy", function() { return _Physics__WEBPACK_IMPORTED_MODULE_17__["CollisionResolutionStrategy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BroadphaseStrategy", function() { return _Physics__WEBPACK_IMPORTED_MODULE_17__["BroadphaseStrategy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Integrator", function() { return _Physics__WEBPACK_IMPORTED_MODULE_17__["Integrator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Physics", function() { return _Physics__WEBPACK_IMPORTED_MODULE_17__["Physics"]; });

/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Scene */ "./Scene.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return _Scene__WEBPACK_IMPORTED_MODULE_18__["Scene"]; });

/* harmony import */ var _TileMap__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./TileMap */ "./TileMap.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TileMap", function() { return _TileMap__WEBPACK_IMPORTED_MODULE_19__["TileMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cell", function() { return _TileMap__WEBPACK_IMPORTED_MODULE_19__["Cell"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TileSprite", function() { return _TileMap__WEBPACK_IMPORTED_MODULE_19__["TileSprite"]; });

/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Timer */ "./Timer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return _Timer__WEBPACK_IMPORTED_MODULE_20__["Timer"]; });

/* harmony import */ var _Trigger__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Trigger */ "./Trigger.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Trigger", function() { return _Trigger__WEBPACK_IMPORTED_MODULE_21__["Trigger"]; });

/* harmony import */ var _ScreenElement__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./ScreenElement */ "./ScreenElement.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScreenElement", function() { return _ScreenElement__WEBPACK_IMPORTED_MODULE_22__["ScreenElement"]; });

/* harmony import */ var _Actions_Index__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./Actions/Index */ "./Actions/Index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActionContext", function() { return _Actions_Index__WEBPACK_IMPORTED_MODULE_23__["ActionContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RotationType", function() { return _Actions_Index__WEBPACK_IMPORTED_MODULE_23__["RotationType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Actions", function() { return _Actions_Index__WEBPACK_IMPORTED_MODULE_23__["Actions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Internal", function() { return _Actions_Index__WEBPACK_IMPORTED_MODULE_23__["Internal"]; });

/* harmony import */ var _Collision_Index__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./Collision/Index */ "./Collision/Index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Body", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["Body"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isCollider", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["isCollider"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Collider", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["Collider"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["BoundingBox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["Circle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionContact", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["CollisionContact"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionJumpTable", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["CollisionJumpTable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClosestLine", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["ClosestLine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClosestLineJumpTable", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["ClosestLineJumpTable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionGroup", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["CollisionGroup"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollisionGroupManager", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["CollisionGroupManager"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TreeNode", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["TreeNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DynamicTree", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["DynamicTree"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DynamicTreeCollisionBroadphase", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["DynamicTreeCollisionBroadphase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Edge", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["Edge"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pair", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["Pair"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConvexPolygon", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["ConvexPolygon"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Side", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["Side"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return _Collision_Index__WEBPACK_IMPORTED_MODULE_24__["Shape"]; });

/* harmony import */ var _Drawing_Index__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./Drawing/Index */ "./Drawing/Index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return _Drawing_Index__WEBPACK_IMPORTED_MODULE_25__["Animation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return _Drawing_Index__WEBPACK_IMPORTED_MODULE_25__["Color"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return _Drawing_Index__WEBPACK_IMPORTED_MODULE_25__["Polygon"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return _Drawing_Index__WEBPACK_IMPORTED_MODULE_25__["Sprite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpriteSheet", function() { return _Drawing_Index__WEBPACK_IMPORTED_MODULE_25__["SpriteSheet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpriteFont", function() { return _Drawing_Index__WEBPACK_IMPORTED_MODULE_25__["SpriteFont"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasDrawComponent", function() { return _Drawing_Index__WEBPACK_IMPORTED_MODULE_25__["CanvasDrawComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasDrawingSystem", function() { return _Drawing_Index__WEBPACK_IMPORTED_MODULE_25__["CanvasDrawingSystem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Effects", function() { return _Drawing_Index__WEBPACK_IMPORTED_MODULE_25__["Effects"]; });

/* harmony import */ var _Interfaces_Index__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./Interfaces/Index */ "./Interfaces/Index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExResponse", function() { return _Interfaces_Index__WEBPACK_IMPORTED_MODULE_26__["ExResponse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has_initialize", function() { return _Interfaces_Index__WEBPACK_IMPORTED_MODULE_26__["has_initialize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasOnInitialize", function() { return _Interfaces_Index__WEBPACK_IMPORTED_MODULE_26__["hasOnInitialize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has_preupdate", function() { return _Interfaces_Index__WEBPACK_IMPORTED_MODULE_26__["has_preupdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasOnPreUpdate", function() { return _Interfaces_Index__WEBPACK_IMPORTED_MODULE_26__["hasOnPreUpdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has_postupdate", function() { return _Interfaces_Index__WEBPACK_IMPORTED_MODULE_26__["has_postupdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasOnPostUpdate", function() { return _Interfaces_Index__WEBPACK_IMPORTED_MODULE_26__["hasOnPostUpdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasPreDraw", function() { return _Interfaces_Index__WEBPACK_IMPORTED_MODULE_26__["hasPreDraw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasPostDraw", function() { return _Interfaces_Index__WEBPACK_IMPORTED_MODULE_26__["hasPostDraw"]; });

/* harmony import */ var _Math_Index__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./Math/Index */ "./Math/Index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PerlinGenerator", function() { return _Math_Index__WEBPACK_IMPORTED_MODULE_27__["PerlinGenerator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PerlinDrawer2D", function() { return _Math_Index__WEBPACK_IMPORTED_MODULE_27__["PerlinDrawer2D"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Random", function() { return _Math_Index__WEBPACK_IMPORTED_MODULE_27__["Random"]; });

/* harmony import */ var _PostProcessing_Index__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./PostProcessing/Index */ "./PostProcessing/Index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorBlindness", function() { return _PostProcessing_Index__WEBPACK_IMPORTED_MODULE_28__["ColorBlindness"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorBlindCorrector", function() { return _PostProcessing_Index__WEBPACK_IMPORTED_MODULE_28__["ColorBlindCorrector"]; });

/* harmony import */ var _Resources_Index__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./Resources/Index */ "./Resources/Index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Resource", function() { return _Resources_Index__WEBPACK_IMPORTED_MODULE_29__["Resource"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sound", function() { return _Resources_Index__WEBPACK_IMPORTED_MODULE_29__["Sound"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AudioContextFactory", function() { return _Resources_Index__WEBPACK_IMPORTED_MODULE_29__["AudioContextFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebAudioInstance", function() { return _Resources_Index__WEBPACK_IMPORTED_MODULE_29__["WebAudioInstance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return _Resources_Index__WEBPACK_IMPORTED_MODULE_29__["Texture"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Gif", function() { return _Resources_Index__WEBPACK_IMPORTED_MODULE_29__["Gif"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stream", function() { return _Resources_Index__WEBPACK_IMPORTED_MODULE_29__["Stream"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParseGif", function() { return _Resources_Index__WEBPACK_IMPORTED_MODULE_29__["ParseGif"]; });

/* harmony import */ var _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./EntityComponentSystem/index */ "./EntityComponentSystem/index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["Component"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TagComponent", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["TagComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AddedComponent", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["AddedComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isAddedComponent", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["isAddedComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RemovedComponent", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["RemovedComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRemovedComponent", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["isRemovedComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Entity", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["Entity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EntityManager", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["EntityManager"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Query", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["Query"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QueryManager", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["QueryManager"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SystemType", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["SystemType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "System", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["System"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AddedEntity", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["AddedEntity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isAddedSystemEntity", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["isAddedSystemEntity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RemovedEntity", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["RemovedEntity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRemoveSystemEntity", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["isRemoveSystemEntity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SystemManager", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["SystemManager"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "World", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["World"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CoordPlane", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["CoordPlane"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformComponent", function() { return _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_30__["TransformComponent"]; });

/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Events", function() { return _Events__WEBPACK_IMPORTED_MODULE_13__; });
/* harmony import */ var _Input_Index__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./Input/Index */ "./Input/Index.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Input", function() { return _Input_Index__WEBPACK_IMPORTED_MODULE_31__; });
/* harmony import */ var _Traits_Index__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./Traits/Index */ "./Traits/Index.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Traits", function() { return _Traits_Index__WEBPACK_IMPORTED_MODULE_32__; });
/* harmony import */ var _Util_Index__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./Util/Index */ "./Util/Index.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Util", function() { return _Util_Index__WEBPACK_IMPORTED_MODULE_33__; });
/* harmony import */ var _Util_Browser__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./Util/Browser */ "./Util/Browser.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BrowserComponent", function() { return _Util_Browser__WEBPACK_IMPORTED_MODULE_34__["BrowserComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BrowserEvents", function() { return _Util_Browser__WEBPACK_IMPORTED_MODULE_34__["BrowserEvents"]; });

/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./Util/Decorators */ "./Util/Decorators.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maxMessages", function() { return _Util_Decorators__WEBPACK_IMPORTED_MODULE_35__["maxMessages"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetObsoleteCounter", function() { return _Util_Decorators__WEBPACK_IMPORTED_MODULE_35__["resetObsoleteCounter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "obsolete", function() { return _Util_Decorators__WEBPACK_IMPORTED_MODULE_35__["obsolete"]; });

/* harmony import */ var _Util_Detector__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./Util/Detector */ "./Util/Detector.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Detector", function() { return _Util_Detector__WEBPACK_IMPORTED_MODULE_36__["Detector"]; });

/* harmony import */ var _Util_CullingBox__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./Util/CullingBox */ "./Util/CullingBox.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CullingBox", function() { return _Util_CullingBox__WEBPACK_IMPORTED_MODULE_37__["CullingBox"]; });

/* harmony import */ var _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./Util/EasingFunctions */ "./Util/EasingFunctions.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EasingFunctions", function() { return _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_38__["EasingFunctions"]; });

/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LogLevel", function() { return _Util_Log__WEBPACK_IMPORTED_MODULE_39__["LogLevel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return _Util_Log__WEBPACK_IMPORTED_MODULE_39__["Logger"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConsoleAppender", function() { return _Util_Log__WEBPACK_IMPORTED_MODULE_39__["ConsoleAppender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScreenAppender", function() { return _Util_Log__WEBPACK_IMPORTED_MODULE_39__["ScreenAppender"]; });

/* harmony import */ var _Util_SortedList__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./Util/SortedList */ "./Util/SortedList.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SortedList", function() { return _Util_SortedList__WEBPACK_IMPORTED_MODULE_40__["SortedList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BinaryTreeNode", function() { return _Util_SortedList__WEBPACK_IMPORTED_MODULE_40__["BinaryTreeNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MockedElement", function() { return _Util_SortedList__WEBPACK_IMPORTED_MODULE_40__["MockedElement"]; });

/* harmony import */ var _Promises__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./Promises */ "./Promises.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PromiseState", function() { return _Promises__WEBPACK_IMPORTED_MODULE_41__["PromiseState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Promise", function() { return _Promises__WEBPACK_IMPORTED_MODULE_41__["Promise"]; });

/**
 * The current Excalibur version string
 * @description `process.env.__EX_VERSION` gets replaced by Webpack on build
 */
const EX_VERSION = "0.25.0-alpha.7566+c37e999";

Object(_Polyfill__WEBPACK_IMPORTED_MODULE_0__["polyfill"])();
// This file is used as the bundle entry point and exports everything
// that will be exposed as the `ex` global variable.






























// ex.Events namespace


// ex.Input namespace


// ex.Traits namespace


// ex.Util namespaces









// ex.Deprecated

// import * as deprecated from './Deprecated';
// export { deprecated as Deprecated };
// export * from './Deprecated';


/***/ })

/******/ });
});